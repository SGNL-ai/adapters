// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type AccountDescriptor interface {
	IsAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
}

// A specialized abstract account descriptor for all Active Directory container sources.
type ActiveDirectoryContainerAccountDescriptor interface {
	IsActiveDirectoryContainerAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetCn() *string
	// The creation time of the container.
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDescription() *string
	// The entry's distinguished name (DN) in LDAP.
	GetDn() string
	// The Active Directory domain under which the entry is defined.
	GetDomain() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetLastUpdateTime() string
	// The container's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).
	GetObjectGUID() string
	// If the container is part of an Active Directory Organizational Unit, this
	// attribute represents its [name in canonical format](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-canonicalname).
	GetOu() *string
}

// A specialized abstract `AccountDescriptor` interface for Active Directory LDAP entry sources.
type ActiveDirectoryEntryDescriptor interface {
	IsActiveDirectoryEntryDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetCn() *string
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDescription() *string
	// The entry's distinguished name (DN) in LDAP.
	GetDn() string
	// The Active Directory domain under which the entry is defined.
	GetDomain() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetLastUpdateTime() string
}

type ActiveDirectoryGroupRole interface {
	IsActiveDirectoryGroupRole()
	GetBuiltin() bool
	GetScope() ActiveDirectoryGroupScope
}

// A specialized abstract `AccountDescriptor` interface for Active Directory LDAP entry sources.
type ActiveDirectorySecurityPrincipalAccountDescriptor interface {
	IsActiveDirectorySecurityPrincipalAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetCn() *string
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDescription() *string
	// The entry's distinguished name (DN) in LDAP.
	GetDn() string
	// The Active Directory domain under which the entry is defined.
	GetDomain() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetLastUpdateTime() string
	// The account's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).
	GetObjectGUID() string
	// The account's [Object-Sid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectsid).
	GetObjectSid() string
	// The account's [SAM-Account-Name attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-samaccountname).
	GetSamAccountName() string
}

// An abstract `AccountDescriptor` interface common to all accounts that participate in the network activity.
type ActivityParticipatingAccountDescriptor interface {
	IsActivityParticipatingAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	GetMostRecentActivity() *string
}

// An abstract `Entity` interface common to all entities that participate in the
// network activity, as opposed to entities defined by their place in the
// organization structure.
type ActivityParticipatingEntity interface {
	IsActivityParticipatingEntity()
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	GetAccounts() []AccountDescriptor
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	GetArchived() bool
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	GetAssociations() []Association
	GetCreationTime() string
	// The date and time of the entity's earliest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	GetEarliestSeenTraffic() *string
	// The entity's unique identifier.
	GetEntityID() string
	GetHasADDomainAdminRole() *bool
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	GetHasRole() *bool
	// If `true`, the entity is inactive. An entity is considered inactive after 21
	// days since its latest recorded network activity (see `mostRecentActivity`).
	GetInactive() bool
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	GetLearned() bool
	// For marked entities, this is set to the last time the entity was marked.
	GetMarkTime() *string
	// The date and time of the entity's latest recorded network activity. This takes
	// into account both the data reported by external sources and the actual traffic
	// seen by the system.
	GetMostRecentActivity() *string
	// Query open incidents for this entity.
	GetOpenIncidents() *IncidentConnection
	// The primary display name used to represent this entity in user-facing data.
	//
	// The primary display name is typically shorter than the secondary display name,
	// but is much less likely to be unique across the organization or network. For
	// further details on the semantics, see the documentation for specific types.
	GetPrimaryDisplayName() string
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	GetRiskFactors() []EntityRiskFactor
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	GetRiskScore() string
	// The entity's risk score derived from `riskScore`.
	GetRiskScoreSeverity() ScoreSeverity
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	GetRoles() []EntityRole
	// The secondary display name is used to represent unique name for this entity in the organization or the network.
	GetSecondaryDisplayName() string
	// If `true`, the entity is stale. An entity is considered stale after 90 days of
	// inactivity (see `mostRecentActivity`), as long as it is still effectively part
	// of the network. An account-based entity is not considered part of the network
	// when all of its base accounts are disabled (see `primaryAccount` and
	// `secondaryAccounts`).
	GetStale() bool
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	GetType() EntityType
	// If `true`, this entity appears on the system watchlist.
	GetWatched() bool
}

type AdminAccountRole interface {
	IsAdminAccountRole()
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type ApplicationServerRole interface {
	IsApplicationServerRole()
	GetConfirmed() bool
	GetFullPath() *string
	GetImpersonator() bool
	GetProbability() *float64
	GetType() EntityRoleType
}

// An association between two entities. The nature of the association and the specific subtype are determined by `bindingType`.
//
// **Symmetric vs. Asymmetric**: Depending on the binding type, an association can
// be symmetric or asymmetric. A symmetric association is set on both participating
// entities, each pointing to the other one. For example, the `LOGIN` association
// is symmetric. Therefore, if a user has a `LOGIN` association with an endpoint,
// the endpoint should have the same association with the user. Conversely, if a
// user has a `SERVICE_ACCESS` association with a server, the server is not
// supposed to have the same association with the user, because the
// `SERVICE_ACCESS` association is asymmetric. The documentation for `BindingType`
// specifies which binding types are symmetric and which are asymmetric.
type Association interface {
	IsAssociation()
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	GetBindingType() BindingType
}

type AwsIcSsoAccountDescriptor interface {
	IsAwsIcSsoAccountDescriptor()
	GetAwsAccountID() *string
	GetAwsOrganizationID() *string
}

type AzurePrivilegedRole interface {
	IsAzurePrivilegedRole()
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetAuthorizingRoleIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type ClassificationRole interface {
	IsClassificationRole()
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

// A specialized `AccountDescriptor` for SSO cloud service accounts.
type CloudServiceAdapterDescriptor interface {
	IsCloudServiceAdapterDescriptor()
	// The ID of the tenant in which the application is registered.
	GetAppOwnerOrganizationID() *string
	// The ID of the registered application.
	GetAppRegistrationObjectID() *string
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetContainingGroupEntities() []*EntityContainerEntity
	GetContainingGroupIds() []string
	GetContainingRoleEntities() []*EntityContainerEntity
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	// The ID of the connector configuration associated with this account.
	GetDataSourceConfigurationIdentifier() string
	// A unique identifier the connector uses to identify this account.
	GetDataSourceParticipantIdentifier() string
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetFlattenedContainingGroupEntities() []*EntityContainerEntity
	GetFlattenedContainingGroupIds() []string
	GetFlattenedContainingRoleEntities() []*EntityContainerEntity
	// The last time the service principal was accessed.
	GetLastAccessTime() *string
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	GetMostRecentActivity() *string
	// The domain name of the application publisher.
	GetPublisherDomain() *string
	GetRegisteredTenantType() *RegisteredTenantType
	GetServicePrincipalObjectID() *string
	// The type of access this application allows.
	GetSignInAudience() *SignInAudience
	GetTenant() *string
}

type ContainerRole interface {
	IsContainerRole()
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type DomainControllersAdminRole interface {
	IsDomainControllersAdminRole()
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type DomainLevelAdminRole interface {
	IsDomainLevelAdminRole()
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type EffectiveAdminRole interface {
	IsEffectiveAdminRole()
	GetAffectedEntities() []Entity
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetEffectedEntityIds() []string
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type EngagementSummary interface {
	IsEngagementSummary()
	GetEngagementType() EngagementType
}

// An *Entity* object encapsulates and summarizes all the system information on an
// organizational or network entity. The most common entities are users and
// endpoints, but there are also entities representing cloud services and entity
// groups, such as Active Directory groups. More entity types are expected to be
// added in the future.
//
// Entity objects are usually derived from external data sources. For instance, all
// covered user accounts in an Active Directory domain are represented as entities.
// However, entities very often integrate data from multiple sources. The network
// traffic monitored by the system is a primary source for behavioral attributes of
// entities, such as the human versus programmatic classification or the
// association of owned endpoints (see `roles`, `associations`). Moreover, entities
// not always represent a single account: an LDAP user, for example, may be
// correlated with an IDaaS account, resulting in a single, unified entity.
//
// Entities are polymorphic. Attributes for specific entity types can be projected
// from a specialized interface (e.g. `UserOrEndpointEntity`, `EndpointEntity`).
// See the `EntityType` enum documentation for the mapping between entity types and
// entity interfaces.
type Entity interface {
	IsEntity()
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	GetAccounts() []AccountDescriptor
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	GetArchived() bool
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	GetAssociations() []Association
	GetCreationTime() string
	// The entity's unique identifier.
	GetEntityID() string
	GetHasADDomainAdminRole() *bool
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	GetHasRole() *bool
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	GetLearned() bool
	// For marked entities, this is set to the last time the entity was marked.
	GetMarkTime() *string
	// Query open incidents for this entity.
	GetOpenIncidents() *IncidentConnection
	// The primary display name used to represent this entity in user-facing data.
	//
	// The primary display name is typically shorter than the secondary display name,
	// but is much less likely to be unique across the organization or network. For
	// further details on the semantics, see the documentation for specific types.
	GetPrimaryDisplayName() string
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	GetRiskFactors() []EntityRiskFactor
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	GetRiskScore() string
	// The entity's risk score derived from `riskScore`.
	GetRiskScoreSeverity() ScoreSeverity
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	GetRoles() []EntityRole
	// The secondary display name is used to represent unique name for this entity in the organization or the network.
	GetSecondaryDisplayName() string
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	GetType() EntityType
	// If `true`, this entity appears on the system watchlist.
	GetWatched() bool
}

// A specialized `Association` type for entity associations
type EntityAssociation interface {
	IsEntityAssociation()
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	GetBindingType() BindingType
	// The associated entity.
	GetEntity() Entity
}

type EntityRiskFactor interface {
	IsEntityRiskFactor()
	GetScore() string
	GetSeverity() ScoreSeverity
	GetType() RiskFactorType
}

type EntityRole interface {
	IsEntityRole()
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

// An error descriptor. This common interface contains just a human-readable error
// message. For more structural data which can be used programmatically, see the
// specialized sub-types of this interface.
type ErrorDetails interface {
	IsErrorDetails()
	// A human-readable error message describing an error or failure.
	GetMessage() string
}

type ForestLevelAdminRole interface {
	IsForestLevelAdminRole()
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type MailingListRole interface {
	IsMailingListRole()
	GetBuiltin() bool
	GetConfirmed() bool
	GetEmailAddresses() []string
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type OperatorLevelAdminRole interface {
	IsOperatorLevelAdminRole()
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type PasswordAttributes interface {
	IsPasswordAttributes()
	GetAged() bool
	GetExposed() bool
	GetLastChange() *string
	GetMayExpire() bool
	GetStrength() PasswordStrength
}

type PermissionAssignerRole interface {
	IsPermissionAssignerRole()
	GetBuiltin() bool
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type ProgrammaticUserAccountRole interface {
	IsProgrammaticUserAccountRole()
	GetConfirmed() bool
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

type ServerRole interface {
	IsServerRole()
	GetConfirmed() bool
	GetFullPath() *string
	GetImpersonator() bool
	GetProbability() *float64
	GetType() EntityRoleType
}

type ServiceDelegationAdminRole interface {
	IsServiceDelegationAdminRole()
	GetAffectedEntities() []Entity
	GetAuthorizingContainingEntitiesIds() []string
	GetAuthorizingGroupIds() []string
	GetBuiltin() bool
	GetConfirmed() bool
	GetEffectedEntityIds() []string
	GetFullPath() *string
	GetProbability() *float64
	GetType() EntityRoleType
}

// A specialized `Association` type for entity associations
type SimulatableAssociation interface {
	IsSimulatableAssociation()
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	GetBindingType() BindingType
	// The associated entity.
	GetEntity() Entity
	GetSimulated() bool
}

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type SsoGroupAccountDescriptor interface {
	IsSsoGroupAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetContainingGroupEntities() []*EntityContainerEntity
	GetContainingGroupIds() []string
	GetContainingRoleEntities() []*EntityContainerEntity
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDataSourceConfigurationIdentifier() string
	GetDataSourceParticipantIdentifier() string
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetFlattenedContainingGroupEntities() []*EntityContainerEntity
	GetFlattenedContainingGroupIds() []string
	GetFlattenedContainingRoleEntities() []*EntityContainerEntity
	GetTenant() *string
}

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type SsoRoleAccountDescriptor interface {
	IsSsoRoleAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDataSourceConfigurationIdentifier() string
	GetDataSourceParticipantIdentifier() string
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetTenant() *string
}

// A specialized `AccountDescriptor` for SSO user accounts.
type SsoUserAccountDescriptor interface {
	IsSsoUserAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetContainingEntities() []*EntityContainerEntity
	GetContainingGroupEntities() []*EntityContainerEntity
	GetContainingGroupIds() []string
	GetContainingRoleEntities() []*EntityContainerEntity
	GetCreationTime() string
	GetCredentialsDataSource() *DataSource
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	// The ID of the connector configuration associated with this account.
	GetDataSourceConfigurationIdentifier() string
	GetDataSourceLoginIdentifier() *string
	// A unique identifier used by the connector to identify this account.
	GetDataSourceParticipantIdentifier() string
	GetDepartment() *string
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetFlattenedContainingGroupEntities() []*EntityContainerEntity
	GetFlattenedContainingGroupIds() []string
	GetFlattenedContainingRoleEntities() []*EntityContainerEntity
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	GetMostRecentActivity() *string
	// Information regarding the account's password.
	GetPasswordAttributes() PasswordAttributes
	GetTenant() *string
	GetTitle() *string
}

// A common interface for all events exposed by the `timeline` API.
type TimelineAuditEvent interface {
	IsTimelineAuditEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A `TimelineEvent` interface common to successful and failed authentication `timeline` events.
type TimelineAuthenticationEvent interface {
	IsTimelineAuthenticationEvent()
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	GetActiveDirectorySiteName() *string
	// The authentication type.
	GetAuthenticationType() AuthenticationType
	GetBrowserInfo() *BrowserInfo
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	GetDataSource() DataSource
	// A display-oriented label for the data source associated with the activity.
	GetDataSourceVendorName() *string
	GetDeviceName() *string
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	GetDeviceType() *string
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	GetEndpointDisplayName() *string
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	GetEndpointEntity() *EndpointEntity
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// The geolocation associated with the activity, if any.
	GetGeoLocation() *GeoLocation
	// The origin endpoint host name.
	GetHostName() *string
	// The origin endpoint IP address, if available.
	GetIPAddress() *string
	GetIPAddressReputations() []IPReputation
	GetIspClassification() *IspClassification
	GetIspDomain() *string
	// The list of Kerberos encryption types specified by the client. Only set for
	// activities performed over the Kerberos protocol (see `protocolType`),
	GetKerberosEncryptionTypes() []KerberosEncryptionType
	GetLdapSecurityType() *LdapSecurityType
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	GetLocationAssociatedWithUser() *bool
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	GetNetworkTag() *string
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	GetNetworkType() NetworkType
	// Information about the origin endpoint operating system.
	GetOperatingSystemInfo() *OperatingSystemInfo
	// The primary network protocol used for performing the activity.
	GetProtocolType() ProtocolType
	GetProtocolVersion() *string
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	GetSmbDialect() *SmbDialect
	GetSourceEntity() UserOrEndpointEntity
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The target endpoint associated with this activity (such as a domain controller), if any.
	GetTargetEndpointEntity() *EndpointEntity
	// The target service entity.
	GetTargetEntity() Entity
	GetTargetServiceDescription() *string
	GetTargetServiceDisplayName() *string
	// The target service raw identifier.
	GetTargetServiceIdentifier() *string
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	GetTargetServiceType() *ServiceType
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
	GetTLSVersion() *TLSVersion
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	GetUserDisplayName() string
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	GetUserEntity() *UserEntity
}

// A common interface for all events exposed by the `timeline` API.
type TimelineConfigurationReportEvent interface {
	IsTimelineConfigurationReportEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// A unique identifier for the report.
	GetReportID() string
	// The report name.
	GetReportName() string
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A common interface for all events exposed by the `timeline` API.
type TimelineConnectorConfigurationEvent interface {
	IsTimelineConnectorConfigurationEvent()
	GetCategory() string
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
	GetType() string
}

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineDomainControllerNotificationEvent interface {
	IsTimelineDomainControllerNotificationEvent()
	// The domain controller entity.
	GetDomainControllerEntity() *EndpointEntity
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The system notification status.
	GetState() *NotificationState
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityEvent interface {
	IsTimelineEntityEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// The `Entity` associated with this event.
	GetEntity() Entity
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A `TimelineEvent` interface common to `timeline` events indicating an error or a failure.
type TimelineErrorEvent interface {
	IsTimelineErrorEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// Information regarding the error.
	GetErrorDetails() ErrorDetails
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A common interface for all events exposed by the `timeline` API.
type TimelineEvent interface {
	IsTimelineEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A specialized `TimelineEvent` interface common to `timeline` event types associated with the life cycle of an incident.
type TimelineIncidentLifeCycleEvent interface {
	IsTimelineIncidentLifeCycleEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// The containing incident of the alert.
	GetIncident() *Incident
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A `TimelineEvent` interface common to system notification `timeline` events.
type TimelineNotificationEvent interface {
	IsTimelineNotificationEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The system notification status.
	GetState() *NotificationState
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyConfigurationEvent interface {
	IsTimelinePolicyConfigurationEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicySingleRuleChangedEvent interface {
	IsTimelinePolicySingleRuleChangedEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	GetRuleID() string
	GetRuleName() string
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A common interface for all events exposed by the `timeline` API.
type TimelineSystemConfigurationEvent interface {
	IsTimelineSystemConfigurationEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A common interface for all events exposed by the `timeline` API.
type TimelineUserEngagementChangedEvent interface {
	IsTimelineUserEngagementChangedEvent()
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	GetSystemComponent() SystemComponent
	GetSystemUser() *SystemUser
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
}

// A `TimelineEvent` interface common to `timeline` events related to end user
// activity on endpoints, such as authentication and service access activities.
// This is the primary interface to be used in projections when querying the
// timeline for `user` activities.
//
// When available, the user and endpoint `Entity` data is exposed through the
// corresponding fields. However, in some cases the data regarding the user or
// endpoint may be too limited to be associated with particular entities. For
// example, a `FAILED_AUTHENTICATION` event may be a result of a misspelled user
// name, and a `SUCCESSFUL_AUTHENTICATION` may originate outside the organization,
// limiting the available data about the source endpoint. For this reason,
// additional fields exposing more elementary data are also available, alongside
// the `Entity` fields.
type TimelineUserOnEndpointActivityEvent interface {
	IsTimelineUserOnEndpointActivityEvent()
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	GetActiveDirectorySiteName() *string
	GetBrowserInfo() *BrowserInfo
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	GetDataSource() DataSource
	// A display-oriented label for the data source associated with the activity.
	GetDataSourceVendorName() *string
	GetDeviceName() *string
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	GetDeviceType() *string
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	GetEndTime() string
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	GetEndpointDisplayName() *string
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	GetEndpointEntity() *EndpointEntity
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	GetEventID() string
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	GetEventLabel() string
	// The event severity. Defaults to `NEUTRAL`.
	GetEventSeverity() TimelineEventSeverity
	// The event type.
	GetEventType() TimelineEventType
	// The geolocation associated with the activity, if any.
	GetGeoLocation() *GeoLocation
	// The origin endpoint host name.
	GetHostName() *string
	// The origin endpoint IP address, if available.
	GetIPAddress() *string
	GetIPAddressReputations() []IPReputation
	GetIspClassification() *IspClassification
	GetIspDomain() *string
	GetLdapSecurityType() *LdapSecurityType
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	GetLocationAssociatedWithUser() *bool
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	GetNetworkTag() *string
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	GetNetworkType() NetworkType
	// Information about the origin endpoint operating system.
	GetOperatingSystemInfo() *OperatingSystemInfo
	// The primary network protocol used for performing the activity.
	GetProtocolType() ProtocolType
	GetProtocolVersion() *string
	// A connection of related events.
	GetRelatedEvents() *TimelineEventConnection
	GetSourceEntity() UserOrEndpointEntity
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	GetStartTime() string
	// The target endpoint associated with this activity (such as a domain controller), if any.
	GetTargetEndpointEntity() *EndpointEntity
	// The target service entity.
	GetTargetEntity() Entity
	GetTargetServiceDescription() *string
	GetTargetServiceDisplayName() *string
	// The target service raw identifier.
	GetTargetServiceIdentifier() *string
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	GetTargetServiceType() *ServiceType
	// The event start time. This is the primary sort-key in `timeline` queries.
	GetTimestamp() string
	GetTLSVersion() *TLSVersion
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	GetUserDisplayName() string
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	GetUserEntity() *UserEntity
}

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type UserAccountDescriptor interface {
	IsUserAccountDescriptor()
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	GetArchived() bool
	GetContainingEntities() []*EntityContainerEntity
	GetCreationTime() string
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	GetDataSource() DataSource
	GetDepartment() *string
	GetDescription() *string
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	GetEnabled() bool
	GetPasswordAttributes() PasswordAttributes
	GetTitle() *string
}

// An abstract `Entity` interface similar to `UserEntity` and `EndpointEntity`. It is used to simplify common projections.
type UserOrEndpointEntity interface {
	IsUserOrEndpointEntity()
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	GetAccounts() []AccountDescriptor
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	GetArchived() bool
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	GetAssociations() []Association
	GetCreationTime() string
	// The date and time of the entity's earliest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	GetEarliestSeenTraffic() *string
	// The entity's unique identifier.
	GetEntityID() string
	GetHasADDomainAdminRole() *bool
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	GetHasRole() *bool
	// The latest calculated impact score for this entity.
	GetImpactScore() string
	// If `true`, the entity is inactive. An entity is considered inactive after 21
	// days since its latest recorded network activity (see `mostRecentActivity`).
	GetInactive() bool
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	GetLearned() bool
	// For marked entities, this is set to the last time the entity was marked.
	GetMarkTime() *string
	// The date and time of the entity's latest recorded network activity. This takes
	// into account both the data reported by external sources and the actual traffic
	// seen by the system.
	GetMostRecentActivity() *string
	// Query open incidents for this entity.
	GetOpenIncidents() *IncidentConnection
	// The primary display name used to represent this entity in user-facing data.
	//
	// The primary display name is typically shorter than the secondary display name,
	// but is much less likely to be unique across the organization or network. For
	// further details on the semantics, see the documentation for specific types.
	GetPrimaryDisplayName() string
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	GetRiskFactors() []EntityRiskFactor
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	GetRiskScore() string
	// The entity's risk score derived from `riskScore`.
	GetRiskScoreSeverity() ScoreSeverity
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	GetRoles() []EntityRole
	// The secondary display name is used to represent unique name for this entity in the organization or the network.
	GetSecondaryDisplayName() string
	// Returns `true` if the system considers this entity shared.
	GetShared() bool
	// If `true`, the entity is stale. An entity is considered stale after 90 days of
	// inactivity (see `mostRecentActivity`), as long as it is still effectively part
	// of the network. An account-based entity is not considered part of the network
	// when all of its base accounts are disabled (see `primaryAccount` and
	// `secondaryAccounts`).
	GetStale() bool
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	GetType() EntityType
	// If `true`, this entity appears on the system watchlist.
	GetWatched() bool
}

type AccountDescriptorImpl struct {
	Archived     bool       `json:"archived"`
	CreationTime string     `json:"creationTime"`
	DataSource   DataSource `json:"dataSource"`
	Description  *string    `json:"description,omitempty"`
	Enabled      bool       `json:"enabled"`
}

func (AccountDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AccountDescriptorImpl) GetArchived() bool       { return this.Archived }
func (this AccountDescriptorImpl) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AccountDescriptorImpl) GetDataSource() DataSource { return this.DataSource }
func (this AccountDescriptorImpl) GetDescription() *string   { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AccountDescriptorImpl) GetEnabled() bool { return this.Enabled }

type AccountOperatorsAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AccountOperatorsAdminRole) IsOperatorLevelAdminRole() {}
func (this AccountOperatorsAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AccountOperatorsAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AccountOperatorsAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this AccountOperatorsAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this AccountOperatorsAdminRole) GetFullPath() *string     { return this.FullPath }
func (this AccountOperatorsAdminRole) GetProbability() *float64 { return this.Probability }
func (this AccountOperatorsAdminRole) GetType() EntityRoleType  { return this.Type }

func (AccountOperatorsAdminRole) IsAdminAccountRole() {}

func (AccountOperatorsAdminRole) IsEntityRole() {}

// A specialized `AccountDescriptor` for Active Directory accounts (users and endpoints).
type ActiveDirectoryAccountDescriptor struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived           bool                     `json:"archived"`
	Cn                 *string                  `json:"cn,omitempty"`
	ConsistencyGUID    *string                  `json:"consistencyGuid,omitempty"`
	ContainingEntities []*EntityContainerEntity `json:"containingEntities"`
	// List of Active Directory group entities this entity is a direct member of. If
	// you wish to also list indirect ancestor groups, project
	// `flattenedContainingGroupEntities` instead.
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	// The creation time of the account.
	CreationTime string `json:"creationTime"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource DataSource `json:"dataSource"`
	// The department that the account belongs to.
	Department  *string `json:"department,omitempty"`
	Description *string `json:"description,omitempty"`
	// The entry's distinguished name (DN) in LDAP.
	Dn string `json:"dn"`
	// The Active Directory domain under which the entry is defined.
	Domain *string `json:"domain,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled bool `json:"enabled"`
	// The account's [expiration time](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-accountexpires).
	ExpirationTime *string `json:"expirationTime,omitempty"`
	// List of Active Directory group entities this entity is a member of. If you
	// wish to only list direct ancestor groups, project `containingGroupEntities` instead.
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	LastUpdateTime                   string                   `json:"lastUpdateTime"`
	// If the account is currently locked out, this attribute contains the date and time when the lockout occurred.
	LockoutTime *string `json:"lockoutTime,omitempty"`
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// The account's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).
	ObjectGUID string `json:"objectGuid"`
	// The account's [Object-Sid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectsid).
	ObjectSid string `json:"objectSid"`
	// If the account is part of an Active Directory Organizational Unit, this
	// attribute represents its [name in canonical format](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-canonicalname/).
	Ou *string `json:"ou,omitempty"`
	// Comprehensive information about the account's password, except the password itself.
	PasswordAttributes *ActiveDirectoryPasswordAttributes `json:"passwordAttributes,omitempty"`
	// The account's [SAM account name](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-samaccountname).
	SamAccountName string `json:"samAccountName"`
	// The account's [Service Principal Names (SPNs)](https://docs.microsoft.com/en-us/windows/desktop/ad/service-principal-names).
	ServicePrincipalNames []string `json:"servicePrincipalNames"`
	Title                 *string  `json:"title,omitempty"`
	// The account's [User Principal Name (UPN)](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-userprincipalname).
	Upn                *string `json:"upn,omitempty"`
	UserAccountControl int     `json:"userAccountControl"`
	// The list of property [User Account Control Flags](https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties#list-of-property-flags).
	UserAccountControlFlags []UserAccountControlFlags `json:"userAccountControlFlags,omitempty"`
}

func (ActiveDirectoryAccountDescriptor) IsActivityParticipatingAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this ActiveDirectoryAccountDescriptor) GetArchived() bool       { return this.Archived }
func (this ActiveDirectoryAccountDescriptor) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this ActiveDirectoryAccountDescriptor) GetDataSource() DataSource { return this.DataSource }
func (this ActiveDirectoryAccountDescriptor) GetDescription() *string   { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this ActiveDirectoryAccountDescriptor) GetEnabled() bool { return this.Enabled }

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this ActiveDirectoryAccountDescriptor) GetMostRecentActivity() *string {
	return this.MostRecentActivity
}

func (ActiveDirectoryAccountDescriptor) IsActiveDirectorySecurityPrincipalAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

func (this ActiveDirectoryAccountDescriptor) GetCn() *string { return this.Cn }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// The entry's distinguished name (DN) in LDAP.
func (this ActiveDirectoryAccountDescriptor) GetDn() string { return this.Dn }

// The Active Directory domain under which the entry is defined.
func (this ActiveDirectoryAccountDescriptor) GetDomain() *string { return this.Domain }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (this ActiveDirectoryAccountDescriptor) GetLastUpdateTime() string { return this.LastUpdateTime }

// The account's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).
func (this ActiveDirectoryAccountDescriptor) GetObjectGUID() string { return this.ObjectGUID }

// The account's [Object-Sid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectsid).
func (this ActiveDirectoryAccountDescriptor) GetObjectSid() string { return this.ObjectSid }

// The account's [SAM-Account-Name attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-samaccountname).
func (this ActiveDirectoryAccountDescriptor) GetSamAccountName() string { return this.SamAccountName }

func (ActiveDirectoryAccountDescriptor) IsUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

func (this ActiveDirectoryAccountDescriptor) GetContainingEntities() []*EntityContainerEntity {
	if this.ContainingEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingEntities))
	for _, concrete := range this.ContainingEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

func (this ActiveDirectoryAccountDescriptor) GetDepartment() *string { return this.Department }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (this ActiveDirectoryAccountDescriptor) GetPasswordAttributes() PasswordAttributes {
	return *this.PasswordAttributes
}
func (this ActiveDirectoryAccountDescriptor) GetTitle() *string { return this.Title }

func (ActiveDirectoryAccountDescriptor) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (ActiveDirectoryAccountDescriptor) IsActiveDirectoryEntryDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// The entry's distinguished name (DN) in LDAP.

// The Active Directory domain under which the entry is defined.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// A specialized `AccountDescriptor` for Active Directory groups.
type ActiveDirectoryGroupAccountDescriptor struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived bool    `json:"archived"`
	Cn       *string `json:"cn,omitempty"`
	// List of Active Directory group entities this entity is a direct member of. If
	// you wish to also list indirect ancestor groups, project
	// `flattenedContainingGroupEntities` instead.
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	// The creation time of the container.
	CreationTime string `json:"creationTime"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource  DataSource `json:"dataSource"`
	Description *string    `json:"description,omitempty"`
	// The entry's distinguished name (DN) in LDAP.
	Dn string `json:"dn"`
	// The Active Directory domain under which the entry is defined.
	Domain *string `json:"domain,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled bool `json:"enabled"`
	// List of Active Directory group entities this entity is a member of. If you
	// wish to only list direct ancestor groups, project `containingGroupEntities` instead.
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	LastUpdateTime                   string                   `json:"lastUpdateTime"`
	LocalGroup                       bool                     `json:"localGroup"`
	// The container's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).
	ObjectGUID string `json:"objectGuid"`
	// The account's [Object-Sid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectsid).
	ObjectSid string `json:"objectSid"`
	// If the container is part of an Active Directory Organizational Unit, this
	// attribute represents its [name in canonical format](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-canonicalname).
	Ou *string `json:"ou,omitempty"`
	// The account's [SAM-Account-Name attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-samaccountname).
	SamAccountName string `json:"samAccountName"`
	SecurityGroup  bool   `json:"securityGroup"`
}

func (ActiveDirectoryGroupAccountDescriptor) IsActiveDirectoryContainerAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this ActiveDirectoryGroupAccountDescriptor) GetArchived() bool { return this.Archived }
func (this ActiveDirectoryGroupAccountDescriptor) GetCn() *string    { return this.Cn }

// The creation time of the container.
func (this ActiveDirectoryGroupAccountDescriptor) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this ActiveDirectoryGroupAccountDescriptor) GetDataSource() DataSource { return this.DataSource }
func (this ActiveDirectoryGroupAccountDescriptor) GetDescription() *string   { return this.Description }

// The entry's distinguished name (DN) in LDAP.
func (this ActiveDirectoryGroupAccountDescriptor) GetDn() string { return this.Dn }

// The Active Directory domain under which the entry is defined.
func (this ActiveDirectoryGroupAccountDescriptor) GetDomain() *string { return this.Domain }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this ActiveDirectoryGroupAccountDescriptor) GetEnabled() bool { return this.Enabled }
func (this ActiveDirectoryGroupAccountDescriptor) GetLastUpdateTime() string {
	return this.LastUpdateTime
}

// The container's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).
func (this ActiveDirectoryGroupAccountDescriptor) GetObjectGUID() string { return this.ObjectGUID }

// If the container is part of an Active Directory Organizational Unit, this
// attribute represents its [name in canonical format](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-canonicalname).
func (this ActiveDirectoryGroupAccountDescriptor) GetOu() *string { return this.Ou }

func (ActiveDirectoryGroupAccountDescriptor) IsActiveDirectorySecurityPrincipalAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// The entry's distinguished name (DN) in LDAP.

// The Active Directory domain under which the entry is defined.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// The account's [Object-Guid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectguid).

// The account's [Object-Sid attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-objectsid).
func (this ActiveDirectoryGroupAccountDescriptor) GetObjectSid() string { return this.ObjectSid }

// The account's [SAM-Account-Name attribute](https://docs.microsoft.com/en-us/windows/desktop/adschema/a-samaccountname).
func (this ActiveDirectoryGroupAccountDescriptor) GetSamAccountName() string {
	return this.SamAccountName
}

func (ActiveDirectoryGroupAccountDescriptor) IsActiveDirectoryEntryDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// The entry's distinguished name (DN) in LDAP.

// The Active Directory domain under which the entry is defined.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (ActiveDirectoryGroupAccountDescriptor) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

type ActiveDirectoryGroupRoleImpl struct {
	Builtin bool                      `json:"builtin"`
	Scope   ActiveDirectoryGroupScope `json:"scope"`
}

func (ActiveDirectoryGroupRoleImpl) IsActiveDirectoryGroupRole()              {}
func (this ActiveDirectoryGroupRoleImpl) GetBuiltin() bool                    { return this.Builtin }
func (this ActiveDirectoryGroupRoleImpl) GetScope() ActiveDirectoryGroupScope { return this.Scope }

type ActiveDirectoryPasswordAttributes struct {
	Aged          bool    `json:"aged"`
	DiscoveryDate *string `json:"discoveryDate,omitempty"`
	// A descriptor object for the password policy currently applied to the subject
	// account, which may be either the Default Password Policy for its domain or a
	// Fine Grained Password Policy.
	//
	// ```graphql
	// #### Query effective policy for privileged users
	// {
	//     entities(roles: [AdminAccountRole]
	//              types: [USER]
	//              archived: false
	//              first: 5
	//              sortKey: RISK_SCORE
	//              sortOrder: DESCENDING)
	//     {
	//         nodes {
	//             primaryDisplayName
	//             secondaryDisplayName
	//             accounts
	//             {
	//                 ... on ActiveDirectoryAccountDescriptor
	//                 {
	//                     passwordAttributes
	//                     {
	//                         lastChange
	//                         strength
	//                         effectivePolicy {
	//                             # Source info
	//                             sourceType
	//                             displayName
	//
	//                             # Policy rank
	//                             policyRank
	//                             policyRankLevel
	//
	//                             # Policy details
	//                             complexityEnabled
	//                             minLength
	//                             minAge
	//                             maxAge
	//                             savedPreviousPasswordCount
	//                             reversibleEncryptionEnabled
	//                             failedAuthenticationAttemptsLockoutThreshold
	//                             lockoutDuration
	//                             lockoutObservationWindow
	//                         }
	//
	//                     }
	//                 }
	//             }
	//         }
	//     }
	// }
	// ```
	EffectivePolicy *AppliedActiveDirectoryPasswordPolicy `json:"effectivePolicy,omitempty"`
	Exposed         bool                                  `json:"exposed"`
	LastChange      *string                               `json:"lastChange,omitempty"`
	MayExpire       bool                                  `json:"mayExpire"`
	Strength        PasswordStrength                      `json:"strength"`
}

func (ActiveDirectoryPasswordAttributes) IsPasswordAttributes()              {}
func (this ActiveDirectoryPasswordAttributes) GetAged() bool                 { return this.Aged }
func (this ActiveDirectoryPasswordAttributes) GetExposed() bool              { return this.Exposed }
func (this ActiveDirectoryPasswordAttributes) GetLastChange() *string        { return this.LastChange }
func (this ActiveDirectoryPasswordAttributes) GetMayExpire() bool            { return this.MayExpire }
func (this ActiveDirectoryPasswordAttributes) GetStrength() PasswordStrength { return this.Strength }

// Query criteria for activity events.
// All specified criteria must be met for a result to match.
type ActivityQueryInput struct {
	// The query is a match if all specified conditions are true
	// ```graphql
	// ##### List service accesses, except the ones that weren’t using NTLM protocol and not File Shares service types
	// {
	//     timeline(types: [SERVICE_ACCESS]
	//              activityQuery: {
	//                  all: [
	//                      { not: { protocolTypes: [NTLM] }},
	//                      { not: { targetServiceTypes: [FILE_SHARE] }}
	//                  ]
	//               }
	//              first: 2)
	//     {
	//         nodes {
	//             eventType
	//             eventLabel
	//             ... on TimelineServiceAccessEvent {
	//                 protocolType
	//                 userEntity {
	//                     primaryDisplayName
	//                 }
	//                 targetServiceType
	//             }
	//         }
	//     }
	// }
	// ```
	All []*ActivityQueryInput `json:"all,omitempty"`
	// The query is a match if any of the specified conditions are true
	// ```graphql
	// ##### List service accesses for MAIL using NTLM or Remote Desktop using Kerberos
	// {
	//     timeline(types: [SERVICE_ACCESS]
	//              activityQuery: {
	//                  any: [
	//                      { protocolTypes: [NTLM], targetServiceTypes: [MAIL] },
	//                      { protocolTypes: [KERBEROS], targetServiceTypes: [REMOTE_DESKTOP] }
	//                  ]
	//               }
	//              last: 2)
	//     {
	//         nodes {
	//             eventType
	//             eventLabel
	//             ... on TimelineServiceAccessEvent {
	//                 protocolType
	//                 userEntity {
	//                     primaryDisplayName
	//                 }
	//             }
	//         }
	//     }
	// }
	// ```
	Any                       []*ActivityQueryInput      `json:"any,omitempty"`
	AuthenticationTypes       []AuthenticationType       `json:"authenticationTypes,omitempty"`
	Blocked                   *bool                      `json:"blocked,omitempty"`
	CertificateBasedAuth      *bool                      `json:"certificateBasedAuth,omitempty"`
	CityCodes                 []int                      `json:"cityCodes,omitempty"`
	CountryCodes              []string                   `json:"countryCodes,omitempty"`
	DataSourceCategories      []DataSourceCategory       `json:"dataSourceCategories,omitempty"`
	DataSources               []DataSource               `json:"dataSources,omitempty"`
	DcerpcSignatures          []DcerpcSignature          `json:"dcerpcSignatures,omitempty"`
	FileOperationTypes        []FileOperationType        `json:"fileOperationTypes,omitempty"`
	HasGeoLocation            *bool                      `json:"hasGeoLocation,omitempty"`
	IspDomains                []string                   `json:"ispDomains,omitempty"`
	KrbErrors                 []KrbErrCode               `json:"krbErrors,omitempty"`
	LdapBindErrors            []LdapBindResult           `json:"ldapBindErrors,omitempty"`
	LdapSearchQuerySignatures []LdapQuerySignature       `json:"ldapSearchQuerySignatures,omitempty"`
	LdapSecurityTypes         []LdapSecurityType         `json:"ldapSecurityTypes,omitempty"`
	LoginRelatedServiceAccess *bool                      `json:"loginRelatedServiceAccess,omitempty"`
	MsSpecificErrors          []ApplicationSpecificError `json:"msSpecificErrors,omitempty"`
	// The query is a match if this conditions are not true
	// ```graphql
	// ##### Show traffic based events from last 12 hours by privileged entities, except Files Shares
	// {
	//     timeline(startTime: "PT-12H"
	//              activityQuery: {
	//                  dataSourceCategories: [TRAFFIC]
	//                  not: { targetServiceTypes: [FILE_SHARE] }}
	//              sourceEntityQuery: { roles: [AdminAccountRole] }
	//              first: 2)
	//     {
	//         nodes {
	//             ... on TimelineEvent {
	//                 eventType
	//             }
	//             ... on TimelineUserOnEndpointActivityEvent {
	//                 userEntity {
	//                     primaryDisplayName
	//                 }
	//                 endpointEntity {
	//                     primaryDisplayName
	//                 }
	//                 ipAddress
	//             }
	//         }
	//     }
	// }
	// ```
	Not                                    *ActivityQueryInput `json:"not,omitempty"`
	NtlmErrors                             []NtlmErrorCode     `json:"ntlmErrors,omitempty"`
	ProtocolTypes                          []ProtocolType      `json:"protocolTypes,omitempty"`
	ProtocolVersions                       []string            `json:"protocolVersions,omitempty"`
	SmbDialects                            []SmbDialect        `json:"smbDialects,omitempty"`
	SourceEndpointHostNames                []string            `json:"sourceEndpointHostNames,omitempty"`
	SourceEndpointIPAddressReputations     []IPReputation      `json:"sourceEndpointIpAddressReputations,omitempty"`
	SourceEndpointIPAddresses              []string            `json:"sourceEndpointIpAddresses,omitempty"`
	SourceEndpointNetworkTags              []string            `json:"sourceEndpointNetworkTags,omitempty"`
	SourceEndpointNetworkTypes             []NetworkType       `json:"sourceEndpointNetworkTypes,omitempty"`
	SourceEndpointSiteEntityIds            []string            `json:"sourceEndpointSiteEntityIds,omitempty"`
	SourceEntityDataSourceLoginIdentifiers []string            `json:"sourceEntityDataSourceLoginIdentifiers,omitempty"`
	SsoErrors                              []SsoError          `json:"ssoErrors,omitempty"`
	StateCodes                             []string            `json:"stateCodes,omitempty"`
	TargetServiceClasses                   []string            `json:"targetServiceClasses,omitempty"`
	TargetServiceIdentifiers               []string            `json:"targetServiceIdentifiers,omitempty"`
	TargetServiceIsSourceEndpoint          *bool               `json:"targetServiceIsSourceEndpoint,omitempty"`
	TargetServiceTypes                     []ServiceType       `json:"targetServiceTypes,omitempty"`
	TLSVersions                            []TLSVersion        `json:"tlsVersions,omitempty"`
}

// Input data for `addCommentToIncident`.
type AddCommentToIncidentInput struct {
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The comment to be added.
	Comment string `json:"comment"`
	// The unique identifier of the incident to be updated (see `Incident:incidentId`).
	IncidentID string `json:"incidentId"`
}

type AddUserEntityAuthorizerInput struct {
	AuthorizerEntityQuery *EntityQueryInput `json:"authorizerEntityQuery"`
	ClientMutationID      *string           `json:"clientMutationId,omitempty"`
	EntityQuery           *EntityQueryInput `json:"entityQuery"`
}

type AdminAccountRoleImpl struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AdminAccountRoleImpl) IsAdminAccountRole() {}
func (this AdminAccountRoleImpl) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AdminAccountRoleImpl) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AdminAccountRoleImpl) GetBuiltin() bool         { return this.Builtin }
func (this AdminAccountRoleImpl) GetConfirmed() bool       { return this.Confirmed }
func (this AdminAccountRoleImpl) GetFullPath() *string     { return this.FullPath }
func (this AdminAccountRoleImpl) GetProbability() *float64 { return this.Probability }
func (this AdminAccountRoleImpl) GetType() EntityRoleType  { return this.Type }

func (AdminAccountRoleImpl) IsEntityRole() {}

type AdministratorsRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AdministratorsRole) IsDomainLevelAdminRole() {}
func (this AdministratorsRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AdministratorsRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AdministratorsRole) GetBuiltin() bool         { return this.Builtin }
func (this AdministratorsRole) GetConfirmed() bool       { return this.Confirmed }
func (this AdministratorsRole) GetFullPath() *string     { return this.FullPath }
func (this AdministratorsRole) GetProbability() *float64 { return this.Probability }
func (this AdministratorsRole) GetType() EntityRoleType  { return this.Type }

func (AdministratorsRole) IsAdminAccountRole() {}

func (AdministratorsRole) IsEntityRole() {}

type AlertQueryInput struct {
	AlertIds             []string    `json:"alertIds,omitempty"`
	MinimalAlertSeverity *float64    `json:"minimalAlertSeverity,omitempty"`
	PatternIds           []int       `json:"patternIds,omitempty"`
	Types                []AlertType `json:"types,omitempty"`
}

type ApplicationServerRoleImpl struct {
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Impersonator bool           `json:"impersonator"`
	Probability  *float64       `json:"probability,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (ApplicationServerRoleImpl) IsApplicationServerRole()      {}
func (this ApplicationServerRoleImpl) GetConfirmed() bool       { return this.Confirmed }
func (this ApplicationServerRoleImpl) GetFullPath() *string     { return this.FullPath }
func (this ApplicationServerRoleImpl) GetImpersonator() bool    { return this.Impersonator }
func (this ApplicationServerRoleImpl) GetProbability() *float64 { return this.Probability }
func (this ApplicationServerRoleImpl) GetType() EntityRoleType  { return this.Type }

func (ApplicationServerRoleImpl) IsServerRole() {}

func (ApplicationServerRoleImpl) IsClassificationRole() {}

func (ApplicationServerRoleImpl) IsEntityRole() {}

// A descriptor object for a password policy instance within an Active Directory domain.
type AppliedActiveDirectoryPasswordPolicy struct {
	// Returns *yes* if a password complexity policy is enabled and passwords are required to meet certain requirements.
	ComplexityEnabled bool `json:"complexityEnabled"`
	// The name of the currently applied password policy.
	DisplayName string `json:"displayName"`
	// The maximum number of failed logons after which the user account will be temporarily locked out.
	FailedAuthenticationAttemptsLockoutThreshold *int `json:"failedAuthenticationAttemptsLockoutThreshold,omitempty"`
	// Duration of the temporary account lockout if the maximum number of failed logons is reached.
	LockoutDuration string `json:"lockoutDuration"`
	// The observation time for lockout threshold. If there are no failed attempts,
	// the threshold counter is reset after this time.
	LockoutObservationWindow string `json:"lockoutObservationWindow"`
	// The period of time that a password can be used before the user is prompted to change it.
	MaxAge string `json:"maxAge"`
	// The period of time that a password must be used before the user can change it.
	MinAge string `json:"minAge"`
	// The minimum allowed number of characters in a user account password.
	MinLength int `json:"minLength"`
	// The password policy score represented as a number.
	PolicyRank string `json:"policyRank"`
	// The password policy score represented verbally.
	PolicyRankLevel ScoreLevel `json:"policyRankLevel"`
	// If *yes* is returned, reversible encryption is enabled. It means that the user
	// account password is stored in the reversible encryption format which is
	// insecure and not recommended.
	ReversibleEncryptionEnabled bool `json:"reversibleEncryptionEnabled"`
	// The number of unique new passwords associated with a user account before an old password can be reused.
	SavedPreviousPasswordCount int `json:"savedPreviousPasswordCount"`
	// The source of information about the password policy.
	SourceType ActiveDirectoryPasswordPolicySourceType `json:"sourceType"`
}

type AssociationImpl struct {
	BindingType BindingType `json:"bindingType"`
}

func (AssociationImpl) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this AssociationImpl) GetBindingType() BindingType { return this.BindingType }

type AttackPathBasedRiskFactor struct {
	AttackPath []*AttackPathNode `json:"attackPath"`
	Score      string            `json:"score"`
	Severity   ScoreSeverity     `json:"severity"`
	Type       RiskFactorType    `json:"type"`
}

func (AttackPathBasedRiskFactor) IsEntityRiskFactor()             {}
func (this AttackPathBasedRiskFactor) GetScore() string           { return this.Score }
func (this AttackPathBasedRiskFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this AttackPathBasedRiskFactor) GetType() RiskFactorType    { return this.Type }

type AttackPathNode struct {
	Entity     Entity             `json:"entity"`
	NextEntity Entity             `json:"nextEntity,omitempty"`
	Relation   AttackPathRelation `json:"relation"`
}

type AuthenticationAsAnyUserWithCertificateRequestAgentRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	CertificateAuthorityEndpoints    []string       `json:"certificateAuthorityEndpoints"`
	CertificateTemplateNames         []string       `json:"certificateTemplateNames"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AuthenticationAsAnyUserWithCertificateRequestAgentRole) IsEffectiveAdminRole() {}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetBuiltin() bool {
	return this.Builtin
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetConfirmed() bool {
	return this.Confirmed
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetFullPath() *string {
	return this.FullPath
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetProbability() *float64 {
	return this.Probability
}
func (this AuthenticationAsAnyUserWithCertificateRequestAgentRole) GetType() EntityRoleType {
	return this.Type
}

func (AuthenticationAsAnyUserWithCertificateRequestAgentRole) IsAdminAccountRole() {}

func (AuthenticationAsAnyUserWithCertificateRequestAgentRole) IsEntityRole() {}

type AuthenticationCertificateTemplateControllerRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Permissions                      []*Permission  `json:"permissions"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AuthenticationCertificateTemplateControllerRole) IsEffectiveAdminRole() {}
func (this AuthenticationCertificateTemplateControllerRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationCertificateTemplateControllerRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationCertificateTemplateControllerRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationCertificateTemplateControllerRole) GetBuiltin() bool { return this.Builtin }
func (this AuthenticationCertificateTemplateControllerRole) GetConfirmed() bool {
	return this.Confirmed
}
func (this AuthenticationCertificateTemplateControllerRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AuthenticationCertificateTemplateControllerRole) GetFullPath() *string {
	return this.FullPath
}
func (this AuthenticationCertificateTemplateControllerRole) GetProbability() *float64 {
	return this.Probability
}
func (this AuthenticationCertificateTemplateControllerRole) GetType() EntityRoleType {
	return this.Type
}

func (AuthenticationCertificateTemplateControllerRole) IsAdminAccountRole() {}

func (AuthenticationCertificateTemplateControllerRole) IsEntityRole() {}

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type AwsIcSsoGroupAccountDescriptorImpl struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived                bool                     `json:"archived"`
	AwsAccountID            *string                  `json:"awsAccountId,omitempty"`
	AwsOrganizationID       *string                  `json:"awsOrganizationId,omitempty"`
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	ContainingRoleEntities  []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime            string                   `json:"creationTime"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource                        DataSource `json:"dataSource"`
	DataSourceConfigurationIdentifier string     `json:"dataSourceConfigurationIdentifier"`
	DataSourceParticipantIdentifier   string     `json:"dataSourceParticipantIdentifier"`
	Description                       *string    `json:"description,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled                          bool                     `json:"enabled"`
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities  []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	Tenant                           *string                  `json:"tenant,omitempty"`
}

func (AwsIcSsoGroupAccountDescriptorImpl) IsSsoGroupAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AwsIcSsoGroupAccountDescriptorImpl) GetArchived() bool { return this.Archived }
func (this AwsIcSsoGroupAccountDescriptorImpl) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AwsIcSsoGroupAccountDescriptorImpl) GetDataSource() DataSource { return this.DataSource }
func (this AwsIcSsoGroupAccountDescriptorImpl) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AwsIcSsoGroupAccountDescriptorImpl) GetEnabled() bool { return this.Enabled }
func (this AwsIcSsoGroupAccountDescriptorImpl) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetTenant() *string { return this.Tenant }

func (AwsIcSsoGroupAccountDescriptorImpl) IsAwsIcSsoAccountDescriptor()  {}
func (this AwsIcSsoGroupAccountDescriptorImpl) GetAwsAccountID() *string { return this.AwsAccountID }
func (this AwsIcSsoGroupAccountDescriptorImpl) GetAwsOrganizationID() *string {
	return this.AwsOrganizationID
}

func (AwsIcSsoGroupAccountDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// A specialized `AccountDescriptor` for SSO user accounts.
type AwsIcSsoUserAccountDescriptorImpl struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived                bool                     `json:"archived"`
	AwsAccountID            *string                  `json:"awsAccountId,omitempty"`
	AwsOrganizationID       *string                  `json:"awsOrganizationId,omitempty"`
	ContainingEntities      []*EntityContainerEntity `json:"containingEntities"`
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	ContainingRoleEntities  []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime            string                   `json:"creationTime"`
	CredentialsDataSource   *DataSource              `json:"credentialsDataSource,omitempty"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource DataSource `json:"dataSource"`
	// The ID of the connector configuration associated with this account.
	DataSourceConfigurationIdentifier string  `json:"dataSourceConfigurationIdentifier"`
	DataSourceLoginIdentifier         *string `json:"dataSourceLoginIdentifier,omitempty"`
	// A unique identifier used by the connector to identify this account.
	DataSourceParticipantIdentifier string  `json:"dataSourceParticipantIdentifier"`
	Department                      *string `json:"department,omitempty"`
	Description                     *string `json:"description,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled                          bool                     `json:"enabled"`
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities  []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	FlattenedContainingRoleIds       []string                 `json:"flattenedContainingRoleIds,omitempty"`
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// Information regarding the account's password.
	PasswordAttributes PasswordAttributes `json:"passwordAttributes,omitempty"`
	Tenant             *string            `json:"tenant,omitempty"`
	Title              *string            `json:"title,omitempty"`
}

func (AwsIcSsoUserAccountDescriptorImpl) IsSsoUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AwsIcSsoUserAccountDescriptorImpl) GetArchived() bool { return this.Archived }
func (this AwsIcSsoUserAccountDescriptorImpl) GetContainingEntities() []*EntityContainerEntity {
	if this.ContainingEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingEntities))
	for _, concrete := range this.ContainingEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetCreationTime() string { return this.CreationTime }
func (this AwsIcSsoUserAccountDescriptorImpl) GetCredentialsDataSource() *DataSource {
	return this.CredentialsDataSource
}

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AwsIcSsoUserAccountDescriptorImpl) GetDataSource() DataSource { return this.DataSource }

// The ID of the connector configuration associated with this account.
func (this AwsIcSsoUserAccountDescriptorImpl) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetDataSourceLoginIdentifier() *string {
	return this.DataSourceLoginIdentifier
}

// A unique identifier used by the connector to identify this account.
func (this AwsIcSsoUserAccountDescriptorImpl) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetDepartment() *string  { return this.Department }
func (this AwsIcSsoUserAccountDescriptorImpl) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AwsIcSsoUserAccountDescriptorImpl) GetEnabled() bool { return this.Enabled }
func (this AwsIcSsoUserAccountDescriptorImpl) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this AwsIcSsoUserAccountDescriptorImpl) GetMostRecentActivity() *string {
	return this.MostRecentActivity
}

// Information regarding the account's password.
func (this AwsIcSsoUserAccountDescriptorImpl) GetPasswordAttributes() PasswordAttributes {
	return this.PasswordAttributes
}
func (this AwsIcSsoUserAccountDescriptorImpl) GetTenant() *string { return this.Tenant }
func (this AwsIcSsoUserAccountDescriptorImpl) GetTitle() *string  { return this.Title }

func (AwsIcSsoUserAccountDescriptorImpl) IsAwsIcSsoAccountDescriptor()  {}
func (this AwsIcSsoUserAccountDescriptorImpl) GetAwsAccountID() *string { return this.AwsAccountID }
func (this AwsIcSsoUserAccountDescriptorImpl) GetAwsOrganizationID() *string {
	return this.AwsOrganizationID
}

func (AwsIcSsoUserAccountDescriptorImpl) IsActivityParticipatingAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

func (AwsIcSsoUserAccountDescriptorImpl) IsUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (AwsIcSsoUserAccountDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

type AzureAccessPrivilegesRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	AuthorizingRoleIds               []string       `json:"authorizingRoleIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AzureAccessPrivilegesRole) IsAzurePrivilegedRole() {}
func (this AzureAccessPrivilegesRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureAccessPrivilegesRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureAccessPrivilegesRole) GetAuthorizingRoleIds() []string {
	if this.AuthorizingRoleIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingRoleIds))
	for _, concrete := range this.AuthorizingRoleIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureAccessPrivilegesRole) GetBuiltin() bool         { return this.Builtin }
func (this AzureAccessPrivilegesRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureAccessPrivilegesRole) GetFullPath() *string     { return this.FullPath }
func (this AzureAccessPrivilegesRole) GetProbability() *float64 { return this.Probability }
func (this AzureAccessPrivilegesRole) GetType() EntityRoleType  { return this.Type }

func (AzureAccessPrivilegesRole) IsAdminAccountRole() {}

func (AzureAccessPrivilegesRole) IsEntityRole() {}

type AzureApplicationPrivilegesRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	AuthorizingRoleIds               []string       `json:"authorizingRoleIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AzureApplicationPrivilegesRole) IsAzurePrivilegedRole() {}
func (this AzureApplicationPrivilegesRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureApplicationPrivilegesRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureApplicationPrivilegesRole) GetAuthorizingRoleIds() []string {
	if this.AuthorizingRoleIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingRoleIds))
	for _, concrete := range this.AuthorizingRoleIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureApplicationPrivilegesRole) GetBuiltin() bool         { return this.Builtin }
func (this AzureApplicationPrivilegesRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureApplicationPrivilegesRole) GetFullPath() *string     { return this.FullPath }
func (this AzureApplicationPrivilegesRole) GetProbability() *float64 { return this.Probability }
func (this AzureApplicationPrivilegesRole) GetType() EntityRoleType  { return this.Type }

func (AzureApplicationPrivilegesRole) IsAdminAccountRole() {}

func (AzureApplicationPrivilegesRole) IsEntityRole() {}

// A specialized `AccountDescriptor` for SSO cloud service accounts.
type AzureCloudServiceAdapterDescriptor struct {
	// The ID of the tenant in which the application is registered.
	AppOwnerOrganizationID *string `json:"appOwnerOrganizationId,omitempty"`
	// The ID of the registered application.
	AppRegistrationObjectID *string `json:"appRegistrationObjectId,omitempty"`
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived                bool                     `json:"archived"`
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	ContainingRoleEntities  []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime            string                   `json:"creationTime"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource DataSource `json:"dataSource"`
	// The ID of the connector configuration associated with this account.
	DataSourceConfigurationIdentifier string `json:"dataSourceConfigurationIdentifier"`
	// A unique identifier the connector uses to identify this account.
	DataSourceParticipantIdentifier string  `json:"dataSourceParticipantIdentifier"`
	Description                     *string `json:"description,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled                          bool                     `json:"enabled"`
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities  []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	// The last time the service principal was accessed.
	LastAccessTime *string `json:"lastAccessTime,omitempty"`
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// The domain name of the application publisher.
	PublisherDomain          *string               `json:"publisherDomain,omitempty"`
	RegisteredTenantType     *RegisteredTenantType `json:"registeredTenantType,omitempty"`
	ServicePrincipalObjectID *string               `json:"servicePrincipalObjectId,omitempty"`
	// The type of access this application allows.
	SignInAudience *SignInAudience `json:"signInAudience,omitempty"`
	Tenant         *string         `json:"tenant,omitempty"`
}

func (AzureCloudServiceAdapterDescriptor) IsCloudServiceAdapterDescriptor() {}

// The ID of the tenant in which the application is registered.
func (this AzureCloudServiceAdapterDescriptor) GetAppOwnerOrganizationID() *string {
	return this.AppOwnerOrganizationID
}

// The ID of the registered application.
func (this AzureCloudServiceAdapterDescriptor) GetAppRegistrationObjectID() *string {
	return this.AppRegistrationObjectID
}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AzureCloudServiceAdapterDescriptor) GetArchived() bool { return this.Archived }
func (this AzureCloudServiceAdapterDescriptor) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCloudServiceAdapterDescriptor) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCloudServiceAdapterDescriptor) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCloudServiceAdapterDescriptor) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AzureCloudServiceAdapterDescriptor) GetDataSource() DataSource { return this.DataSource }

// The ID of the connector configuration associated with this account.
func (this AzureCloudServiceAdapterDescriptor) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}

// A unique identifier the connector uses to identify this account.
func (this AzureCloudServiceAdapterDescriptor) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this AzureCloudServiceAdapterDescriptor) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AzureCloudServiceAdapterDescriptor) GetEnabled() bool { return this.Enabled }
func (this AzureCloudServiceAdapterDescriptor) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCloudServiceAdapterDescriptor) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCloudServiceAdapterDescriptor) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The last time the service principal was accessed.
func (this AzureCloudServiceAdapterDescriptor) GetLastAccessTime() *string {
	return this.LastAccessTime
}

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this AzureCloudServiceAdapterDescriptor) GetMostRecentActivity() *string {
	return this.MostRecentActivity
}

// The domain name of the application publisher.
func (this AzureCloudServiceAdapterDescriptor) GetPublisherDomain() *string {
	return this.PublisherDomain
}
func (this AzureCloudServiceAdapterDescriptor) GetRegisteredTenantType() *RegisteredTenantType {
	return this.RegisteredTenantType
}
func (this AzureCloudServiceAdapterDescriptor) GetServicePrincipalObjectID() *string {
	return this.ServicePrincipalObjectID
}

// The type of access this application allows.
func (this AzureCloudServiceAdapterDescriptor) GetSignInAudience() *SignInAudience {
	return this.SignInAudience
}
func (this AzureCloudServiceAdapterDescriptor) GetTenant() *string { return this.Tenant }

func (AzureCloudServiceAdapterDescriptor) IsActivityParticipatingAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

func (AzureCloudServiceAdapterDescriptor) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

type AzureCredentialsPrivilegesRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	AuthorizingRoleIds               []string       `json:"authorizingRoleIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AzureCredentialsPrivilegesRole) IsAzurePrivilegedRole() {}
func (this AzureCredentialsPrivilegesRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCredentialsPrivilegesRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCredentialsPrivilegesRole) GetAuthorizingRoleIds() []string {
	if this.AuthorizingRoleIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingRoleIds))
	for _, concrete := range this.AuthorizingRoleIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureCredentialsPrivilegesRole) GetBuiltin() bool         { return this.Builtin }
func (this AzureCredentialsPrivilegesRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureCredentialsPrivilegesRole) GetFullPath() *string     { return this.FullPath }
func (this AzureCredentialsPrivilegesRole) GetProbability() *float64 { return this.Probability }
func (this AzureCredentialsPrivilegesRole) GetType() EntityRoleType  { return this.Type }

func (AzureCredentialsPrivilegesRole) IsAdminAccountRole() {}

func (AzureCredentialsPrivilegesRole) IsEntityRole() {}

type AzureDistributionGroupRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (AzureDistributionGroupRole) IsEntityRole()                 {}
func (this AzureDistributionGroupRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureDistributionGroupRole) GetFullPath() *string     { return this.FullPath }
func (this AzureDistributionGroupRole) GetProbability() *float64 { return this.Probability }
func (this AzureDistributionGroupRole) GetType() EntityRoleType  { return this.Type }

type AzureGlobalPrivilegesRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	AuthorizingRoleIds               []string       `json:"authorizingRoleIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AzureGlobalPrivilegesRole) IsAzurePrivilegedRole() {}
func (this AzureGlobalPrivilegesRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureGlobalPrivilegesRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureGlobalPrivilegesRole) GetAuthorizingRoleIds() []string {
	if this.AuthorizingRoleIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingRoleIds))
	for _, concrete := range this.AuthorizingRoleIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureGlobalPrivilegesRole) GetBuiltin() bool         { return this.Builtin }
func (this AzureGlobalPrivilegesRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureGlobalPrivilegesRole) GetFullPath() *string     { return this.FullPath }
func (this AzureGlobalPrivilegesRole) GetProbability() *float64 { return this.Probability }
func (this AzureGlobalPrivilegesRole) GetType() EntityRoleType  { return this.Type }

func (AzureGlobalPrivilegesRole) IsAdminAccountRole() {}

func (AzureGlobalPrivilegesRole) IsEntityRole() {}

type AzureLegacyProtocolUsageRiskFactor struct {
	ClientDataSourceIdentifiers []string       `json:"clientDataSourceIdentifiers"`
	Score                       string         `json:"score"`
	Severity                    ScoreSeverity  `json:"severity"`
	Type                        RiskFactorType `json:"type"`
}

func (AzureLegacyProtocolUsageRiskFactor) IsEntityRiskFactor()             {}
func (this AzureLegacyProtocolUsageRiskFactor) GetScore() string           { return this.Score }
func (this AzureLegacyProtocolUsageRiskFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this AzureLegacyProtocolUsageRiskFactor) GetType() RiskFactorType    { return this.Type }

type AzureMicrosoft365GroupRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (AzureMicrosoft365GroupRole) IsEntityRole()                 {}
func (this AzureMicrosoft365GroupRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureMicrosoft365GroupRole) GetFullPath() *string     { return this.FullPath }
func (this AzureMicrosoft365GroupRole) GetProbability() *float64 { return this.Probability }
func (this AzureMicrosoft365GroupRole) GetType() EntityRoleType  { return this.Type }

type AzurePrivilegedApplicationControllerRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AzurePrivilegedApplicationControllerRole) IsEffectiveAdminRole() {}
func (this AzurePrivilegedApplicationControllerRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzurePrivilegedApplicationControllerRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzurePrivilegedApplicationControllerRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzurePrivilegedApplicationControllerRole) GetBuiltin() bool   { return this.Builtin }
func (this AzurePrivilegedApplicationControllerRole) GetConfirmed() bool { return this.Confirmed }
func (this AzurePrivilegedApplicationControllerRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzurePrivilegedApplicationControllerRole) GetFullPath() *string { return this.FullPath }
func (this AzurePrivilegedApplicationControllerRole) GetProbability() *float64 {
	return this.Probability
}
func (this AzurePrivilegedApplicationControllerRole) GetType() EntityRoleType { return this.Type }

func (AzurePrivilegedApplicationControllerRole) IsAdminAccountRole() {}

func (AzurePrivilegedApplicationControllerRole) IsEntityRole() {}

type AzureSecurityGroupRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (AzureSecurityGroupRole) IsEntityRole()                 {}
func (this AzureSecurityGroupRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureSecurityGroupRole) GetFullPath() *string     { return this.FullPath }
func (this AzureSecurityGroupRole) GetProbability() *float64 { return this.Probability }
func (this AzureSecurityGroupRole) GetType() EntityRoleType  { return this.Type }

type AzureSecurityPrivilegesRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	AuthorizingRoleIds               []string       `json:"authorizingRoleIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (AzureSecurityPrivilegesRole) IsAzurePrivilegedRole() {}
func (this AzureSecurityPrivilegesRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSecurityPrivilegesRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSecurityPrivilegesRole) GetAuthorizingRoleIds() []string {
	if this.AuthorizingRoleIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingRoleIds))
	for _, concrete := range this.AuthorizingRoleIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSecurityPrivilegesRole) GetBuiltin() bool         { return this.Builtin }
func (this AzureSecurityPrivilegesRole) GetConfirmed() bool       { return this.Confirmed }
func (this AzureSecurityPrivilegesRole) GetFullPath() *string     { return this.FullPath }
func (this AzureSecurityPrivilegesRole) GetProbability() *float64 { return this.Probability }
func (this AzureSecurityPrivilegesRole) GetType() EntityRoleType  { return this.Type }

func (AzureSecurityPrivilegesRole) IsAdminAccountRole() {}

func (AzureSecurityPrivilegesRole) IsEntityRole() {}

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type AzureSsoGroupAccountDescriptor struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived                bool                     `json:"archived"`
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	ContainingRoleEntities  []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime            string                   `json:"creationTime"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource                        DataSource `json:"dataSource"`
	DataSourceConfigurationIdentifier string     `json:"dataSourceConfigurationIdentifier"`
	DataSourceParticipantIdentifier   string     `json:"dataSourceParticipantIdentifier"`
	Description                       *string    `json:"description,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled                          bool                     `json:"enabled"`
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities  []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	Tenant                           *string                  `json:"tenant,omitempty"`
}

func (AzureSsoGroupAccountDescriptor) IsSsoGroupAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AzureSsoGroupAccountDescriptor) GetArchived() bool { return this.Archived }
func (this AzureSsoGroupAccountDescriptor) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoGroupAccountDescriptor) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoGroupAccountDescriptor) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoGroupAccountDescriptor) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AzureSsoGroupAccountDescriptor) GetDataSource() DataSource { return this.DataSource }
func (this AzureSsoGroupAccountDescriptor) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this AzureSsoGroupAccountDescriptor) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this AzureSsoGroupAccountDescriptor) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AzureSsoGroupAccountDescriptor) GetEnabled() bool { return this.Enabled }
func (this AzureSsoGroupAccountDescriptor) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoGroupAccountDescriptor) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoGroupAccountDescriptor) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoGroupAccountDescriptor) GetTenant() *string { return this.Tenant }

func (AzureSsoGroupAccountDescriptor) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// An account descriptor provides data associated with an external entity source,
// such as an entry in an identity management system.
type AzureSsoRoleAccountDescriptor struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived     bool   `json:"archived"`
	CreationTime string `json:"creationTime"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource                        DataSource `json:"dataSource"`
	DataSourceConfigurationIdentifier string     `json:"dataSourceConfigurationIdentifier"`
	DataSourceParticipantIdentifier   string     `json:"dataSourceParticipantIdentifier"`
	Description                       *string    `json:"description,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled bool    `json:"enabled"`
	Tenant  *string `json:"tenant,omitempty"`
}

func (AzureSsoRoleAccountDescriptor) IsSsoRoleAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AzureSsoRoleAccountDescriptor) GetArchived() bool       { return this.Archived }
func (this AzureSsoRoleAccountDescriptor) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AzureSsoRoleAccountDescriptor) GetDataSource() DataSource { return this.DataSource }
func (this AzureSsoRoleAccountDescriptor) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this AzureSsoRoleAccountDescriptor) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this AzureSsoRoleAccountDescriptor) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AzureSsoRoleAccountDescriptor) GetEnabled() bool   { return this.Enabled }
func (this AzureSsoRoleAccountDescriptor) GetTenant() *string { return this.Tenant }

func (AzureSsoRoleAccountDescriptor) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// A specialized `AccountDescriptor` for SSO user accounts.
type AzureSsoUserAccountDescriptor struct {
	// If `true`, the account no longer exists; if `false`, the account is currently enabled.
	Archived                bool                     `json:"archived"`
	ContainingEntities      []*EntityContainerEntity `json:"containingEntities"`
	ContainingGroupEntities []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds      []string                 `json:"containingGroupIds"`
	ContainingRoleEntities  []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime            string                   `json:"creationTime"`
	CredentialsDataSource   *DataSource              `json:"credentialsDataSource,omitempty"`
	// The data source of this account. Together with the entity type, the data
	// source determines the account descriptor subtype to be used.
	DataSource DataSource `json:"dataSource"`
	// The ID of the connector configuration associated with this account.
	DataSourceConfigurationIdentifier string  `json:"dataSourceConfigurationIdentifier"`
	DataSourceLoginIdentifier         *string `json:"dataSourceLoginIdentifier,omitempty"`
	// A unique identifier used by the connector to identify this account.
	DataSourceParticipantIdentifier string  `json:"dataSourceParticipantIdentifier"`
	Department                      *string `json:"department,omitempty"`
	Description                     *string `json:"description,omitempty"`
	// If `true`, the account is currently enabled; if `false`, the account no longer exists.
	Enabled                          bool                     `json:"enabled"`
	FlattenedContainingGroupEntities []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds      []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities  []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	// The date and time of the account's latest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// Information regarding the account's password.
	PasswordAttributes PasswordAttributes `json:"passwordAttributes,omitempty"`
	Tenant             *string            `json:"tenant,omitempty"`
	Title              *string            `json:"title,omitempty"`
}

func (AzureSsoUserAccountDescriptor) IsSsoUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this AzureSsoUserAccountDescriptor) GetArchived() bool { return this.Archived }
func (this AzureSsoUserAccountDescriptor) GetContainingEntities() []*EntityContainerEntity {
	if this.ContainingEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingEntities))
	for _, concrete := range this.ContainingEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoUserAccountDescriptor) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoUserAccountDescriptor) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoUserAccountDescriptor) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoUserAccountDescriptor) GetCreationTime() string { return this.CreationTime }
func (this AzureSsoUserAccountDescriptor) GetCredentialsDataSource() *DataSource {
	return this.CredentialsDataSource
}

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this AzureSsoUserAccountDescriptor) GetDataSource() DataSource { return this.DataSource }

// The ID of the connector configuration associated with this account.
func (this AzureSsoUserAccountDescriptor) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this AzureSsoUserAccountDescriptor) GetDataSourceLoginIdentifier() *string {
	return this.DataSourceLoginIdentifier
}

// A unique identifier used by the connector to identify this account.
func (this AzureSsoUserAccountDescriptor) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this AzureSsoUserAccountDescriptor) GetDepartment() *string  { return this.Department }
func (this AzureSsoUserAccountDescriptor) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this AzureSsoUserAccountDescriptor) GetEnabled() bool { return this.Enabled }
func (this AzureSsoUserAccountDescriptor) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoUserAccountDescriptor) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this AzureSsoUserAccountDescriptor) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this AzureSsoUserAccountDescriptor) GetMostRecentActivity() *string {
	return this.MostRecentActivity
}

// Information regarding the account's password.
func (this AzureSsoUserAccountDescriptor) GetPasswordAttributes() PasswordAttributes {
	return this.PasswordAttributes
}
func (this AzureSsoUserAccountDescriptor) GetTenant() *string { return this.Tenant }
func (this AzureSsoUserAccountDescriptor) GetTitle() *string  { return this.Title }

func (AzureSsoUserAccountDescriptor) IsActivityParticipatingAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

func (AzureSsoUserAccountDescriptor) IsUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (AzureSsoUserAccountDescriptor) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

type BackupOperatorsAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (BackupOperatorsAdminRole) IsOperatorLevelAdminRole() {}
func (this BackupOperatorsAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BackupOperatorsAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BackupOperatorsAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this BackupOperatorsAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this BackupOperatorsAdminRole) GetFullPath() *string     { return this.FullPath }
func (this BackupOperatorsAdminRole) GetProbability() *float64 { return this.Probability }
func (this BackupOperatorsAdminRole) GetType() EntityRoleType  { return this.Type }

func (BackupOperatorsAdminRole) IsAdminAccountRole() {}

func (BackupOperatorsAdminRole) IsEntityRole() {}

type BrowserInfo struct {
	Name    string  `json:"name"`
	Version *string `json:"version,omitempty"`
}

type BuiltinAdministratorRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (BuiltinAdministratorRole) IsDomainLevelAdminRole() {}
func (this BuiltinAdministratorRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BuiltinAdministratorRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BuiltinAdministratorRole) GetBuiltin() bool         { return this.Builtin }
func (this BuiltinAdministratorRole) GetConfirmed() bool       { return this.Confirmed }
func (this BuiltinAdministratorRole) GetFullPath() *string     { return this.FullPath }
func (this BuiltinAdministratorRole) GetProbability() *float64 { return this.Probability }
func (this BuiltinAdministratorRole) GetType() EntityRoleType  { return this.Type }

func (BuiltinAdministratorRole) IsAdminAccountRole() {}

func (BuiltinAdministratorRole) IsEntityRole() {}

// A descriptor object for an error applying an action to one or more `Entity` objects.
type BulkEntityActionFailure struct {
	// The entity-ids for which the action wasn't applied successfully.
	EntityIds []string `json:"entityIds"`
	// The failure reason.
	ErrorDetails ErrorDetails `json:"errorDetails"`
}

// Input object for mutations applying an action to multiple entities at once.
type BulkEntityActionInput struct {
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// Query criteria to match the subject entities by.
	//
	// Usually the query should match entities by selective attributes such as
	// entity-id (see ```EntityQueryInput:entityIds```) or sam-account-name (see
	// ```EntityQueryInput:samAccountNames```). Only 1000 entities may be updated at
	// once - the entire operation is aborted with an error if the query criteria
	// exceeds this limit.
	EntityQuery *EntityQueryInput `json:"entityQuery"`
}

// Result object for mutation APIs applying an action to multiple entities at once.
type BulkEntityActionResult struct {
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// List of failures applying the action, grouped by the failure reason.
	Failures []*BulkEntityActionFailure `json:"failures"`
	// List of successfully updated entities.
	//
	// **Note:** Entity actions are idempotent - even if the said action is
	// effectively a no-op for some entity, it would still be considered
	// *successfully updated*.
	UpdatedEntities []Entity `json:"updatedEntities"`
}

type BusinessPrivilege struct {
	AuthorizingGroupIds []string                `json:"authorizingGroupIds"`
	BusinessPrivilegeID string                  `json:"businessPrivilegeId"`
	Impact              BusinessPrivilegeImpact `json:"impact"`
}

type BusinessPrivilegeRole struct {
	AuthorizingContainingEntitiesIds []string             `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string             `json:"authorizingGroupIds"`
	Builtin                          bool                 `json:"builtin"`
	BusinessPrivileges               []*BusinessPrivilege `json:"businessPrivileges"`
	Confirmed                        bool                 `json:"confirmed"`
	FullPath                         *string              `json:"fullPath,omitempty"`
	Probability                      *float64             `json:"probability,omitempty"`
	Type                             EntityRoleType       `json:"type"`
}

func (BusinessPrivilegeRole) IsAdminAccountRole() {}
func (this BusinessPrivilegeRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BusinessPrivilegeRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BusinessPrivilegeRole) GetBuiltin() bool         { return this.Builtin }
func (this BusinessPrivilegeRole) GetConfirmed() bool       { return this.Confirmed }
func (this BusinessPrivilegeRole) GetFullPath() *string     { return this.FullPath }
func (this BusinessPrivilegeRole) GetProbability() *float64 { return this.Probability }
func (this BusinessPrivilegeRole) GetType() EntityRoleType  { return this.Type }

func (BusinessPrivilegeRole) IsEntityRole() {}

type CertificateAuthenticationAsAnyDomainUserRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	CertificateAuthorityEndpoints    []string       `json:"certificateAuthorityEndpoints"`
	CertificateTemplateNames         []string       `json:"certificateTemplateNames"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (CertificateAuthenticationAsAnyDomainUserRole) IsEffectiveAdminRole() {}
func (this CertificateAuthenticationAsAnyDomainUserRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CertificateAuthenticationAsAnyDomainUserRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CertificateAuthenticationAsAnyDomainUserRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CertificateAuthenticationAsAnyDomainUserRole) GetBuiltin() bool   { return this.Builtin }
func (this CertificateAuthenticationAsAnyDomainUserRole) GetConfirmed() bool { return this.Confirmed }
func (this CertificateAuthenticationAsAnyDomainUserRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CertificateAuthenticationAsAnyDomainUserRole) GetFullPath() *string { return this.FullPath }
func (this CertificateAuthenticationAsAnyDomainUserRole) GetProbability() *float64 {
	return this.Probability
}
func (this CertificateAuthenticationAsAnyDomainUserRole) GetType() EntityRoleType { return this.Type }

func (CertificateAuthenticationAsAnyDomainUserRole) IsAdminAccountRole() {}

func (CertificateAuthenticationAsAnyDomainUserRole) IsEntityRole() {}

type CertificateAuthority struct {
	ID                            string                 `json:"_id"`
	DNSHostName                   string                 `json:"dnsHostName"`
	Name                          string                 `json:"name"`
	PublishedCertificateTemplates []*CertificateTemplate `json:"publishedCertificateTemplates,omitempty"`
}

type CertificateAuthorityAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (CertificateAuthorityAdminRole) IsAdminAccountRole() {}
func (this CertificateAuthorityAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CertificateAuthorityAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CertificateAuthorityAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this CertificateAuthorityAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this CertificateAuthorityAdminRole) GetFullPath() *string     { return this.FullPath }
func (this CertificateAuthorityAdminRole) GetProbability() *float64 { return this.Probability }
func (this CertificateAuthorityAdminRole) GetType() EntityRoleType  { return this.Type }

func (CertificateAuthorityAdminRole) IsEntityRole() {}

type CertificateAuthorityServerRole struct {
	CertificateAuthority *CertificateAuthority `json:"certificateAuthority"`
	Confirmed            bool                  `json:"confirmed"`
	FullPath             *string               `json:"fullPath,omitempty"`
	Impersonator         bool                  `json:"impersonator"`
	Probability          *float64              `json:"probability,omitempty"`
	Type                 EntityRoleType        `json:"type"`
}

func (CertificateAuthorityServerRole) IsServerRole()                 {}
func (this CertificateAuthorityServerRole) GetConfirmed() bool       { return this.Confirmed }
func (this CertificateAuthorityServerRole) GetFullPath() *string     { return this.FullPath }
func (this CertificateAuthorityServerRole) GetImpersonator() bool    { return this.Impersonator }
func (this CertificateAuthorityServerRole) GetProbability() *float64 { return this.Probability }
func (this CertificateAuthorityServerRole) GetType() EntityRoleType  { return this.Type }

func (CertificateAuthorityServerRole) IsClassificationRole() {}

func (CertificateAuthorityServerRole) IsEntityRole() {}

type CertificateTemplate struct {
	ID                       string   `json:"_id"`
	Name                     string   `json:"name"`
	PkiExtendedKeyUsageNames []string `json:"pkiExtendedKeyUsageNames"`
}

type CertificateTemplateAuthenticationBasedRiskFactor struct {
	CertificateTemplateNames  []string                   `json:"certificateTemplateNames"`
	InvolvedEntitiesQueryInfo *InvolvedEntitiesQueryInfo `json:"involvedEntitiesQueryInfo"`
	Score                     string                     `json:"score"`
	Severity                  ScoreSeverity              `json:"severity"`
	Type                      RiskFactorType             `json:"type"`
}

func (CertificateTemplateAuthenticationBasedRiskFactor) IsEntityRiskFactor()   {}
func (this CertificateTemplateAuthenticationBasedRiskFactor) GetScore() string { return this.Score }
func (this CertificateTemplateAuthenticationBasedRiskFactor) GetSeverity() ScoreSeverity {
	return this.Severity
}
func (this CertificateTemplateAuthenticationBasedRiskFactor) GetType() RiskFactorType {
	return this.Type
}

type ClassificationRoleImpl struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (ClassificationRoleImpl) IsClassificationRole()         {}
func (this ClassificationRoleImpl) GetConfirmed() bool       { return this.Confirmed }
func (this ClassificationRoleImpl) GetFullPath() *string     { return this.FullPath }
func (this ClassificationRoleImpl) GetProbability() *float64 { return this.Probability }
func (this ClassificationRoleImpl) GetType() EntityRoleType  { return this.Type }

func (ClassificationRoleImpl) IsEntityRole() {}

type ClassifyEndpointEntityInput struct {
	Classifications  []EndpointEntityClassification `json:"classifications"`
	ClientMutationID *string                        `json:"clientMutationId,omitempty"`
	EntityQuery      *EntityQueryInput              `json:"entityQuery"`
}

type ClassifyUserEntityInput struct {
	Classifications  []UserEntityClassification `json:"classifications"`
	ClientMutationID *string                    `json:"clientMutationId,omitempty"`
	EntityQuery      *EntityQueryInput          `json:"entityQuery"`
}

type CloudActivityOnVulnerableOsRiskFactor struct {
	Score                          string                 `json:"score"`
	Severity                       ScoreSeverity          `json:"severity"`
	Type                           RiskFactorType         `json:"type"`
	UsedVulnerableOperatingSystems []*OperatingSystemInfo `json:"usedVulnerableOperatingSystems"`
}

func (CloudActivityOnVulnerableOsRiskFactor) IsEntityRiskFactor()             {}
func (this CloudActivityOnVulnerableOsRiskFactor) GetScore() string           { return this.Score }
func (this CloudActivityOnVulnerableOsRiskFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this CloudActivityOnVulnerableOsRiskFactor) GetType() RiskFactorType    { return this.Type }

type CloudServiceAdapterDescriptorImpl struct {
	AppOwnerOrganizationID            *string                  `json:"appOwnerOrganizationId,omitempty"`
	AppRegistrationObjectID           *string                  `json:"appRegistrationObjectId,omitempty"`
	Archived                          bool                     `json:"archived"`
	ContainingGroupEntities           []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds                []string                 `json:"containingGroupIds"`
	ContainingRoleEntities            []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime                      string                   `json:"creationTime"`
	DataSource                        DataSource               `json:"dataSource"`
	DataSourceConfigurationIdentifier string                   `json:"dataSourceConfigurationIdentifier"`
	DataSourceParticipantIdentifier   string                   `json:"dataSourceParticipantIdentifier"`
	Description                       *string                  `json:"description,omitempty"`
	Enabled                           bool                     `json:"enabled"`
	FlattenedContainingGroupEntities  []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds       []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities   []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	LastAccessTime                    *string                  `json:"lastAccessTime,omitempty"`
	MostRecentActivity                *string                  `json:"mostRecentActivity,omitempty"`
	PublisherDomain                   *string                  `json:"publisherDomain,omitempty"`
	RegisteredTenantType              *RegisteredTenantType    `json:"registeredTenantType,omitempty"`
	ServicePrincipalObjectID          *string                  `json:"servicePrincipalObjectId,omitempty"`
	SignInAudience                    *SignInAudience          `json:"signInAudience,omitempty"`
	Tenant                            *string                  `json:"tenant,omitempty"`
}

func (CloudServiceAdapterDescriptorImpl) IsCloudServiceAdapterDescriptor() {}

// The ID of the tenant in which the application is registered.
func (this CloudServiceAdapterDescriptorImpl) GetAppOwnerOrganizationID() *string {
	return this.AppOwnerOrganizationID
}

// The ID of the registered application.
func (this CloudServiceAdapterDescriptorImpl) GetAppRegistrationObjectID() *string {
	return this.AppRegistrationObjectID
}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this CloudServiceAdapterDescriptorImpl) GetArchived() bool { return this.Archived }
func (this CloudServiceAdapterDescriptorImpl) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CloudServiceAdapterDescriptorImpl) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CloudServiceAdapterDescriptorImpl) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CloudServiceAdapterDescriptorImpl) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this CloudServiceAdapterDescriptorImpl) GetDataSource() DataSource { return this.DataSource }

// The ID of the connector configuration associated with this account.
func (this CloudServiceAdapterDescriptorImpl) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}

// A unique identifier the connector uses to identify this account.
func (this CloudServiceAdapterDescriptorImpl) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this CloudServiceAdapterDescriptorImpl) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this CloudServiceAdapterDescriptorImpl) GetEnabled() bool { return this.Enabled }
func (this CloudServiceAdapterDescriptorImpl) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CloudServiceAdapterDescriptorImpl) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CloudServiceAdapterDescriptorImpl) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The last time the service principal was accessed.
func (this CloudServiceAdapterDescriptorImpl) GetLastAccessTime() *string { return this.LastAccessTime }

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this CloudServiceAdapterDescriptorImpl) GetMostRecentActivity() *string {
	return this.MostRecentActivity
}

// The domain name of the application publisher.
func (this CloudServiceAdapterDescriptorImpl) GetPublisherDomain() *string {
	return this.PublisherDomain
}
func (this CloudServiceAdapterDescriptorImpl) GetRegisteredTenantType() *RegisteredTenantType {
	return this.RegisteredTenantType
}
func (this CloudServiceAdapterDescriptorImpl) GetServicePrincipalObjectID() *string {
	return this.ServicePrincipalObjectID
}

// The type of access this application allows.
func (this CloudServiceAdapterDescriptorImpl) GetSignInAudience() *SignInAudience {
	return this.SignInAudience
}
func (this CloudServiceAdapterDescriptorImpl) GetTenant() *string { return this.Tenant }

func (CloudServiceAdapterDescriptorImpl) IsActivityParticipatingAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

func (CloudServiceAdapterDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// A specialized `Association` type for entity associations
type CloudServiceAssociation struct {
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType BindingType `json:"bindingType"`
	// The associated entity.
	Entity Entity `json:"entity"`
}

func (CloudServiceAssociation) IsEntityAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this CloudServiceAssociation) GetBindingType() BindingType { return this.BindingType }

// The associated entity.
func (this CloudServiceAssociation) GetEntity() Entity { return this.Entity }

func (CloudServiceAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

// An abstract `Entity` interface common to all entities that participate in the
// network activity, as opposed to entities defined by their place in the
// organization structure.
type CloudServiceEntity struct {
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	Accounts []AccountDescriptor `json:"accounts"`
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	Archived bool `json:"archived"`
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	Associations []Association `json:"associations"`
	CreationTime string        `json:"creationTime"`
	// The date and time of the entity's earliest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	EarliestSeenTraffic *string `json:"earliestSeenTraffic,omitempty"`
	// The entity's unique identifier.
	EntityID             string `json:"entityId"`
	HasADDomainAdminRole *bool  `json:"hasADDomainAdminRole,omitempty"`
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	HasRole *bool `json:"hasRole,omitempty"`
	// If `true`, the entity is inactive. An entity is considered inactive after 21
	// days since its latest recorded network activity (see `mostRecentActivity`).
	Inactive bool `json:"inactive"`
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	Learned bool `json:"learned"`
	// For marked entities, this is set to the last time the entity was marked.
	MarkTime *string `json:"markTime,omitempty"`
	// The date and time of the entity's latest recorded network activity. This takes
	// into account both the data reported by external sources and the actual traffic
	// seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// Query open incidents for this entity.
	OpenIncidents *IncidentConnection `json:"openIncidents,omitempty"`
	// The primary display name used to represent this entity in user-facing data.
	//
	// The primary display name is typically shorter than the secondary display name,
	// but is much less likely to be unique across the organization or network. For
	// further details on the semantics, see the documentation for specific types.
	PrimaryDisplayName string `json:"primaryDisplayName"`
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	RiskFactors []EntityRiskFactor `json:"riskFactors"`
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	RiskScore string `json:"riskScore"`
	// The entity's risk score derived from `riskScore`.
	RiskScoreSeverity ScoreSeverity `json:"riskScoreSeverity"`
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	Roles []EntityRole `json:"roles,omitempty"`
	// The secondary display name is used to represent unique name for this entity in the organization or the network.
	SecondaryDisplayName string `json:"secondaryDisplayName"`
	// If `true`, the entity is stale. An entity is considered stale after 90 days of
	// inactivity (see `mostRecentActivity`), as long as it is still effectively part
	// of the network. An account-based entity is not considered part of the network
	// when all of its base accounts are disabled (see `primaryAccount` and
	// `secondaryAccounts`).
	Stale bool `json:"stale"`
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	Type EntityType `json:"type"`
	// If `true`, this entity appears on the system watchlist.
	Watched bool `json:"watched"`
}

func (CloudServiceEntity) IsActivityParticipatingEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
func (this CloudServiceEntity) GetAccounts() []AccountDescriptor {
	if this.Accounts == nil {
		return nil
	}
	interfaceSlice := make([]AccountDescriptor, 0, len(this.Accounts))
	for _, concrete := range this.Accounts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.
func (this CloudServiceEntity) GetArchived() bool { return this.Archived }

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.
func (this CloudServiceEntity) GetAssociations() []Association {
	if this.Associations == nil {
		return nil
	}
	interfaceSlice := make([]Association, 0, len(this.Associations))
	for _, concrete := range this.Associations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CloudServiceEntity) GetCreationTime() string { return this.CreationTime }

// The date and time of the entity's earliest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this CloudServiceEntity) GetEarliestSeenTraffic() *string { return this.EarliestSeenTraffic }

// The entity's unique identifier.
func (this CloudServiceEntity) GetEntityID() string            { return this.EntityID }
func (this CloudServiceEntity) GetHasADDomainAdminRole() *bool { return this.HasADDomainAdminRole }

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
//
//	{
//	  entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//	  {
//	    nodes
//	    {
//	      type
//	      primaryDisplayName
//	      ... on UserEntity
//	      {
//	        isHuman: hasRole(type: HumanUserAccountRole)
//	        isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//	        isAdmin: hasRole(type: AdminAccountRole)
//	      }
//	      ... on EndpointEntity
//	      {
//	        isWorkstation: hasRole(type: WorkstationRole)
//	        isServer: hasRole(type: WorkstationRole)
//	      }
//	      isManuallyClassified: hasRole(confirmed: true)
//	    }
//	  }
//	}
//
// ```
func (this CloudServiceEntity) GetHasRole() *bool { return this.HasRole }

// If `true`, the entity is inactive. An entity is considered inactive after 21
// days since its latest recorded network activity (see `mostRecentActivity`).
func (this CloudServiceEntity) GetInactive() bool { return this.Inactive }

// If `true`, the system has gathered enough information to consider this entity *learned*.
func (this CloudServiceEntity) GetLearned() bool { return this.Learned }

// For marked entities, this is set to the last time the entity was marked.
func (this CloudServiceEntity) GetMarkTime() *string { return this.MarkTime }

// The date and time of the entity's latest recorded network activity. This takes
// into account both the data reported by external sources and the actual traffic
// seen by the system.
func (this CloudServiceEntity) GetMostRecentActivity() *string { return this.MostRecentActivity }

// Query open incidents for this entity.
func (this CloudServiceEntity) GetOpenIncidents() *IncidentConnection { return this.OpenIncidents }

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.
func (this CloudServiceEntity) GetPrimaryDisplayName() string { return this.PrimaryDisplayName }

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.
func (this CloudServiceEntity) GetRiskFactors() []EntityRiskFactor {
	if this.RiskFactors == nil {
		return nil
	}
	interfaceSlice := make([]EntityRiskFactor, 0, len(this.RiskFactors))
	for _, concrete := range this.RiskFactors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
func (this CloudServiceEntity) GetRiskScore() string { return this.RiskScore }

// The entity's risk score derived from `riskScore`.
func (this CloudServiceEntity) GetRiskScoreSeverity() ScoreSeverity { return this.RiskScoreSeverity }

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.
func (this CloudServiceEntity) GetRoles() []EntityRole {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]EntityRole, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The secondary display name is used to represent unique name for this entity in the organization or the network.
func (this CloudServiceEntity) GetSecondaryDisplayName() string { return this.SecondaryDisplayName }

// If `true`, the entity is stale. An entity is considered stale after 90 days of
// inactivity (see `mostRecentActivity`), as long as it is still effectively part
// of the network. An account-based entity is not considered part of the network
// when all of its base accounts are disabled (see `primaryAccount` and
// `secondaryAccounts`).
func (this CloudServiceEntity) GetStale() bool { return this.Stale }

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
func (this CloudServiceEntity) GetType() EntityType { return this.Type }

// If `true`, this entity appears on the system watchlist.
func (this CloudServiceEntity) GetWatched() bool { return this.Watched }

func (CloudServiceEntity) IsEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.

// The entity's unique identifier.

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
// {
//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//   {
//     nodes
//     {
//       type
//       primaryDisplayName
//       ... on UserEntity
//       {
//         isHuman: hasRole(type: HumanUserAccountRole)
//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//         isAdmin: hasRole(type: AdminAccountRole)
//       }
//       ... on EndpointEntity
//       {
//         isWorkstation: hasRole(type: WorkstationRole)
//         isServer: hasRole(type: WorkstationRole)
//       }
//       isManuallyClassified: hasRole(confirmed: true)
//     }
//   }
// }
// ```

// If `true`, the system has gathered enough information to consider this entity *learned*.

// For marked entities, this is set to the last time the entity was marked.

// Query open incidents for this entity.

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).

// The entity's risk score derived from `riskScore`.

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.

// The secondary display name is used to represent unique name for this entity in the organization or the network.

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).

// If `true`, this entity appears on the system watchlist.

type CommonEngagementSummary struct {
	EngagementType EngagementType `json:"engagementType"`
}

func (CommonEngagementSummary) IsEngagementSummary()                   {}
func (this CommonEngagementSummary) GetEngagementType() EngagementType { return this.EngagementType }

type ConstrainedServiceDelegationAdminRole struct {
	AffectedEntities                 []Entity             `json:"affectedEntities"`
	AllowedServices                  []*ServiceDescriptor `json:"allowedServices"`
	AuthorizingContainingEntitiesIds []string             `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string             `json:"authorizingGroupIds"`
	Builtin                          bool                 `json:"builtin"`
	Confirmed                        bool                 `json:"confirmed"`
	EffectedEntityIds                []string             `json:"effectedEntityIds,omitempty"`
	FullPath                         *string              `json:"fullPath,omitempty"`
	Probability                      *float64             `json:"probability,omitempty"`
	Type                             EntityRoleType       `json:"type"`
}

func (ConstrainedServiceDelegationAdminRole) IsServiceDelegationAdminRole() {}
func (this ConstrainedServiceDelegationAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ConstrainedServiceDelegationAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ConstrainedServiceDelegationAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ConstrainedServiceDelegationAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this ConstrainedServiceDelegationAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this ConstrainedServiceDelegationAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ConstrainedServiceDelegationAdminRole) GetFullPath() *string     { return this.FullPath }
func (this ConstrainedServiceDelegationAdminRole) GetProbability() *float64 { return this.Probability }
func (this ConstrainedServiceDelegationAdminRole) GetType() EntityRoleType  { return this.Type }

func (ConstrainedServiceDelegationAdminRole) IsEffectiveAdminRole() {}

func (ConstrainedServiceDelegationAdminRole) IsAdminAccountRole() {}

func (ConstrainedServiceDelegationAdminRole) IsEntityRole() {}

type DefaultPasswordAttributesImpl struct {
	Aged       bool             `json:"aged"`
	Exposed    bool             `json:"exposed"`
	LastChange *string          `json:"lastChange,omitempty"`
	MayExpire  bool             `json:"mayExpire"`
	Strength   PasswordStrength `json:"strength"`
}

func (DefaultPasswordAttributesImpl) IsPasswordAttributes()              {}
func (this DefaultPasswordAttributesImpl) GetAged() bool                 { return this.Aged }
func (this DefaultPasswordAttributesImpl) GetExposed() bool              { return this.Exposed }
func (this DefaultPasswordAttributesImpl) GetLastChange() *string        { return this.LastChange }
func (this DefaultPasswordAttributesImpl) GetMayExpire() bool            { return this.MayExpire }
func (this DefaultPasswordAttributesImpl) GetStrength() PasswordStrength { return this.Strength }

type DistributionGroupRole struct {
	Builtin        bool                      `json:"builtin"`
	Confirmed      bool                      `json:"confirmed"`
	EmailAddresses []string                  `json:"emailAddresses"`
	FullPath       *string                   `json:"fullPath,omitempty"`
	Probability    *float64                  `json:"probability,omitempty"`
	Scope          ActiveDirectoryGroupScope `json:"scope"`
	Type           EntityRoleType            `json:"type"`
}

func (DistributionGroupRole) IsActiveDirectoryGroupRole()              {}
func (this DistributionGroupRole) GetBuiltin() bool                    { return this.Builtin }
func (this DistributionGroupRole) GetScope() ActiveDirectoryGroupScope { return this.Scope }

func (DistributionGroupRole) IsMailingListRole() {}

func (this DistributionGroupRole) GetConfirmed() bool { return this.Confirmed }
func (this DistributionGroupRole) GetEmailAddresses() []string {
	if this.EmailAddresses == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EmailAddresses))
	for _, concrete := range this.EmailAddresses {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DistributionGroupRole) GetFullPath() *string     { return this.FullPath }
func (this DistributionGroupRole) GetProbability() *float64 { return this.Probability }
func (this DistributionGroupRole) GetType() EntityRoleType  { return this.Type }

func (DistributionGroupRole) IsContainerRole() {}

func (DistributionGroupRole) IsEntityRole() {}

type DNSServerRole struct {
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Impersonator bool           `json:"impersonator"`
	Probability  *float64       `json:"probability,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (DNSServerRole) IsServerRole()                 {}
func (this DNSServerRole) GetConfirmed() bool       { return this.Confirmed }
func (this DNSServerRole) GetFullPath() *string     { return this.FullPath }
func (this DNSServerRole) GetImpersonator() bool    { return this.Impersonator }
func (this DNSServerRole) GetProbability() *float64 { return this.Probability }
func (this DNSServerRole) GetType() EntityRoleType  { return this.Type }

func (DNSServerRole) IsClassificationRole() {}

func (DNSServerRole) IsEntityRole() {}

type DomainAdminsRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (DomainAdminsRole) IsDomainLevelAdminRole() {}
func (this DomainAdminsRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DomainAdminsRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DomainAdminsRole) GetBuiltin() bool         { return this.Builtin }
func (this DomainAdminsRole) GetConfirmed() bool       { return this.Confirmed }
func (this DomainAdminsRole) GetFullPath() *string     { return this.FullPath }
func (this DomainAdminsRole) GetProbability() *float64 { return this.Probability }
func (this DomainAdminsRole) GetType() EntityRoleType  { return this.Type }

func (DomainAdminsRole) IsAdminAccountRole() {}

func (DomainAdminsRole) IsEntityRole() {}

type DomainControllerRole struct {
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Impersonator bool           `json:"impersonator"`
	Pdc          *bool          `json:"pdc,omitempty"`
	Probability  *float64       `json:"probability,omitempty"`
	SiteEntity   *string        `json:"siteEntity,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (DomainControllerRole) IsApplicationServerRole()      {}
func (this DomainControllerRole) GetConfirmed() bool       { return this.Confirmed }
func (this DomainControllerRole) GetFullPath() *string     { return this.FullPath }
func (this DomainControllerRole) GetImpersonator() bool    { return this.Impersonator }
func (this DomainControllerRole) GetProbability() *float64 { return this.Probability }
func (this DomainControllerRole) GetType() EntityRoleType  { return this.Type }

func (DomainControllerRole) IsServerRole() {}

func (DomainControllerRole) IsClassificationRole() {}

func (DomainControllerRole) IsEntityRole() {}

type DomainControllersAdminRoleImpl struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (DomainControllersAdminRoleImpl) IsDomainControllersAdminRole() {}
func (this DomainControllersAdminRoleImpl) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DomainControllersAdminRoleImpl) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DomainControllersAdminRoleImpl) GetBuiltin() bool         { return this.Builtin }
func (this DomainControllersAdminRoleImpl) GetConfirmed() bool       { return this.Confirmed }
func (this DomainControllersAdminRoleImpl) GetFullPath() *string     { return this.FullPath }
func (this DomainControllersAdminRoleImpl) GetProbability() *float64 { return this.Probability }
func (this DomainControllersAdminRoleImpl) GetType() EntityRoleType  { return this.Type }

func (DomainControllersAdminRoleImpl) IsDomainLevelAdminRole() {}

func (DomainControllersAdminRoleImpl) IsAdminAccountRole() {}

func (DomainControllersAdminRoleImpl) IsEntityRole() {}

type DuplicatePasswordRiskEntityFactor struct {
	GroupID  string         `json:"groupId"`
	Score    string         `json:"score"`
	Severity ScoreSeverity  `json:"severity"`
	Type     RiskFactorType `json:"type"`
}

func (DuplicatePasswordRiskEntityFactor) IsEntityRiskFactor()             {}
func (this DuplicatePasswordRiskEntityFactor) GetScore() string           { return this.Score }
func (this DuplicatePasswordRiskEntityFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this DuplicatePasswordRiskEntityFactor) GetType() RiskFactorType    { return this.Type }

type EffectiveGpo struct {
	Domain  *string `json:"domain,omitempty"`
	GpoName *string `json:"gpoName,omitempty"`
}

type EffectiveReplicatorsAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (EffectiveReplicatorsAdminRole) IsEffectiveAdminRole() {}
func (this EffectiveReplicatorsAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EffectiveReplicatorsAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EffectiveReplicatorsAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EffectiveReplicatorsAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this EffectiveReplicatorsAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this EffectiveReplicatorsAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EffectiveReplicatorsAdminRole) GetFullPath() *string     { return this.FullPath }
func (this EffectiveReplicatorsAdminRole) GetProbability() *float64 { return this.Probability }
func (this EffectiveReplicatorsAdminRole) GetType() EntityRoleType  { return this.Type }

func (EffectiveReplicatorsAdminRole) IsAdminAccountRole() {}

func (EffectiveReplicatorsAdminRole) IsEntityRole() {}

// A specialized `Entity` interface for the endpoint, used when `Entity:type` is `ENDPOINT`.
//
// The entity type, as opposed to its classification, is a structural attribute. To
// differentiate between various kinds of endpoints, check their classification
// (see `roles` field).
type EndpointEntity struct {
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	Accounts     []AccountDescriptor `json:"accounts"`
	AgentID      *string             `json:"agentId,omitempty"`
	AgentVersion *string             `json:"agentVersion,omitempty"`
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	Archived bool `json:"archived"`
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	Associations []Association `json:"associations"`
	Cid          *string       `json:"cid,omitempty"`
	CreationTime string        `json:"creationTime"`
	// The date and time of the entity's earliest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	EarliestSeenTraffic *string `json:"earliestSeenTraffic,omitempty"`
	// The entity's unique identifier.
	EntityID             string `json:"entityId"`
	GuestAccountEnabled  *bool  `json:"guestAccountEnabled,omitempty"`
	HasADDomainAdminRole *bool  `json:"hasADDomainAdminRole,omitempty"`
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	HasRole *bool `json:"hasRole,omitempty"`
	// The latest recorded host name for this endpoint.
	HostName *string `json:"hostName,omitempty"`
	// The latest calculated impact score for this entity.
	ImpactScore string `json:"impactScore"`
	// If `true`, the entity is inactive. An entity is considered inactive after 21
	// days since its latest recorded network activity (see `mostRecentActivity`).
	Inactive bool `json:"inactive"`
	// The latest recorded IP address for this endpoint.
	LastIPAddress *string `json:"lastIpAddress,omitempty"`
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	Learned bool `json:"learned"`
	// For marked entities, this is set to the last time the entity was marked.
	MarkTime *string `json:"markTime,omitempty"`
	// The date and time of the entity's latest recorded network activity. This takes
	// into account both the data reported by external sources and the actual traffic
	// seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// Query open incidents for this entity.
	OpenIncidents *IncidentConnection `json:"openIncidents,omitempty"`
	// The latest information about the operating system running on this endpoint.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary display name used to represent this endpoint in user-facing data.
	//
	// For endpoints based on domain accounts, this is derived from the explicit
	// display name, or an analogous attribute, of their primary account. Very often
	// that's the host part of their full DNS host name. Otherwise this is either the
	// `hostName`, if available, or `lastIpAddress`.
	PrimaryDisplayName string `json:"primaryDisplayName"`
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	RiskFactors []EntityRiskFactor `json:"riskFactors"`
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	RiskScore string `json:"riskScore"`
	// The entity's risk score derived from `riskScore`.
	RiskScoreSeverity ScoreSeverity `json:"riskScoreSeverity"`
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	Roles []EntityRole `json:"roles,omitempty"`
	// The secondary display name used to represent this endpoint in user-facing data.
	//
	// For endpoints based on domain accounts, this is set to the same value as
	// `hostName`. Otherwise, this is set to the same value as `lastIpAddress`.
	SecondaryDisplayName string `json:"secondaryDisplayName"`
	// Returns `true` if the system considers this entity shared.
	Shared bool `json:"shared"`
	// If `true`, the entity is stale. An entity is considered stale after 90 days of
	// inactivity (see `mostRecentActivity`), as long as it is still effectively part
	// of the network. An account-based entity is not considered part of the network
	// when all of its base accounts are disabled (see `primaryAccount` and
	// `secondaryAccounts`).
	Stale bool `json:"stale"`
	// List of static IP addresses associated with by this endpoint, as recorded by the system.
	StaticIPAddresses []string `json:"staticIpAddresses"`
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	Type EntityType `json:"type"`
	// If `true`, the system considers this endpoint unmanaged.
	//
	// Unmanaged endpoints are, first and foremost, entities lacking an account in
	// any organization domain (`primaryAccount` would also be null in this case).
	// Since, by their nature, such endpoints are not properly reporting their
	// status, certain restrictions are applied to them.
	Unmanaged bool `json:"unmanaged"`
	// If `true`, this entity appears on the system watchlist.
	Watched bool `json:"watched"`
	// The ZTA Score of this endpoint.
	ZtaScore *int `json:"ztaScore,omitempty"`
}

func (EndpointEntity) IsUserOrEndpointEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
func (this EndpointEntity) GetAccounts() []AccountDescriptor {
	if this.Accounts == nil {
		return nil
	}
	interfaceSlice := make([]AccountDescriptor, 0, len(this.Accounts))
	for _, concrete := range this.Accounts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.
func (this EndpointEntity) GetArchived() bool { return this.Archived }

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.
func (this EndpointEntity) GetAssociations() []Association {
	if this.Associations == nil {
		return nil
	}
	interfaceSlice := make([]Association, 0, len(this.Associations))
	for _, concrete := range this.Associations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EndpointEntity) GetCreationTime() string { return this.CreationTime }

// The date and time of the entity's earliest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this EndpointEntity) GetEarliestSeenTraffic() *string { return this.EarliestSeenTraffic }

// The entity's unique identifier.
func (this EndpointEntity) GetEntityID() string            { return this.EntityID }
func (this EndpointEntity) GetHasADDomainAdminRole() *bool { return this.HasADDomainAdminRole }

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
//
//	{
//	  entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//	  {
//	    nodes
//	    {
//	      type
//	      primaryDisplayName
//	      ... on UserEntity
//	      {
//	        isHuman: hasRole(type: HumanUserAccountRole)
//	        isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//	        isAdmin: hasRole(type: AdminAccountRole)
//	      }
//	      ... on EndpointEntity
//	      {
//	        isWorkstation: hasRole(type: WorkstationRole)
//	        isServer: hasRole(type: WorkstationRole)
//	      }
//	      isManuallyClassified: hasRole(confirmed: true)
//	    }
//	  }
//	}
//
// ```
func (this EndpointEntity) GetHasRole() *bool { return this.HasRole }

// The latest calculated impact score for this entity.
func (this EndpointEntity) GetImpactScore() string { return this.ImpactScore }

// If `true`, the entity is inactive. An entity is considered inactive after 21
// days since its latest recorded network activity (see `mostRecentActivity`).
func (this EndpointEntity) GetInactive() bool { return this.Inactive }

// If `true`, the system has gathered enough information to consider this entity *learned*.
func (this EndpointEntity) GetLearned() bool { return this.Learned }

// For marked entities, this is set to the last time the entity was marked.
func (this EndpointEntity) GetMarkTime() *string { return this.MarkTime }

// The date and time of the entity's latest recorded network activity. This takes
// into account both the data reported by external sources and the actual traffic
// seen by the system.
func (this EndpointEntity) GetMostRecentActivity() *string { return this.MostRecentActivity }

// Query open incidents for this entity.
func (this EndpointEntity) GetOpenIncidents() *IncidentConnection { return this.OpenIncidents }

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.
func (this EndpointEntity) GetPrimaryDisplayName() string { return this.PrimaryDisplayName }

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.
func (this EndpointEntity) GetRiskFactors() []EntityRiskFactor {
	if this.RiskFactors == nil {
		return nil
	}
	interfaceSlice := make([]EntityRiskFactor, 0, len(this.RiskFactors))
	for _, concrete := range this.RiskFactors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
func (this EndpointEntity) GetRiskScore() string { return this.RiskScore }

// The entity's risk score derived from `riskScore`.
func (this EndpointEntity) GetRiskScoreSeverity() ScoreSeverity { return this.RiskScoreSeverity }

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.
func (this EndpointEntity) GetRoles() []EntityRole {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]EntityRole, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The secondary display name is used to represent unique name for this entity in the organization or the network.
func (this EndpointEntity) GetSecondaryDisplayName() string { return this.SecondaryDisplayName }

// Returns `true` if the system considers this entity shared.
func (this EndpointEntity) GetShared() bool { return this.Shared }

// If `true`, the entity is stale. An entity is considered stale after 90 days of
// inactivity (see `mostRecentActivity`), as long as it is still effectively part
// of the network. An account-based entity is not considered part of the network
// when all of its base accounts are disabled (see `primaryAccount` and
// `secondaryAccounts`).
func (this EndpointEntity) GetStale() bool { return this.Stale }

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
func (this EndpointEntity) GetType() EntityType { return this.Type }

// If `true`, this entity appears on the system watchlist.
func (this EndpointEntity) GetWatched() bool { return this.Watched }

func (EndpointEntity) IsActivityParticipatingEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.

// The date and time of the entity's earliest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

// The entity's unique identifier.

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
// {
//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//   {
//     nodes
//     {
//       type
//       primaryDisplayName
//       ... on UserEntity
//       {
//         isHuman: hasRole(type: HumanUserAccountRole)
//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//         isAdmin: hasRole(type: AdminAccountRole)
//       }
//       ... on EndpointEntity
//       {
//         isWorkstation: hasRole(type: WorkstationRole)
//         isServer: hasRole(type: WorkstationRole)
//       }
//       isManuallyClassified: hasRole(confirmed: true)
//     }
//   }
// }
// ```

// If `true`, the entity is inactive. An entity is considered inactive after 21
// days since its latest recorded network activity (see `mostRecentActivity`).

// If `true`, the system has gathered enough information to consider this entity *learned*.

// For marked entities, this is set to the last time the entity was marked.

// The date and time of the entity's latest recorded network activity. This takes
// into account both the data reported by external sources and the actual traffic
// seen by the system.

// Query open incidents for this entity.

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).

// The entity's risk score derived from `riskScore`.

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.

// The secondary display name is used to represent unique name for this entity in the organization or the network.

// If `true`, the entity is stale. An entity is considered stale after 90 days of
// inactivity (see `mostRecentActivity`), as long as it is still effectively part
// of the network. An account-based entity is not considered part of the network
// when all of its base accounts are disabled (see `primaryAccount` and
// `secondaryAccounts`).

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).

// If `true`, this entity appears on the system watchlist.

func (EndpointEntity) IsEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.

// The entity's unique identifier.

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
// {
//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//   {
//     nodes
//     {
//       type
//       primaryDisplayName
//       ... on UserEntity
//       {
//         isHuman: hasRole(type: HumanUserAccountRole)
//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//         isAdmin: hasRole(type: AdminAccountRole)
//       }
//       ... on EndpointEntity
//       {
//         isWorkstation: hasRole(type: WorkstationRole)
//         isServer: hasRole(type: WorkstationRole)
//       }
//       isManuallyClassified: hasRole(confirmed: true)
//     }
//   }
// }
// ```

// If `true`, the system has gathered enough information to consider this entity *learned*.

// For marked entities, this is set to the last time the entity was marked.

// Query open incidents for this entity.

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).

// The entity's risk score derived from `riskScore`.

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.

// The secondary display name is used to represent unique name for this entity in the organization or the network.

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).

// If `true`, this entity appears on the system watchlist.

type EnterpriseAdminsRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (EnterpriseAdminsRole) IsForestLevelAdminRole() {}
func (this EnterpriseAdminsRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EnterpriseAdminsRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EnterpriseAdminsRole) GetBuiltin() bool         { return this.Builtin }
func (this EnterpriseAdminsRole) GetConfirmed() bool       { return this.Confirmed }
func (this EnterpriseAdminsRole) GetFullPath() *string     { return this.FullPath }
func (this EnterpriseAdminsRole) GetProbability() *float64 { return this.Probability }
func (this EnterpriseAdminsRole) GetType() EntityRoleType  { return this.Type }

func (EnterpriseAdminsRole) IsAdminAccountRole() {}

func (EnterpriseAdminsRole) IsEntityRole() {}

// Query criteria for entity accounts.
type EntityAccountQuery struct {
	Archived *bool `json:"archived,omitempty"`
	// Query for any value of the account's `dataSourceLoginIdentifier` field. The search is case-insensitive.
	DataSourceLoginIdentifiers []string `json:"dataSourceLoginIdentifiers,omitempty"`
	// Query for any value of the account's `dataSourceParticipantIdentifier` field. The search is case-insensitive.
	DataSourceParticipantIdentifiers []string `json:"dataSourceParticipantIdentifiers,omitempty"`
	// Query for any value of the account's `dataSource` field.
	DataSources []DataSource `json:"dataSources,omitempty"`
	// Query for any value of the account's `department` field. The search is case-insensitive.
	Departments []string `json:"departments,omitempty"`
	// Query for any value of the account's `domain` using a `WildcardPattern` search. The search is case-insensitive.
	DomainPattern *string `json:"domainPattern,omitempty"`
	// Query for any value of the account's `domain` field. The search is case-insensitive.
	Domains []string `json:"domains,omitempty"`
	// Query for the value of the account's `enabled` field.
	Enabled *bool `json:"enabled,omitempty"`
	// Query for any value of the account's `objectGuid` field. The search is case-insensitive.
	ObjectGuids []string `json:"objectGuids,omitempty"`
	// Query for any value of the account's `objectSid` field. The search is case-insensitive.
	ObjectSids []string `json:"objectSids,omitempty"`
	OuPattern  *string  `json:"ouPattern,omitempty"`
	Ous        []string `json:"ous,omitempty"`
	// Query for any value of the account's `samAccountName` using a `WildcardPattern` search. The search is case-insensitive.
	SamAccountNamePattern *string `json:"samAccountNamePattern,omitempty"`
	// Query for any value of the account's `samAccountName` field. The search is case-insensitive.
	SamAccountNames         []string                  `json:"samAccountNames,omitempty"`
	UserAccountControlFlags []UserAccountControlFlags `json:"userAccountControlFlags,omitempty"`
}

type EntityAssociationImpl struct {
	BindingType BindingType `json:"bindingType"`
	Entity      Entity      `json:"entity"`
}

func (EntityAssociationImpl) IsEntityAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this EntityAssociationImpl) GetBindingType() BindingType { return this.BindingType }

// The associated entity.
func (this EntityAssociationImpl) GetEntity() Entity { return this.Entity }

func (EntityAssociationImpl) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

// Query criteria for `Association` type for entity associations.
type EntityAssociationQuery struct {
	// Query for any value of `Association:bindingType`. A matching entity must have
	// at least one `Association` of any of the specified binding types.
	BindingTypes []BindingType `json:"bindingTypes,omitempty"`
	// Query for associated `EntityAssociation:entity` matching all entity query criteria.
	//
	// ```graphql
	// ##### List users regularly accessing Azure Portal
	// {
	//     entities(
	//         associationQuery: {
	//             bindingTypes: [CLOUD_SERVICE_ACCESS]
	//             entityQuery: {
	//                 # Querying by primaryDisplayNames for demonstration purposes - It's generally recommended to use
	//                 # more reliable identifiers, such as the entityId (queryable via the entityIds argument)
	//                 primaryDisplayNames: ["Azure Portal"]
	//             }
	//         }
	//         types: [USER]
	//         archived: false
	//         first: 2)
	//     {
	//         nodes {
	//             primaryDisplayName
	//             secondaryDisplayName
	//         }
	//     }
	// }
	// ```
	EntityQuery *EntityQueryInput `json:"entityQuery,omitempty"`
}

// A [Relay-Compatible](https://facebook.github.io/relay/graphql/connections.htm)
// Connection type for paginating over `Entity` elements.
type EntityConnection struct {
	// List of `Entity` edges.
	Edges []*EntityEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// A convenience extension to the standard Relay Connection type, directly
	// exposing the `Entity` elements, which may be used *instead* of edges. It is
	// primarily useful in conjunction with `startCursor` and `endCursor`, or when
	// exploring the API interactively (e.g. in GraphiQL).
	Nodes []Entity `json:"nodes"`
}

// An *Entity* object encapsulates and summarizes all the system information on an
// organizational or network entity. The most common entities are users and
// endpoints, but there are also entities representing cloud services and entity
// groups, such as Active Directory groups. More entity types are expected to be
// added in the future.
//
// Entity objects are usually derived from external data sources. For instance, all
// covered user accounts in an Active Directory domain are represented as entities.
// However, entities very often integrate data from multiple sources. The network
// traffic monitored by the system is a primary source for behavioral attributes of
// entities, such as the human versus programmatic classification or the
// association of owned endpoints (see `roles`, `associations`). Moreover, entities
// not always represent a single account: an LDAP user, for example, may be
// correlated with an IDaaS account, resulting in a single, unified entity.
//
// Entities are polymorphic. Attributes for specific entity types can be projected
// from a specialized interface (e.g. `UserOrEndpointEntity`, `EndpointEntity`).
// See the `EntityType` enum documentation for the mapping between entity types and
// entity interfaces.
type EntityContainerEntity struct {
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	Accounts []AccountDescriptor `json:"accounts"`
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	Archived bool `json:"archived"`
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	Associations  []Association       `json:"associations"`
	ContainerType EntityContainerType `json:"containerType"`
	CreationTime  string              `json:"creationTime"`
	// The entity's unique identifier.
	EntityID             string `json:"entityId"`
	HasADDomainAdminRole *bool  `json:"hasADDomainAdminRole,omitempty"`
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	HasRole *bool `json:"hasRole,omitempty"`
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	Learned bool `json:"learned"`
	// For marked entities, this is set to the last time the entity was marked.
	MarkTime *string `json:"markTime,omitempty"`
	// Query open incidents for this entity.
	OpenIncidents *IncidentConnection `json:"openIncidents,omitempty"`
	// The primary display name used to represent this entity in user-facing data.
	//
	// The primary display name is typically shorter than the secondary display name,
	// but is much less likely to be unique across the organization or network. For
	// further details on the semantics, see the documentation for specific types.
	PrimaryDisplayName string `json:"primaryDisplayName"`
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	RiskFactors []EntityRiskFactor `json:"riskFactors"`
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	RiskScore string `json:"riskScore"`
	// The entity's risk score derived from `riskScore`.
	RiskScoreSeverity ScoreSeverity `json:"riskScoreSeverity"`
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	Roles []EntityRole `json:"roles,omitempty"`
	// The secondary display name is used to represent unique name for this entity in the organization or the network.
	SecondaryDisplayName string `json:"secondaryDisplayName"`
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	Type EntityType `json:"type"`
	// If `true`, this entity appears on the system watchlist.
	Watched bool `json:"watched"`
}

func (EntityContainerEntity) IsEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
func (this EntityContainerEntity) GetAccounts() []AccountDescriptor {
	if this.Accounts == nil {
		return nil
	}
	interfaceSlice := make([]AccountDescriptor, 0, len(this.Accounts))
	for _, concrete := range this.Accounts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.
func (this EntityContainerEntity) GetArchived() bool { return this.Archived }

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.
func (this EntityContainerEntity) GetAssociations() []Association {
	if this.Associations == nil {
		return nil
	}
	interfaceSlice := make([]Association, 0, len(this.Associations))
	for _, concrete := range this.Associations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EntityContainerEntity) GetCreationTime() string { return this.CreationTime }

// The entity's unique identifier.
func (this EntityContainerEntity) GetEntityID() string            { return this.EntityID }
func (this EntityContainerEntity) GetHasADDomainAdminRole() *bool { return this.HasADDomainAdminRole }

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
//
//	{
//	  entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//	  {
//	    nodes
//	    {
//	      type
//	      primaryDisplayName
//	      ... on UserEntity
//	      {
//	        isHuman: hasRole(type: HumanUserAccountRole)
//	        isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//	        isAdmin: hasRole(type: AdminAccountRole)
//	      }
//	      ... on EndpointEntity
//	      {
//	        isWorkstation: hasRole(type: WorkstationRole)
//	        isServer: hasRole(type: WorkstationRole)
//	      }
//	      isManuallyClassified: hasRole(confirmed: true)
//	    }
//	  }
//	}
//
// ```
func (this EntityContainerEntity) GetHasRole() *bool { return this.HasRole }

// If `true`, the system has gathered enough information to consider this entity *learned*.
func (this EntityContainerEntity) GetLearned() bool { return this.Learned }

// For marked entities, this is set to the last time the entity was marked.
func (this EntityContainerEntity) GetMarkTime() *string { return this.MarkTime }

// Query open incidents for this entity.
func (this EntityContainerEntity) GetOpenIncidents() *IncidentConnection { return this.OpenIncidents }

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.
func (this EntityContainerEntity) GetPrimaryDisplayName() string { return this.PrimaryDisplayName }

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.
func (this EntityContainerEntity) GetRiskFactors() []EntityRiskFactor {
	if this.RiskFactors == nil {
		return nil
	}
	interfaceSlice := make([]EntityRiskFactor, 0, len(this.RiskFactors))
	for _, concrete := range this.RiskFactors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
func (this EntityContainerEntity) GetRiskScore() string { return this.RiskScore }

// The entity's risk score derived from `riskScore`.
func (this EntityContainerEntity) GetRiskScoreSeverity() ScoreSeverity { return this.RiskScoreSeverity }

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.
func (this EntityContainerEntity) GetRoles() []EntityRole {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]EntityRole, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The secondary display name is used to represent unique name for this entity in the organization or the network.
func (this EntityContainerEntity) GetSecondaryDisplayName() string { return this.SecondaryDisplayName }

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
func (this EntityContainerEntity) GetType() EntityType { return this.Type }

// If `true`, this entity appears on the system watchlist.
func (this EntityContainerEntity) GetWatched() bool { return this.Watched }

// A `Entity` edge in a connection.
type EntityEdge struct {
	// Cursor pointing to this edge, to be used in standard pagination query arguments (`before`, `after`).
	Cursor string `json:"cursor"`
	// The `Entity` item at the end of this edge.
	Node Entity `json:"node"`
}

type EntityImpl struct {
	Accounts             []AccountDescriptor `json:"accounts"`
	Archived             bool                `json:"archived"`
	Associations         []Association       `json:"associations"`
	CreationTime         string              `json:"creationTime"`
	EntityID             string              `json:"entityId"`
	HasADDomainAdminRole *bool               `json:"hasADDomainAdminRole,omitempty"`
	HasRole              *bool               `json:"hasRole,omitempty"`
	Learned              bool                `json:"learned"`
	MarkTime             *string             `json:"markTime,omitempty"`
	OpenIncidents        *IncidentConnection `json:"openIncidents,omitempty"`
	PrimaryDisplayName   string              `json:"primaryDisplayName"`
	RiskFactors          []EntityRiskFactor  `json:"riskFactors"`
	RiskScore            string              `json:"riskScore"`
	RiskScoreSeverity    ScoreSeverity       `json:"riskScoreSeverity"`
	Roles                []EntityRole        `json:"roles,omitempty"`
	SecondaryDisplayName string              `json:"secondaryDisplayName"`
	Type                 EntityType          `json:"type"`
	Watched              bool                `json:"watched"`
}

func (EntityImpl) IsEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
func (this EntityImpl) GetAccounts() []AccountDescriptor {
	if this.Accounts == nil {
		return nil
	}
	interfaceSlice := make([]AccountDescriptor, 0, len(this.Accounts))
	for _, concrete := range this.Accounts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.
func (this EntityImpl) GetArchived() bool { return this.Archived }

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.
func (this EntityImpl) GetAssociations() []Association {
	if this.Associations == nil {
		return nil
	}
	interfaceSlice := make([]Association, 0, len(this.Associations))
	for _, concrete := range this.Associations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this EntityImpl) GetCreationTime() string { return this.CreationTime }

// The entity's unique identifier.
func (this EntityImpl) GetEntityID() string            { return this.EntityID }
func (this EntityImpl) GetHasADDomainAdminRole() *bool { return this.HasADDomainAdminRole }

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
//
//	{
//	  entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//	  {
//	    nodes
//	    {
//	      type
//	      primaryDisplayName
//	      ... on UserEntity
//	      {
//	        isHuman: hasRole(type: HumanUserAccountRole)
//	        isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//	        isAdmin: hasRole(type: AdminAccountRole)
//	      }
//	      ... on EndpointEntity
//	      {
//	        isWorkstation: hasRole(type: WorkstationRole)
//	        isServer: hasRole(type: WorkstationRole)
//	      }
//	      isManuallyClassified: hasRole(confirmed: true)
//	    }
//	  }
//	}
//
// ```
func (this EntityImpl) GetHasRole() *bool { return this.HasRole }

// If `true`, the system has gathered enough information to consider this entity *learned*.
func (this EntityImpl) GetLearned() bool { return this.Learned }

// For marked entities, this is set to the last time the entity was marked.
func (this EntityImpl) GetMarkTime() *string { return this.MarkTime }

// Query open incidents for this entity.
func (this EntityImpl) GetOpenIncidents() *IncidentConnection { return this.OpenIncidents }

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.
func (this EntityImpl) GetPrimaryDisplayName() string { return this.PrimaryDisplayName }

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.
func (this EntityImpl) GetRiskFactors() []EntityRiskFactor {
	if this.RiskFactors == nil {
		return nil
	}
	interfaceSlice := make([]EntityRiskFactor, 0, len(this.RiskFactors))
	for _, concrete := range this.RiskFactors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
func (this EntityImpl) GetRiskScore() string { return this.RiskScore }

// The entity's risk score derived from `riskScore`.
func (this EntityImpl) GetRiskScoreSeverity() ScoreSeverity { return this.RiskScoreSeverity }

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.
func (this EntityImpl) GetRoles() []EntityRole {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]EntityRole, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The secondary display name is used to represent unique name for this entity in the organization or the network.
func (this EntityImpl) GetSecondaryDisplayName() string { return this.SecondaryDisplayName }

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
func (this EntityImpl) GetType() EntityType { return this.Type }

// If `true`, this entity appears on the system watchlist.
func (this EntityImpl) GetWatched() bool { return this.Watched }

// Query criteria for filtering results by `Entity` attributes.
//
// All specified criteria must be met for a result to match.
type EntityQueryInput struct {
	// Query for entities which were created before the specified date.
	AccountCreationEndTime *string `json:"accountCreationEndTime,omitempty"`
	// Query for entities which were created on or after the specified date.
	AccountCreationStartTime *string `json:"accountCreationStartTime,omitempty"`
	// Query for entities that have an account set to expire before the specified
	// date (see `ActiveDirectoryAccountDescriptor::expirationTime`).
	//
	// ```graphql
	// {
	//   ##### Accounts expiring in the next 3 months
	//   entities(accountExpirationStartTime: "P0D", # Now
	//            accountExpirationEndTime: "P3M", # Now + 3 months
	//            first: 100)
	//   {
	//     nodes
	//     {
	//       primaryDisplayName
	//       accounts
	//       {
	//         ... on ActiveDirectoryAccountDescriptor
	//         {
	//           expirationTime
	//         }
	//       }
	//     }
	//   }
	// }
	// ```
	AccountExpirationEndTime *string `json:"accountExpirationEndTime,omitempty"`
	// Query for entities that have an account set to expire on or after the
	// specified date (see `ActiveDirectoryAccountDescriptor::expirationTime`).
	//
	// ```graphql
	// {
	//   ##### Accounts expiring in the next 3 months
	//   entities(accountExpirationStartTime: "P0D", # Now
	//            accountExpirationEndTime: "P3M", # Now + 3 months
	//            first: 100)
	//   {
	//     nodes
	//     {
	//       primaryDisplayName
	//       accounts
	//       {
	//         ... on ActiveDirectoryAccountDescriptor
	//         {
	//           expirationTime
	//         }
	//       }
	//     }
	//   }
	// }
	// ```
	AccountExpirationStartTime *string `json:"accountExpirationStartTime,omitempty"`
	// Query for entities which are currently locked out of one of their accounts
	// (see `ActiveDirectoryAccountDescriptor:enabled`). If `false`, query for all
	// other entities.
	AccountLocked *bool `json:"accountLocked,omitempty"`
	// Query for entities having at least one account matching all of the specified query criteria.
	AccountQuery *EntityAccountQuery `json:"accountQuery,omitempty"`
	AgentIds     []string            `json:"agentIds,omitempty"`
	// The query is a match if all specified conditions are true
	All []*EntityQueryInput `json:"all,omitempty"`
	// The query is a match if any of the specified conditions are true
	Any []*EntityQueryInput `json:"any,omitempty"`
	// Query for entities whose `Entity` attribute is set as `Entity:archived`.
	Archived *bool `json:"archived,omitempty"`
	// Query for any value of `Entity:associations:bindingType`. A matching entity
	// must have at least one `Association` of any of the specified binding types.
	AssociationBindingTypes []BindingType `json:"associationBindingTypes,omitempty"`
	// Query for entities having at least one association matching all query criteria.
	//
	// ```graphql
	// ##### List users regularly accessing Azure Portal
	// {
	//     entities(
	//         associationQuery: {
	//             bindingTypes: [CLOUD_SERVICE_ACCESS]
	//             entityQuery: {
	//                 # Querying by primaryDisplayNames for demonstration purposes - It's generally recommended to use
	//                 # more reliable identifiers, such as the entityId (queryable via the entityIds argument)
	//                 primaryDisplayNames: ["Azure Portal"]
	//             }
	//         }
	//         types: [USER]
	//         archived: false
	//         first: 2)
	//     {
	//         nodes {
	//             primaryDisplayName
	//             secondaryDisplayName
	//         }
	//     }
	// }
	// ```
	AssociationQuery *EntityAssociationQuery `json:"associationQuery,omitempty"`
	// Query for any value of `HumanUserAccountRole:businessRole`. Only entities classified as Human can be matched.
	BusinessRoles []BusinessRole `json:"businessRoles,omitempty"`
	// Query for entities that have at least one SSO account on a cloud service.
	CloudEnabled *bool `json:"cloudEnabled,omitempty"`
	// Query for entities that have accounts only on cloud directories.
	CloudOnly      *bool                 `json:"cloudOnly,omitempty"`
	ContainerTypes []EntityContainerType `json:"containerTypes,omitempty"`
	// Query for any value of `AccountDescriptor.dataSource` in all entity's accounts.
	DataSources []DataSource `json:"dataSources,omitempty"`
	// Query for any value of `ActiveDirectoryAccountDescriptor:department` in all
	// entity's accounts. The search is case-insensitive.
	Departments []string `json:"departments,omitempty"`
	// Query for entities which are directly member of any of the Active Directory
	// group entities matched by the given query input. To query all members, use the
	// `memberOfActiveDirectoryGroups` query argument instead.
	//
	// #### Examples
	// ```graphql
	// #### Querying for group membership - direct vs. all memebers
	// {
	//     # We're using then primaryDisplayName argument here for the sake of the demo. In production code, it's much
	//     # better to use a more reliable identifier, such as the entityIds or the secondaryDisplayNames query arguments.
	//
	//     direct: entities(
	//         first: 2
	//         directMemberOfActiveDirectoryGroups: {
	//             primaryDisplayNames: ["Administrators"]
	//         }) {
	//         nodes {
	//             type
	//             primaryDisplayName
	//             secondaryDisplayName
	//         }
	//     }
	//
	//     directAndIndirect: entities(
	//         first: 2
	//         memberOfActiveDirectoryGroups: {
	//            primaryDisplayNames: ["Administrators"]
	//         }) {
	//         nodes {
	//             type
	//             primaryDisplayName
	//             secondaryDisplayName
	//         }
	//     }
	// }
	// ```
	DirectMemberOfActiveDirectoryGroups *EntityQueryInput `json:"directMemberOfActiveDirectoryGroups,omitempty"`
	// Query for entities which are member of any of the entity containers matched by the given query input.
	DirectMemberOfContainers *EntityQueryInput `json:"directMemberOfContainers,omitempty"`
	// Query for any value of `ActiveDirectoryEntryDescriptor:domain` in all entity's
	// accounts using a `WildcardPattern` search. The search is case-insensitive.
	DomainPattern *string `json:"domainPattern,omitempty"`
	// Query for any value of `ActiveDirectoryEntryDescriptor:domain` in all entity's accounts. The search is case-insensitive.
	Domains                  []string `json:"domains,omitempty"`
	DuplicatePasswordGroupID *string  `json:"duplicatePasswordGroupId,omitempty"`
	// Query for any value of `UserEndpoint:emailAddress` using a `WildcardPattern` search. The search is case-insensitive.
	EmailAddressPattern *string  `json:"emailAddressPattern,omitempty"`
	EmailAddresses      []string `json:"emailAddresses,omitempty"`
	// Query for value of `AccountDescriptor:enabled` in all entity's accounts.
	Enabled *bool `json:"enabled,omitempty"`
	// Query for entities which are either `enabled` or `unmanaged`.
	EnabledOrUnmanaged *bool `json:"enabledOrUnmanaged,omitempty"`
	// Query for any value of `Entity:entityId`.
	EntityIds  []string `json:"entityIds,omitempty"`
	HasAccount *bool    `json:"hasAccount,omitempty"`
	// Query for entities one of whose accounts has an aged password (see `PasswordAttributes:aged`).
	HasAgedPassword *bool `json:"hasAgedPassword,omitempty"`
	HasAgent        *bool `json:"hasAgent,omitempty"`
	HasAnySpn       *bool `json:"hasAnySPN,omitempty"`
	HasEmailAddress *bool `json:"hasEmailAddress,omitempty"`
	// Query for entities one of whose accounts has an exposed password (see `PasswordAttributes:exposed`).
	HasExposedPassword *bool `json:"hasExposedPassword,omitempty"`
	HasLinkedAccounts  *bool `json:"hasLinkedAccounts,omitempty"`
	// Query for entities one of whose accounts has a never-expiring password (see `PasswordAttributes:mayExpire`).
	HasNeverExpiringPassword *bool `json:"hasNeverExpiringPassword,omitempty"`
	// Query for entities which participate in at least one open incident (see `Incident:state`).
	HasOpenIncidents   *bool `json:"hasOpenIncidents,omitempty"`
	HasStaticIPAddress *bool `json:"hasStaticIpAddress,omitempty"`
	// Query for endpoint entities with a vulnerable operating system (see `EndpointEntity::operatingSystemInfo`).
	//
	// All `OperatingSystemVulnerability` values except `NONE` and `UNKNOWN` are considered *vulnerable*.
	HasVulnerableOs *bool `json:"hasVulnerableOs,omitempty"`
	// Query for entities one of whose accounts has a weak password (see `PasswordAttributes:strength`).
	HasWeakPassword *bool `json:"hasWeakPassword,omitempty"`
	// Query for any value of `EndpointEntity:hostName` using a `WildcardPattern` search. The search is case-insensitive.
	HostNamePattern *string `json:"hostNamePattern,omitempty"`
	// Query for any value of `EndpointEntity:hostName`. The search is case-insensitive.
	HostNames []string `json:"hostNames,omitempty"`
	ID        *string  `json:"id,omitempty"`
	Ids       []string `json:"ids,omitempty"`
	// Query for endpoints typically used for impersonation. An `impersonator `
	// endpoint has at least one `ServerRole` (or one of its sub-types) for which
	// `ServerRole:impersonator` is set to `true`.
	Impersonator *bool `json:"impersonator,omitempty"`
	// Query for entities whose `ActivityParticipatingEntity` attribute is set as `ActivityParticipatingEntity:inactive`.
	Inactive            *bool   `json:"inactive,omitempty"`
	InsightCounterID    *string `json:"insightCounterId,omitempty"`
	InsightsQuery       *string `json:"insightsQuery,omitempty"`
	LastUpdateEndTime   *string `json:"lastUpdateEndTime,omitempty"`
	LastUpdateStartTime *string `json:"lastUpdateStartTime,omitempty"`
	// Query for a value of `Entity:learned`.
	Learned             *bool    `json:"learned,omitempty"`
	LinkingSuggestions  *string  `json:"linkingSuggestions,omitempty"`
	LocalAdminEntityIds []string `json:"localAdminEntityIds,omitempty"`
	// Query for marked entities (see `Entity:markTime`).
	Marked *bool `json:"marked,omitempty"`
	// Query for a maximal value of `Entity:riskScoreSeverity`.
	MaxRiskScoreSeverity *ScoreSeverity `json:"maxRiskScoreSeverity,omitempty"`
	// Query for entities which are member of any of the Active Directory group
	// entities matched by the given query input, directly via another group. To
	// query for direct members only, use the `directMemberOfActiveDirectoryGroups`
	// query argument instead.
	//
	// #### Examples
	// ```graphql
	// #### Querying for group membership - direct vs. all memebers
	// {
	//     # We're using then primaryDisplayName argument here for the sake of the demo. In production code, it's much
	//     # better to use a more reliable identifier, such as the entityIds or the secondaryDisplayNames query arguments.
	//
	//     direct: entities(
	//         first: 2
	//         directMemberOfActiveDirectoryGroups: {
	//             primaryDisplayNames: ["Administrators"]
	//         }) {
	//         nodes {
	//             type
	//             primaryDisplayName
	//             secondaryDisplayName
	//         }
	//     }
	//
	//     directAndIndirect: entities(
	//         first: 2
	//         memberOfActiveDirectoryGroups: {
	//            primaryDisplayNames: ["Administrators"]
	//         }) {
	//         nodes {
	//             type
	//             primaryDisplayName
	//             secondaryDisplayName
	//         }
	//     }
	// }
	// ```
	MemberOfActiveDirectoryGroups *EntityQueryInput `json:"memberOfActiveDirectoryGroups,omitempty"`
	// Query for entities which are member of any of the entity containers matched by
	// the given query input, directly via another group. To query for direct members
	// only, use the `directMemberOfContainers` query argument instead.
	MemberOfContainers *EntityQueryInput `json:"memberOfContainers,omitempty"`
	// Query for a minimal value of `Entity:riskScoreSeverity`.
	MinRiskScoreSeverity *ScoreSeverity `json:"minRiskScoreSeverity,omitempty"`
	// Query for entities with any recorded network activity before the specified date.
	MostRecentActivityEndTime *string `json:"mostRecentActivityEndTime,omitempty"`
	// Query for entities with any recorded network activity on of after the specified date.
	MostRecentActivityStartTime *string `json:"mostRecentActivityStartTime,omitempty"`
	// Query for entities with any recorded on premise network activity before the specified date.
	MostRecentOnPremiseActivityEndTime *string `json:"mostRecentOnPremiseActivityEndTime,omitempty"`
	// Query for entities with any recorded on premise network activity on of after the specified date.
	MostRecentOnPremiseActivityStartTime *string `json:"mostRecentOnPremiseActivityStartTime,omitempty"`
	// Query for entities with any recorded SSO network activity before the specified date.
	MostRecentSSOActivityEndTime *string `json:"mostRecentSSOActivityEndTime,omitempty"`
	// Query for entities with any recorded SSO network activity on of after the specified date.
	MostRecentSSOActivityStartTime *string `json:"mostRecentSSOActivityStartTime,omitempty"`
	NameSearch                     *string `json:"nameSearch,omitempty"`
	NeverLoggedOn                  *bool   `json:"neverLoggedOn,omitempty"`
	// The query is a match if this conditions are not true
	//
	// ```graphql
	// ##### List privileged entities, except those who have Extensive Local Administrators role
	// {
	//     entities(roles: [AdminAccountRole]
	//              not: {roles: [LocalAdminRole]}
	//              archived: false
	//              first: 2)
	//     {
	//         nodes {
	//             primaryDisplayName
	//             secondaryDisplayName
	//             roles {
	//                 type
	//             }
	//         }
	//     }
	// }
	// ```
	Not                     *EntityQueryInput `json:"not,omitempty"`
	ObjectSids              []string          `json:"objectSids,omitempty"`
	OperatingSystemFamilies []string          `json:"operatingSystemFamilies,omitempty"`
	OuPattern               *string           `json:"ouPattern,omitempty"`
	Ous                     []string          `json:"ous,omitempty"`
	// Query for user entities whose password changed before the specified date.
	PasswordLastChangeEndTime *string `json:"passwordLastChangeEndTime,omitempty"`
	// Query for user entities whose password changed on or after the specified date.
	PasswordLastChangeStartTime *string  `json:"passwordLastChangeStartTime,omitempty"`
	PasswordTokens              []string `json:"passwordTokens,omitempty"`
	// Query for any value of `Entity:primaryDisplayName` using a `WildcardPattern` search. The search is case-insensitive.
	PrimaryDisplayNamePattern *string `json:"primaryDisplayNamePattern,omitempty"`
	// Query for any value of `Entity:primaryDisplayName`.
	PrimaryDisplayNames []string `json:"primaryDisplayNames,omitempty"`
	// Query for any value of `RiskFactorContribution:type` given each entity's risk factors (see `riskFactors`).
	RiskFactorTypes []RiskFactorType `json:"riskFactorTypes,omitempty"`
	// Query for entities whose risk-score is equal or greater than the specified value.
	RiskScoreLowerBound *string `json:"riskScoreLowerBound,omitempty"`
	// Query for entities whose risk-score is lower than the specified value.
	RiskScoreUpperBound *string `json:"riskScoreUpperBound,omitempty"`
	// Query for user entities having a RBAC role assignment association matching query criteria
	//
	// ```graphql
	// ##### List role display names associated with the following scope id
	// {
	//     entities(first:1, associationBindingTypes: [RBAC_ASSIGNMENT],
	//         roleAssignmentAssociationQuery: {
	//             scopeIds: ["dedf3e09-aa9a-4f7e-b3f1-9a30ea597797"]
	//         }) {
	//         nodes {
	//             associations {
	//                 ... on SsoRbacAssignmentAssociation {
	//                     roles {
	//                         displayName
	//                     }
	//                 }
	//             }
	//         }
	//     }
	// }
	// ```
	RoleAssignmentAssociationQuery *RoleAssignmentAssociationQuery `json:"roleAssignmentAssociationQuery,omitempty"`
	// **Deprecated**. Use `roles`, `all` instead.
	RoleGroups [][]EntityRoleType `json:"roleGroups,omitempty"`
	// Query `Entity:roles`. A matching entity is guaranteed to have at least one of the specified role types.
	Roles []EntityRoleType `json:"roles,omitempty"`
	// Query for any value of `ActiveDirectoryAccountDescriptor:samAccountName` in
	// all entity's accounts using a `WildcardPattern` search. The search is
	// case-insensitive.
	SamAccountNamePattern *string `json:"samAccountNamePattern,omitempty"`
	// Query for any value of `ActiveDirectoryAccountDescriptor:samAccountName` in
	// all entity's accounts. The search is case-insensitive.
	//
	// ```graphql
	// ##### Look up a user by their sam-account-name
	// {
	//   # Query for the built-in "Administrator" account.
	//   # This is merely an illustration of the samAccountNames query argument.
	//   # See the roles query argument for more powerful options to query
	//   # privileged accounts
	//   entities(samAccountNames: ["administrator"]
	//            # Uncomment and fill in your domain here to ensure
	//            # a single match
	//            # domain: "MY.DOMAIN"
	//            archived: false
	//            first: 1)
	//   {
	//     nodes {
	//       entityId
	//       primaryDisplayName
	//       secondaryDisplayName
	//       roles
	//       {
	//         type
	//       }
	//         ... on UserOrEndpointEntity
	//         {
	//           riskScoreSeverity
	//         }
	//     }
	//   }
	// }
	// ```
	SamAccountNames []string `json:"samAccountNames,omitempty"`
	// Query for any value of `Entity:secondaryDisplayName` using a `WildcardPattern` search. The search is case-insensitive.
	SecondaryDisplayNamePattern *string `json:"secondaryDisplayNamePattern,omitempty"`
	// Query for any value of `Entity:secondaryDisplayName`.
	SecondaryDisplayNames []string `json:"secondaryDisplayNames,omitempty"`
	// Query for entities whose `UserOrEndpointEntity` attribute is set as `UserOrEndpointEntity:shared`.
	Shared *bool `json:"shared,omitempty"`
	// Query for entities whose `ActivityParticipatingEntity` attribute is set as `ActivityParticipatingEntity:stale`.
	Stale   *bool       `json:"stale,omitempty"`
	Tenants []string    `json:"tenants,omitempty"`
	Type    *EntityType `json:"type,omitempty"`
	// Query for any value of `Entity:type`.
	Types []EntityType `json:"types,omitempty"`
	// Query for unmanaged endpoints (see `EndpointEntity:unmanaged`).
	Unmanaged               *bool                     `json:"unmanaged,omitempty"`
	UserAccountControlFlags []UserAccountControlFlags `json:"userAccountControlFlags,omitempty"`
	// Query for any instance of `Entity:watched`.
	Watched *bool `json:"watched,omitempty"`
}

type EntityRiskFactorImpl struct {
	Score    string         `json:"score"`
	Severity ScoreSeverity  `json:"severity"`
	Type     RiskFactorType `json:"type"`
}

func (EntityRiskFactorImpl) IsEntityRiskFactor()             {}
func (this EntityRiskFactorImpl) GetScore() string           { return this.Score }
func (this EntityRiskFactorImpl) GetSeverity() ScoreSeverity { return this.Severity }
func (this EntityRiskFactorImpl) GetType() RiskFactorType    { return this.Type }

type EntityRoleImpl struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (EntityRoleImpl) IsEntityRole()                 {}
func (this EntityRoleImpl) GetConfirmed() bool       { return this.Confirmed }
func (this EntityRoleImpl) GetFullPath() *string     { return this.FullPath }
func (this EntityRoleImpl) GetProbability() *float64 { return this.Probability }
func (this EntityRoleImpl) GetType() EntityRoleType  { return this.Type }

type ErrorDetailsImpl struct {
	Message string `json:"message"`
}

func (ErrorDetailsImpl) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this ErrorDetailsImpl) GetMessage() string { return this.Message }

type ExchangeServerRole struct {
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Impersonator bool           `json:"impersonator"`
	Probability  *float64       `json:"probability,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (ExchangeServerRole) IsApplicationServerRole()      {}
func (this ExchangeServerRole) GetConfirmed() bool       { return this.Confirmed }
func (this ExchangeServerRole) GetFullPath() *string     { return this.FullPath }
func (this ExchangeServerRole) GetImpersonator() bool    { return this.Impersonator }
func (this ExchangeServerRole) GetProbability() *float64 { return this.Probability }
func (this ExchangeServerRole) GetType() EntityRoleType  { return this.Type }

func (ExchangeServerRole) IsServerRole() {}

func (ExchangeServerRole) IsClassificationRole() {}

func (ExchangeServerRole) IsEntityRole() {}

type ExposedLocalAdminsEntityRiskFactor struct {
	ExposedUsers []*ExposedLocalUserData `json:"exposedUsers"`
	Score        string                  `json:"score"`
	Severity     ScoreSeverity           `json:"severity"`
	Type         RiskFactorType          `json:"type"`
}

func (ExposedLocalAdminsEntityRiskFactor) IsEntityRiskFactor()             {}
func (this ExposedLocalAdminsEntityRiskFactor) GetScore() string           { return this.Score }
func (this ExposedLocalAdminsEntityRiskFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this ExposedLocalAdminsEntityRiskFactor) GetType() RiskFactorType    { return this.Type }

type ExposedLocalUserData struct {
	AccountName string  `json:"accountName"`
	Domain      *string `json:"domain,omitempty"`
	GpoName     *string `json:"gpoName,omitempty"`
}

type FileServerRole struct {
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Impersonator bool           `json:"impersonator"`
	Probability  *float64       `json:"probability,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (FileServerRole) IsApplicationServerRole()      {}
func (this FileServerRole) GetConfirmed() bool       { return this.Confirmed }
func (this FileServerRole) GetFullPath() *string     { return this.FullPath }
func (this FileServerRole) GetImpersonator() bool    { return this.Impersonator }
func (this FileServerRole) GetProbability() *float64 { return this.Probability }
func (this FileServerRole) GetType() EntityRoleType  { return this.Type }

func (FileServerRole) IsServerRole() {}

func (FileServerRole) IsClassificationRole() {}

func (FileServerRole) IsEntityRole() {}

type GeoJSONProperties struct {
	CountryCode    *string `json:"countryCode,omitempty"`
	StateCode      *string `json:"stateCode,omitempty"`
	CityCode       *string `json:"cityCode,omitempty"`
	AccuracyRadius *string `json:"accuracyRadius,omitempty"`
}

// An object representing a geographical location.
//
// The fields `coordinates`, `type`, and `properties` should be used only for
// compatibility with [GeoJSON](http://geojson.org/) compatibility. Otherwise, they
// can be replaced with more user-friendly fields that retrieve the same information.
//
// ```graphql
//
//	{
//	  # An IDAAS connector must be configured for this query to return any results.
//	  timeline(
//	    first: 1
//	    categories: ACTIVITY
//	    dataSourceCategories: [IDAAS]
//	    sortOrder: DESCENDING)
//	  {
//	    nodes
//	    {
//	      ... on TimelineUserOnEndpointActivityEvent
//	      {
//	        geoLocation
//	        {
//	          longitude
//	          latitude
//	          longitude
//	          countryCode
//	          stateCode
//	          cityCode
//	          accuracyRadius
//
//	          # These fields are not available in geo-json form
//	          country
//	          city
//	          blacklisted
//	          whitelisted
//	          timeZone
//	        }
//
//	        # Alternative, geo-json projection
//	        geoJsonFrom: geoLocation {
//	          type
//	          coordinates
//	          properties {
//	            countryCode
//	            stateCode
//	            cityCode
//	            accuracyRadius
//	          }
//	        }
//	      }
//	    }
//	  }
//	}
//
// ```
type GeoLocation struct {
	// The accuracy radius reported for this location.
	AccuracyRadius *int `json:"accuracyRadius,omitempty"`
	// Returns `true` if the country associated with this location appears on the user-configured blacklist.
	Blacklisted *bool `json:"blacklisted,omitempty"`
	// If the city for this location is identified, its name is returned. Prefer `cityCode` for programmatic usage.
	City *string `json:"city,omitempty"`
	// If the city for this location is identified, the respective city code is presented.
	CityCode *int `json:"cityCode,omitempty"`
	// Location coordinates ordered as `(longitude, latitude)`.
	//
	// This field should be used only for GeoJSON compatibility. It retrieves the
	// same data as the `longitude` and `latitude` properties.
	Coordinates []float64 `json:"coordinates"`
	// If the country for this location is identified, its name is returned. Prefer `countryCode` for programmatic usage.
	Country *string `json:"country,omitempty"`
	// If the country for this location is identified, it is represented as a
	// [two-letter ISO-3166-1 country
	// code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
	CountryCode *string `json:"countryCode,omitempty"`
	// The location latitude
	Latitude float64 `json:"latitude"`
	// The location longitude
	Longitude float64 `json:"longitude"`
	// Additional properties (besides coordinates) known for this location.
	//
	// This field should be used only for GeoJSON compatibility. It retrieves the same data as non-nested fields,
	Properties *GeoJSONProperties `json:"properties,omitempty"`
	// If the state for this location is identified, the respective state code is presented.
	StateCode *string `json:"stateCode,omitempty"`
	// GeoJSON's `type` field (always returns `Point`)
	Type GeoJSONType `json:"type"`
	// Returns `true` if the country associated with this location appears on the user-configured whitelist.
	Whitelisted *bool `json:"whitelisted,omitempty"`
}

// An association between two entities. The nature of the association and the specific subtype are determined by `bindingType`.
//
// **Symmetric vs. Asymmetric**: Depending on the binding type, an association can
// be symmetric or asymmetric. A symmetric association is set on both participating
// entities, each pointing to the other one. For example, the `LOGIN` association
// is symmetric. Therefore, if a user has a `LOGIN` association with an endpoint,
// the endpoint should have the same association with the user. Conversely, if a
// user has a `SERVICE_ACCESS` association with a server, the server is not
// supposed to have the same association with the user, because the
// `SERVICE_ACCESS` association is asymmetric. The documentation for `BindingType`
// specifies which binding types are symmetric and which are asymmetric.
type GeoLocationAssociation struct {
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType BindingType  `json:"bindingType"`
	GeoLocation *GeoLocation `json:"geoLocation"`
}

func (GeoLocationAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this GeoLocationAssociation) GetBindingType() BindingType { return this.BindingType }

type GpoBasedRiskEntityFactor struct {
	EffectiveGpos []*EffectiveGpo `json:"effectiveGpos"`
	Score         string          `json:"score"`
	Severity      ScoreSeverity   `json:"severity"`
	Type          RiskFactorType  `json:"type"`
}

func (GpoBasedRiskEntityFactor) IsEntityRiskFactor()             {}
func (this GpoBasedRiskEntityFactor) GetScore() string           { return this.Score }
func (this GpoBasedRiskEntityFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this GpoBasedRiskEntityFactor) GetType() RiskFactorType    { return this.Type }

type HoneytokenRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (HoneytokenRole) IsClassificationRole()         {}
func (this HoneytokenRole) GetConfirmed() bool       { return this.Confirmed }
func (this HoneytokenRole) GetFullPath() *string     { return this.FullPath }
func (this HoneytokenRole) GetProbability() *float64 { return this.Probability }
func (this HoneytokenRole) GetType() EntityRoleType  { return this.Type }

func (HoneytokenRole) IsEntityRole() {}

type HumanUserAccountRole struct {
	BusinessRole BusinessRole   `json:"businessRole"`
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Probability  *float64       `json:"probability,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (HumanUserAccountRole) IsClassificationRole()         {}
func (this HumanUserAccountRole) GetConfirmed() bool       { return this.Confirmed }
func (this HumanUserAccountRole) GetFullPath() *string     { return this.FullPath }
func (this HumanUserAccountRole) GetProbability() *float64 { return this.Probability }
func (this HumanUserAccountRole) GetType() EntityRoleType  { return this.Type }

func (HumanUserAccountRole) IsEntityRole() {}

// A malicious event or a sequence of related events that may lead or have already
// led to a significant disruption or degradation of network availability and
// security or business continuity.
type Incident struct {
	// List of all alert events contained by this incident. This is a simplified
	// version of the `timeline` field, restricting the query to alert events and
	// avoiding inner pagination.
	AlertEvents []*TimelineAlertEvent `json:"alertEvents"`
	// Comments attached to this incident.
	Comments []*IncidentComment `json:"comments"`
	// Consolidated list of entities which are considered compromised in the context
	// of this incident. The list items are sorted by importance in descending order.
	CompromisedEntities []Entity `json:"compromisedEntities"`
	// The incident end time.
	EndTime string `json:"endTime"`
	// The incident unique identifier. This identifier can be later used to refetch the incident using the `incident` API.
	IncidentID string `json:"incidentId"`
	// The current incident life cycle stage.
	LifeCycleStage *IncidentLifeCycleStage `json:"lifeCycleStage,omitempty"`
	// If `true`, the incident is marked as read. An incident is automatically marked
	// as read once it is opened in the user interface.
	MarkedAsRead bool `json:"markedAsRead"`
	// The incident severity.
	Severity IncidentSeverity `json:"severity"`
	// The incident start time.
	StartTime string `json:"startTime"`
	// Fetches events associated with this incident. By default, only alerts (see
	// `TimelineEventAlert`) are filtered. For a broader context, list additional
	// events associated with the entities involved in this incident during its
	// lifecyles by setting `includeContextualEvents` to `true`.
	//
	// If you wish to query alert events only, you may prefer to project
	// `alertEvents`, which is a simplified, unpaginated version of this field.
	Timeline *TimelineEventConnection `json:"timeline"`
	// The incident type.
	Type IncidentType `json:"type"`
}

// Descriptor of an `Incident` comment.
type IncidentComment struct {
	// The system user who added this comment.
	Author *SystemUser `json:"author"`
	// The comment.
	Text string `json:"text"`
	// The time at which the comment was added.
	Timestamp string `json:"timestamp"`
}

// A [Relay-Compatible](https://facebook.github.io/relay/graphql/connections.htm)
// Connection type for paginating over `Incident` elements.
type IncidentConnection struct {
	// List of `Incident` edges.
	Edges []*IncidentEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// A convenience extension to the standard Relay Connection type, directly
	// exposing the `Incident` elements, which may be used *instead* of edges. It is
	// primarily useful in conjunction with `startCursor` and `endCursor`, or when
	// exploring the API interactively (e.g. in GraphiQL).
	Nodes []*Incident `json:"nodes"`
}

// A `Incident` edge in a connection.
type IncidentEdge struct {
	// Cursor pointing to this edge, to be used in standard pagination query arguments (`before`, `after`).
	Cursor string `json:"cursor"`
	// The `Incident` item at the end of this edge.
	Node *Incident `json:"node"`
}

type IncidentState struct {
	Author         *SystemUser            `json:"author,omitempty"`
	LifeCycleStage IncidentLifeCycleStage `json:"lifeCycleStage"`
	Reason         string                 `json:"reason"`
	Timestamp      string                 `json:"timestamp"`
}

type IncidentUpdateResult struct {
	ClientMutationID *string   `json:"clientMutationId,omitempty"`
	Incident         *Incident `json:"incident"`
}

type InvolvedEntitiesQueryInfo struct {
	Archived bool   `json:"archived"`
	Domains  string `json:"domains"`
	Roles    string `json:"roles"`
	Types    string `json:"types"`
}

type IPInfoList struct {
	IPList []*TrafficInspectionExclusionListInput `json:"ipList"`
	Tag    *string                                `json:"tag,omitempty"`
}

type IPList struct {
	IPList []string `json:"ipList"`
	Tag    *string  `json:"tag,omitempty"`
}

type IPStatusOutput struct {
	IP       string                                  `json:"ip"`
	Port     *int                                    `json:"port,omitempty"`
	Protocol *TrafficInspectionExclusionListProtocol `json:"protocol,omitempty"`
	Status   TrafficInspectionExclusionListStatus    `json:"status"`
}

// A specialized `ErrorDetails` type for Kerberos activities.
type KerberosErrorDetails struct {
	// The standard Kerberos error code associated with the error.
	KrbError KrbErrCode `json:"krbError"`
	// A human-readable error message describing an error or failure.
	Message string `json:"message"`
	// The extended Microsoft-specific error code associated with the error, if any.
	MsSpecificError *ApplicationSpecificError `json:"msSpecificError,omitempty"`
}

func (KerberosErrorDetails) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this KerberosErrorDetails) GetMessage() string { return this.Message }

type KeyCredentialAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (KeyCredentialAdminRole) IsEffectiveAdminRole() {}
func (this KeyCredentialAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this KeyCredentialAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this KeyCredentialAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this KeyCredentialAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this KeyCredentialAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this KeyCredentialAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this KeyCredentialAdminRole) GetFullPath() *string     { return this.FullPath }
func (this KeyCredentialAdminRole) GetProbability() *float64 { return this.Probability }
func (this KeyCredentialAdminRole) GetType() EntityRoleType  { return this.Type }

func (KeyCredentialAdminRole) IsAdminAccountRole() {}

func (KeyCredentialAdminRole) IsEntityRole() {}

type KrbtgtAccountAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (KrbtgtAccountAdminRole) IsDomainLevelAdminRole() {}
func (this KrbtgtAccountAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this KrbtgtAccountAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this KrbtgtAccountAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this KrbtgtAccountAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this KrbtgtAccountAdminRole) GetFullPath() *string     { return this.FullPath }
func (this KrbtgtAccountAdminRole) GetProbability() *float64 { return this.Probability }
func (this KrbtgtAccountAdminRole) GetType() EntityRoleType  { return this.Type }

func (KrbtgtAccountAdminRole) IsAdminAccountRole() {}

func (KrbtgtAccountAdminRole) IsEntityRole() {}

// A specialized `ErrorDetails` implementation for LDAP activities.
type LdapErrorDetails struct {
	// The LDAP operation result associated with the error.
	LdapError LdapOperationResult `json:"ldapError"`
	// A human-readable error message describing an error or failure.
	Message string `json:"message"`
}

func (LdapErrorDetails) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this LdapErrorDetails) GetMessage() string { return this.Message }

type LinkedAccountsRiskEntityFactor struct {
	RiskyLinkID string         `json:"riskyLinkId"`
	Score       string         `json:"score"`
	Severity    ScoreSeverity  `json:"severity"`
	Type        RiskFactorType `json:"type"`
}

func (LinkedAccountsRiskEntityFactor) IsEntityRiskFactor()             {}
func (this LinkedAccountsRiskEntityFactor) GetScore() string           { return this.Score }
func (this LinkedAccountsRiskEntityFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this LinkedAccountsRiskEntityFactor) GetType() RiskFactorType    { return this.Type }

// A specialized `Association` type for entity associations
type LocalAdminDomainEntityAssociation struct {
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType BindingType `json:"bindingType"`
	// The associated entity.
	Entity          Entity     `json:"entity"`
	EntityType      EntityType `json:"entityType"`
	LastDataRefresh string     `json:"lastDataRefresh"`
	LastLogin       *string    `json:"lastLogin,omitempty"`
}

func (LocalAdminDomainEntityAssociation) IsEntityAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this LocalAdminDomainEntityAssociation) GetBindingType() BindingType { return this.BindingType }

// The associated entity.
func (this LocalAdminDomainEntityAssociation) GetEntity() Entity { return this.Entity }

func (LocalAdminDomainEntityAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

// An association between two entities. The nature of the association and the specific subtype are determined by `bindingType`.
//
// **Symmetric vs. Asymmetric**: Depending on the binding type, an association can
// be symmetric or asymmetric. A symmetric association is set on both participating
// entities, each pointing to the other one. For example, the `LOGIN` association
// is symmetric. Therefore, if a user has a `LOGIN` association with an endpoint,
// the endpoint should have the same association with the user. Conversely, if a
// user has a `SERVICE_ACCESS` association with a server, the server is not
// supposed to have the same association with the user, because the
// `SERVICE_ACCESS` association is asymmetric. The documentation for `BindingType`
// specifies which binding types are symmetric and which are asymmetric.
type LocalAdminLocalUserAssociation struct {
	AccountEnabled        bool   `json:"accountEnabled"`
	AccountName           string `json:"accountName"`
	AdminsSharingPassword int    `json:"adminsSharingPassword"`
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType        BindingType `json:"bindingType"`
	LastDataRefresh    string      `json:"lastDataRefresh"`
	LastLogin          *string     `json:"lastLogin,omitempty"`
	LastPasswordChange *string     `json:"lastPasswordChange,omitempty"`
	ObjectSid          string      `json:"objectSid"`
}

func (LocalAdminLocalUserAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this LocalAdminLocalUserAssociation) GetBindingType() BindingType { return this.BindingType }

type LocalAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EndpointCount                    int            `json:"endpointCount"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (LocalAdminRole) IsAdminAccountRole() {}
func (this LocalAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this LocalAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this LocalAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this LocalAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this LocalAdminRole) GetFullPath() *string     { return this.FullPath }
func (this LocalAdminRole) GetProbability() *float64 { return this.Probability }
func (this LocalAdminRole) GetType() EntityRoleType  { return this.Type }

func (LocalAdminRole) IsEntityRole() {}

type MailboxRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (MailboxRole) IsProgrammaticUserAccountRole() {}
func (this MailboxRole) GetConfirmed() bool        { return this.Confirmed }
func (this MailboxRole) GetFullPath() *string      { return this.FullPath }
func (this MailboxRole) GetProbability() *float64  { return this.Probability }
func (this MailboxRole) GetType() EntityRoleType   { return this.Type }

func (MailboxRole) IsClassificationRole() {}

func (MailboxRole) IsEntityRole() {}

type MfaConnectorDescriptor struct {
	ConnectorType MfaConnectorType `json:"connectorType"`
	ProviderType  *string          `json:"providerType,omitempty"`
}

type MfaEngagementSummary struct {
	Authorized          bool                    `json:"authorized"`
	AuthorizerID        *string                 `json:"authorizerId,omitempty"`
	ConnectorDescriptor *MfaConnectorDescriptor `json:"connectorDescriptor,omitempty"`
	EngagementType      EngagementType          `json:"engagementType"`
	FactorTypeSequence  []MfaFactorType         `json:"factorTypeSequence"`
}

func (MfaEngagementSummary) IsEngagementSummary()                   {}
func (this MfaEngagementSummary) GetEngagementType() EngagementType { return this.EngagementType }

type Mutation struct {
}

type NotificationState struct {
	Dismissed      bool        `json:"dismissed"`
	LastUpdateTime string      `json:"lastUpdateTime"`
	Resolved       bool        `json:"resolved"`
	SystemUser     *SystemUser `json:"systemUser,omitempty"`
}

// A specialized `ErrorDetails` type for NTLM activities.
type NtlmErrorDetails struct {
	// If the NTLM error is part of an LDAP authentication over NTLM, this is set to
	// LDAP operation result associated with the failed LDAP authentication.
	LdapError *LdapOperationResult `json:"ldapError,omitempty"`
	// A human-readable error message describing an error or failure.
	Message string `json:"message"`
	// The NTLM error code associated with this error.
	NtlmError *NtlmErrorCode `json:"ntlmError,omitempty"`
}

func (NtlmErrorDetails) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this NtlmErrorDetails) GetMessage() string { return this.Message }

type NtlmMovementRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (NtlmMovementRole) IsClassificationRole()         {}
func (this NtlmMovementRole) GetConfirmed() bool       { return this.Confirmed }
func (this NtlmMovementRole) GetFullPath() *string     { return this.FullPath }
func (this NtlmMovementRole) GetProbability() *float64 { return this.Probability }
func (this NtlmMovementRole) GetType() EntityRoleType  { return this.Type }

func (NtlmMovementRole) IsEntityRole() {}

type ObjectSidTakeoverAdminRole struct {
	AffectedEntities                 []Entity                  `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string                  `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string                  `json:"authorizingGroupIds"`
	Builtin                          bool                      `json:"builtin"`
	Confirmed                        bool                      `json:"confirmed"`
	EffectedEntityIds                []string                  `json:"effectedEntityIds,omitempty"`
	FullPath                         *string                   `json:"fullPath,omitempty"`
	Probability                      *float64                  `json:"probability,omitempty"`
	Takeovers                        []*ObjectSidTakeoverEntry `json:"takeovers"`
	Type                             EntityRoleType            `json:"type"`
}

func (ObjectSidTakeoverAdminRole) IsEffectiveAdminRole() {}
func (this ObjectSidTakeoverAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ObjectSidTakeoverAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ObjectSidTakeoverAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ObjectSidTakeoverAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this ObjectSidTakeoverAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this ObjectSidTakeoverAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ObjectSidTakeoverAdminRole) GetFullPath() *string     { return this.FullPath }
func (this ObjectSidTakeoverAdminRole) GetProbability() *float64 { return this.Probability }
func (this ObjectSidTakeoverAdminRole) GetType() EntityRoleType  { return this.Type }

func (ObjectSidTakeoverAdminRole) IsAdminAccountRole() {}

func (ObjectSidTakeoverAdminRole) IsEntityRole() {}

type ObjectSidTakeoverEntry struct {
	Entity     Entity                  `json:"entity,omitempty"`
	Method     ObjectSidTakeoverMethod `json:"method"`
	ObjectSid  string                  `json:"objectSid"`
	Privileges []EntityRoleType        `json:"privileges"`
}

type OperatingSystemInfo struct {
	DisplayName   string                       `json:"displayName"`
	Family        OperatingSystemFamily        `json:"family"`
	Name          string                       `json:"name"`
	ServicePack   *string                      `json:"servicePack,omitempty"`
	Target        OperatingSystemTarget        `json:"target"`
	Version       *string                      `json:"version,omitempty"`
	Vulnerability OperatingSystemVulnerability `json:"vulnerability"`
}

// An `EntityAssociation` in which the associated party is an entity bound by origin (see `BindingType`).
type OriginAssociation struct {
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType BindingType `json:"bindingType"`
	// The associated entity.
	Entity Entity `json:"entity"`
}

func (OriginAssociation) IsEntityAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this OriginAssociation) GetBindingType() BindingType { return this.BindingType }

// The associated entity.
func (this OriginAssociation) GetEntity() Entity { return this.Entity }

func (OriginAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

type OwnerAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (OwnerAdminRole) IsEffectiveAdminRole() {}
func (this OwnerAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this OwnerAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this OwnerAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this OwnerAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this OwnerAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this OwnerAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this OwnerAdminRole) GetFullPath() *string     { return this.FullPath }
func (this OwnerAdminRole) GetProbability() *float64 { return this.Probability }
func (this OwnerAdminRole) GetType() EntityRoleType  { return this.Type }

func (OwnerAdminRole) IsAdminAccountRole() {}

func (OwnerAdminRole) IsEntityRole() {}

// Relay Connection pagination information.
type PageInfo struct {
	// Continuation cursor for forwards-pagination.
	EndCursor *string `json:"endCursor,omitempty"`
	// If `true` is returned, there are more items to be fetched when paginating forwards.
	HasNextPage bool `json:"hasNextPage"`
	// If `true` is returned, there are more items to be fetched when paginating backwards.
	HasPreviousPage bool `json:"hasPreviousPage"`
	// Continuation cursor for backwards-pagination.
	StartCursor *string `json:"startCursor,omitempty"`
}

type PasswordResetterAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (PasswordResetterAdminRole) IsEffectiveAdminRole() {}
func (this PasswordResetterAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PasswordResetterAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PasswordResetterAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PasswordResetterAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this PasswordResetterAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this PasswordResetterAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PasswordResetterAdminRole) GetFullPath() *string     { return this.FullPath }
func (this PasswordResetterAdminRole) GetProbability() *float64 { return this.Probability }
func (this PasswordResetterAdminRole) GetType() EntityRoleType  { return this.Type }

func (PasswordResetterAdminRole) IsAdminAccountRole() {}

func (PasswordResetterAdminRole) IsEntityRole() {}

type Permission struct {
	AuthorizingGroupIds       []string `json:"authorizingGroupIds"`
	CaEndpointIds             []string `json:"caEndpointIds"`
	CertificateAuthorityNames []string `json:"certificateAuthorityNames"`
	PermissionName            string   `json:"permissionName"`
	TemplateNames             []string `json:"templateNames"`
}

type PermissionsControllerAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (PermissionsControllerAdminRole) IsEffectiveAdminRole() {}
func (this PermissionsControllerAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PermissionsControllerAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PermissionsControllerAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PermissionsControllerAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this PermissionsControllerAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this PermissionsControllerAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PermissionsControllerAdminRole) GetFullPath() *string     { return this.FullPath }
func (this PermissionsControllerAdminRole) GetProbability() *float64 { return this.Probability }
func (this PermissionsControllerAdminRole) GetType() EntityRoleType  { return this.Type }

func (PermissionsControllerAdminRole) IsAdminAccountRole() {}

func (PermissionsControllerAdminRole) IsEntityRole() {}

type PolicyQueryInput struct {
	EnforcedExternally  *bool                            `json:"enforcedExternally,omitempty"`
	MfaResults          []EngagementAuthenticationStatus `json:"mfaResults,omitempty"`
	RuleActions         []RuleAction                     `json:"ruleActions,omitempty"`
	RuleIds             []string                         `json:"ruleIds,omitempty"`
	VerificationResults []EngagementAuthenticationStatus `json:"verificationResults,omitempty"`
}

type PrintOperatorsAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (PrintOperatorsAdminRole) IsOperatorLevelAdminRole() {}
func (this PrintOperatorsAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrintOperatorsAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrintOperatorsAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this PrintOperatorsAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this PrintOperatorsAdminRole) GetFullPath() *string     { return this.FullPath }
func (this PrintOperatorsAdminRole) GetProbability() *float64 { return this.Probability }
func (this PrintOperatorsAdminRole) GetType() EntityRoleType  { return this.Type }

func (PrintOperatorsAdminRole) IsAdminAccountRole() {}

func (PrintOperatorsAdminRole) IsEntityRole() {}

type PrivilegedGroupControllerAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (PrivilegedGroupControllerAdminRole) IsEffectiveAdminRole() {}
func (this PrivilegedGroupControllerAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivilegedGroupControllerAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivilegedGroupControllerAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivilegedGroupControllerAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this PrivilegedGroupControllerAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this PrivilegedGroupControllerAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivilegedGroupControllerAdminRole) GetFullPath() *string     { return this.FullPath }
func (this PrivilegedGroupControllerAdminRole) GetProbability() *float64 { return this.Probability }
func (this PrivilegedGroupControllerAdminRole) GetType() EntityRoleType  { return this.Type }

func (PrivilegedGroupControllerAdminRole) IsAdminAccountRole() {}

func (PrivilegedGroupControllerAdminRole) IsEntityRole() {}

type ProgrammaticUserAccountRoleImpl struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (ProgrammaticUserAccountRoleImpl) IsProgrammaticUserAccountRole() {}
func (this ProgrammaticUserAccountRoleImpl) GetConfirmed() bool        { return this.Confirmed }
func (this ProgrammaticUserAccountRoleImpl) GetFullPath() *string      { return this.FullPath }
func (this ProgrammaticUserAccountRoleImpl) GetProbability() *float64  { return this.Probability }
func (this ProgrammaticUserAccountRoleImpl) GetType() EntityRoleType   { return this.Type }

func (ProgrammaticUserAccountRoleImpl) IsClassificationRole() {}

func (ProgrammaticUserAccountRoleImpl) IsEntityRole() {}

type Query struct {
}

// Description of Azure RBAC role definition.
type RbacRoleDescriptor struct {
	// Role name
	DisplayName string `json:"displayName"`
	// Role Azure id
	RoleID string `json:"roleId"`
}

// Description of Azure subscription.
type RbacSubscriptionDescriptor struct {
	// Subscription name
	DisplayName string `json:"displayName"`
	// Subscription Azure id
	SubscriptionID string `json:"subscriptionId"`
}

type ReadOnlyDomainControllersAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (ReadOnlyDomainControllersAdminRole) IsDomainControllersAdminRole() {}
func (this ReadOnlyDomainControllersAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ReadOnlyDomainControllersAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ReadOnlyDomainControllersAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this ReadOnlyDomainControllersAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this ReadOnlyDomainControllersAdminRole) GetFullPath() *string     { return this.FullPath }
func (this ReadOnlyDomainControllersAdminRole) GetProbability() *float64 { return this.Probability }
func (this ReadOnlyDomainControllersAdminRole) GetType() EntityRoleType  { return this.Type }

func (ReadOnlyDomainControllersAdminRole) IsDomainLevelAdminRole() {}

func (ReadOnlyDomainControllersAdminRole) IsAdminAccountRole() {}

func (ReadOnlyDomainControllersAdminRole) IsEntityRole() {}

// A specialized `Association` type for entity associations
type RecentlyVerifiedLoginBindingAssociation struct {
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType BindingType `json:"bindingType"`
	// The associated entity.
	Entity           Entity `json:"entity"`
	Simulated        bool   `json:"simulated"`
	VerificationTime string `json:"verificationTime"`
}

func (RecentlyVerifiedLoginBindingAssociation) IsSimulatableAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this RecentlyVerifiedLoginBindingAssociation) GetBindingType() BindingType {
	return this.BindingType
}

// The associated entity.
func (this RecentlyVerifiedLoginBindingAssociation) GetEntity() Entity  { return this.Entity }
func (this RecentlyVerifiedLoginBindingAssociation) GetSimulated() bool { return this.Simulated }

func (RecentlyVerifiedLoginBindingAssociation) IsEntityAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

// The associated entity.

func (RecentlyVerifiedLoginBindingAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

type RemoveUserEntityAuthorizerInput struct {
	AuthorizerEntityQuery *EntityQueryInput `json:"authorizerEntityQuery"`
	ClientMutationID      *string           `json:"clientMutationId,omitempty"`
	EntityQuery           *EntityQueryInput `json:"entityQuery"`
}

type ReplicatorsAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (ReplicatorsAdminRole) IsOperatorLevelAdminRole() {}
func (this ReplicatorsAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ReplicatorsAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ReplicatorsAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this ReplicatorsAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this ReplicatorsAdminRole) GetFullPath() *string     { return this.FullPath }
func (this ReplicatorsAdminRole) GetProbability() *float64 { return this.Probability }
func (this ReplicatorsAdminRole) GetType() EntityRoleType  { return this.Type }

func (ReplicatorsAdminRole) IsAdminAccountRole() {}

func (ReplicatorsAdminRole) IsEntityRole() {}

// A descriptor for the overall risk associated with a group of entities in an
// Active Directory domain. In this context, *group* does not imply an Active
// Directory group, but a logical group of entities of various membership types
// (see `EntityMembershipType`)
type RiskByMembershipResult struct {
	// The Active Directory domain name.
	Domain string `json:"domain"`
	// The group name
	Group string `json:"group"`
	// The number of entities in the group.
	GroupSize int `json:"groupSize"`
	// The overall impact score associated with the group.
	Impact string `json:"impact"`
	// The group type.
	MembershipType EntityMembershipType `json:"membershipType"`
	// Breakdown of score severities by their contribution to the overall risk score of this group.
	RiskContributionBreakdown *ScoreSeverityBreakdown `json:"riskContributionBreakdown,omitempty"`
	// Breakdown of score severities by the percentage of members associated with each severity.
	RiskDistribution *ScoreSeverityBreakdown `json:"riskDistribution,omitempty"`
	// The risk factors associated with this group.
	RiskFactors []*RiskFactorContribution `json:"riskFactors"`
	// The overall risk score associated with this group.
	Score string `json:"score"`
}

// A [Relay-Compatible](https://facebook.github.io/relay/graphql/connections.htm)
// Connection type for paginating over `RiskByMembershipResult` elements.
type RiskByMembershipResultConnection struct {
	// List of `RiskByMembershipResult` edges.
	Edges []*RiskByMembershipResultEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// A convenience extension to the standard Relay Connection type, directly
	// exposing the `RiskByMembershipResult` elements, which may be used *instead* of
	// edges. It is primarily useful in conjunction with `startCursor` and
	// `endCursor`, or when exploring the API interactively (e.g. in GraphiQL).
	Nodes []*RiskByMembershipResult `json:"nodes"`
}

// A `RiskByMembershipResult` edge in a connection.
type RiskByMembershipResultEdge struct {
	// Cursor pointing to this edge, to be used in standard pagination query arguments (`before`, `after`).
	Cursor string `json:"cursor"`
	// The `RiskByMembershipResult` item at the end of this edge.
	Node *RiskByMembershipResult `json:"node"`
}

// Risk factor contribution descriptor.
type RiskFactorContribution struct {
	// The severity value assigned to the risk factor type.
	Severity ScoreSeverity `json:"severity"`
	// The risk factor type.
	Type RiskFactorType `json:"type"`
}

// Query criteria for role assignment association. All specific criteria must be met for a result to match.
type RoleAssignmentAssociationQuery struct {
	// The query is a match if the role display names match
	RoleDisplayNames []string `json:"roleDisplayNames,omitempty"`
	// The query is a match if the role ids match
	RoleIds []string `json:"roleIds,omitempty"`
	// The query is a match if the scope display names match
	ScopeDisplayNames []string `json:"scopeDisplayNames,omitempty"`
	// The query is a match if the scope ids match
	ScopeIds []string `json:"scopeIds,omitempty"`
}

type SchemaAdminsRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (SchemaAdminsRole) IsForestLevelAdminRole() {}
func (this SchemaAdminsRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SchemaAdminsRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SchemaAdminsRole) GetBuiltin() bool         { return this.Builtin }
func (this SchemaAdminsRole) GetConfirmed() bool       { return this.Confirmed }
func (this SchemaAdminsRole) GetFullPath() *string     { return this.FullPath }
func (this SchemaAdminsRole) GetProbability() *float64 { return this.Probability }
func (this SchemaAdminsRole) GetType() EntityRoleType  { return this.Type }

func (SchemaAdminsRole) IsAdminAccountRole() {}

func (SchemaAdminsRole) IsEntityRole() {}

type ScoreSeverityBreakdown struct {
	Normal *string `json:"NORMAL,omitempty"`
	Medium *string `json:"MEDIUM,omitempty"`
	High   *string `json:"HIGH,omitempty"`
}

// The *SecurityAssessment* data type holds data about a set of domain-level
// security risk factors, along with an overall score for these factors.
//
// ### Examples
//
// ```graphql
// #### Get the the latest security assessment
//
//	{
//	    securityAssessment(domain: "DOMAIN.TLD") # fill your domain here
//	    {
//	        overallScore
//	        overallScoreLevel
//	        assessmentFactors
//	        {
//	            riskFactorType
//	            likelihood
//	            severity
//	        }
//	    }
//	}
//
// ```
// ```graphql
// #### Get security assessment past data
//
//	{
//	    # Last week's security assessment history, in daily resolution
//	    securityAssessmentHistory(domain: "DOMAIN.TLD" # fill your domain here
//	        first: 7
//	        startTime: "P-1W" # Or some ISO-8601 Date (see DateTimeInput documentation)
//	        timeResolution: DAY)
//	    {
//	        nodes
//	        {
//	            securityAssessment
//	            {
//	                overallScore
//	                overallScoreLevel
//	                assessmentFactors
//	                {
//	                    riskFactorType
//	                    likelihood
//	                    severity
//	                    lastUpdateTime
//	                }
//	            }
//	        }
//	    }
//	}
//
// ```
// ```graphql
// #### Utilizing security assessment goals
//
//	{
//	    securityAssessmentGoals
//	    {
//	        name
//	        goalId
//	    }
//
//
//	    # These goals can be used for restrict the assessed factors in both current and historical data APIs
//	    # To see the results, please fill the domain query argument
//	    pumCurrent:
//	    securityAssessment(domain: "DOMAIN.TLD" # fill your domain here
//	        goalIds: ["a48477ba-c645-4d7d-ad3a-b33ed488e03f"]) {
//	        overallScore
//	        overallScoreLevel
//	        assessmentFactors
//	        {
//	            riskFactorType
//	        }
//	    }
//
//	    penTetstingHistory:
//	    securityAssessmentHistory(domain: "DOMAIN.TLD" # fill your domain here
//	        goalIds: ["c9d1c1a3-0b95-4235-97d9-f12a748e5fa6"]
//	        first: 7
//	        startTime: "P-7D"
//	        timeResolution: DAY)
//	    {
//	        nodes
//	        {
//	            securityAssessment
//	            {
//	                overallScore
//	                overallScoreLevel
//	                assessmentFactors
//	                {
//	                    riskFactorType
//	                    lastUpdateTime
//	                }
//	            }
//	        }
//	    }
//	}
//
// ```
type SecurityAssessment struct {
	// List of risk factors matching the query criteria.
	AssessmentFactors []*SecurityAssessmentFactor `json:"assessmentFactors"`
	Domain            *string                     `json:"domain,omitempty"`
	// The overall security score for the given `assessmentFactors`, as a number between 0 (no risk) to 1 (maximum risk).
	OverallScore string `json:"overallScore"`
	// The overall security score level for the given `assessmentFactors`.
	OverallScoreLevel ScoreLevel `json:"overallScoreLevel"`
	Tenant            *string    `json:"tenant,omitempty"`
}

type SecurityAssessmentFactor struct {
	// Human-readable description for the risk
	Description string `json:"description"`
	// The domain associated with the risk factor.
	Domain *string `json:"domain,omitempty"`
	// Human-readable label for the risk factor
	Label string `json:"label"`
	// The time when the information about the risk factor was last updated.
	LastUpdateTime string `json:"lastUpdateTime"`
	// The risk factor likelihood level.
	Likelihood ScoreLevel `json:"likelihood"`
	// The actions recommended in order to reduce or neutralize the risk.
	Recommendations []*SecurityAssessmentFactorRecommendation `json:"recommendations"`
	// The risk factor type.
	RiskFactorType RiskFactorType `json:"riskFactorType"`
	// The risk factor score level, taking into account both its severity and its likelihood.
	ScoreLevel ScoreLevel `json:"scoreLevel"`
	// The risk factor severity level.
	Severity ScoreLevel `json:"severity"`
	Tenant   *string    `json:"tenant,omitempty"`
}

// The actions recommended in order to reduce or neutralize the risk.
type SecurityAssessmentFactorRecommendation struct {
	// The link to the detailed recommendations.
	Link *string `json:"link,omitempty"`
	// A detailed description of the actions recommended in order to reduce or neutralize the risk.
	Text string `json:"text"`
}

// A goal associated with a `SecurityAssessment` result.
//
// ```graphql
// #### Utilizing security assessment goals
//
//	{
//	    securityAssessmentGoals
//	    {
//	        name
//	        goalId
//	    }
//
//
//	    # These goals can be used for restrict the assessed factors in both current and historical data APIs
//	    # To see the results, please fill the domain query argument
//	    pumCurrent:
//	    securityAssessment(domain: "DOMAIN.TLD" # fill your domain here
//	        goalIds: ["a48477ba-c645-4d7d-ad3a-b33ed488e03f"]) {
//	        overallScore
//	        overallScoreLevel
//	        assessmentFactors
//	        {
//	            riskFactorType
//	        }
//	    }
//
//	    penTetstingHistory:
//	    securityAssessmentHistory(domain: "DOMAIN.TLD" # fill your domain here
//	        goalIds: ["c9d1c1a3-0b95-4235-97d9-f12a748e5fa6"]
//	        first: 7
//	        startTime: "P-7D"
//	        timeResolution: DAY)
//	    {
//	        nodes
//	        {
//	            securityAssessment
//	            {
//	                overallScore
//	                overallScoreLevel
//	                assessmentFactors
//	                {
//	                    riskFactorType
//	                    lastUpdateTime
//	                }
//	            }
//	        }
//	    }
//	}
//
// ```
type SecurityAssessmentGoal struct {
	// The goal unique identifier, which can then be used for querying ```securityAssessment```.
	GoalID string `json:"goalId"`
	// The goal name.
	Name string `json:"name"`
}

// Analyzing results of previous security assessments enables you to see the
// general direction of changes in the risk score and measure the security
// enhancement progress.
type SecurityAssessmentHistoryEntry struct {
	// The name of a previous security assessment.
	SecurityAssessment *SecurityAssessment `json:"securityAssessment"`
	// The time when a previous security assessment was performed.
	Timestamp string `json:"timestamp"`
}

// A [Relay-Compatible](https://facebook.github.io/relay/graphql/connections.htm)
// Connection type for paginating over `SecurityAssessmentHistoryEntry` elements.
type SecurityAssessmentHistoryEntryConnection struct {
	// List of `SecurityAssessmentHistoryEntry` edges.
	Edges []*SecurityAssessmentHistoryEntryEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// A convenience extension to the standard Relay Connection type, directly
	// exposing the `SecurityAssessmentHistoryEntry` elements, which may be used
	// *instead* of edges. It is primarily useful in conjunction with `startCursor`
	// and `endCursor`, or when exploring the API interactively (e.g. in GraphiQL).
	Nodes []*SecurityAssessmentHistoryEntry `json:"nodes"`
}

// A `SecurityAssessmentHistoryEntry` edge in a connection.
type SecurityAssessmentHistoryEntryEdge struct {
	// Cursor pointing to this edge, to be used in standard pagination query arguments (`before`, `after`).
	Cursor string `json:"cursor"`
	// The `SecurityAssessmentHistoryEntry` item at the end of this edge.
	Node *SecurityAssessmentHistoryEntry `json:"node"`
}

type SecurityGroupRole struct {
	Builtin     bool                      `json:"builtin"`
	Confirmed   bool                      `json:"confirmed"`
	FullPath    *string                   `json:"fullPath,omitempty"`
	Probability *float64                  `json:"probability,omitempty"`
	Scope       ActiveDirectoryGroupScope `json:"scope"`
	Type        EntityRoleType            `json:"type"`
}

func (SecurityGroupRole) IsActiveDirectoryGroupRole()              {}
func (this SecurityGroupRole) GetBuiltin() bool                    { return this.Builtin }
func (this SecurityGroupRole) GetScope() ActiveDirectoryGroupScope { return this.Scope }

func (SecurityGroupRole) IsPermissionAssignerRole() {}

func (this SecurityGroupRole) GetConfirmed() bool       { return this.Confirmed }
func (this SecurityGroupRole) GetFullPath() *string     { return this.FullPath }
func (this SecurityGroupRole) GetProbability() *float64 { return this.Probability }
func (this SecurityGroupRole) GetType() EntityRoleType  { return this.Type }

func (SecurityGroupRole) IsContainerRole() {}

func (SecurityGroupRole) IsEntityRole() {}

type ServerOperatorsAdminRole struct {
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (ServerOperatorsAdminRole) IsOperatorLevelAdminRole() {}
func (this ServerOperatorsAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ServerOperatorsAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ServerOperatorsAdminRole) GetBuiltin() bool         { return this.Builtin }
func (this ServerOperatorsAdminRole) GetConfirmed() bool       { return this.Confirmed }
func (this ServerOperatorsAdminRole) GetFullPath() *string     { return this.FullPath }
func (this ServerOperatorsAdminRole) GetProbability() *float64 { return this.Probability }
func (this ServerOperatorsAdminRole) GetType() EntityRoleType  { return this.Type }

func (ServerOperatorsAdminRole) IsAdminAccountRole() {}

func (ServerOperatorsAdminRole) IsEntityRole() {}

type ServerRoleImpl struct {
	Confirmed    bool           `json:"confirmed"`
	FullPath     *string        `json:"fullPath,omitempty"`
	Impersonator bool           `json:"impersonator"`
	Probability  *float64       `json:"probability,omitempty"`
	Type         EntityRoleType `json:"type"`
}

func (ServerRoleImpl) IsServerRole()                 {}
func (this ServerRoleImpl) GetConfirmed() bool       { return this.Confirmed }
func (this ServerRoleImpl) GetFullPath() *string     { return this.FullPath }
func (this ServerRoleImpl) GetImpersonator() bool    { return this.Impersonator }
func (this ServerRoleImpl) GetProbability() *float64 { return this.Probability }
func (this ServerRoleImpl) GetType() EntityRoleType  { return this.Type }

func (ServerRoleImpl) IsClassificationRole() {}

func (ServerRoleImpl) IsEntityRole() {}

// A specialized `Association` type for entity associations
type ServiceAssociation struct {
	// The association binding type, which also determines the specific `Association` subtype of this instance.
	BindingType BindingType `json:"bindingType"`
	// The associated entity.
	Entity         Entity   `json:"entity"`
	ServiceClasses []string `json:"serviceClasses"`
}

func (ServiceAssociation) IsEntityAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this ServiceAssociation) GetBindingType() BindingType { return this.BindingType }

// The associated entity.
func (this ServiceAssociation) GetEntity() Entity { return this.Entity }

func (ServiceAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.

type ServiceDescriptor struct {
	Entity     Entity `json:"entity,omitempty"`
	Identifier string `json:"identifier"`
}

type ServicePrincipalNameBasedRiskFactor struct {
	Score                 string         `json:"score"`
	ServicePrincipalNames []string       `json:"servicePrincipalNames"`
	Severity              ScoreSeverity  `json:"severity"`
	Type                  RiskFactorType `json:"type"`
}

func (ServicePrincipalNameBasedRiskFactor) IsEntityRiskFactor()             {}
func (this ServicePrincipalNameBasedRiskFactor) GetScore() string           { return this.Score }
func (this ServicePrincipalNameBasedRiskFactor) GetSeverity() ScoreSeverity { return this.Severity }
func (this ServicePrincipalNameBasedRiskFactor) GetType() RiskFactorType    { return this.Type }

type SetEntityLinkedAccountInput struct {
	ClientMutationID                     *string           `json:"clientMutationId,omitempty"`
	EntityQuery                          *EntityQueryInput `json:"entityQuery"`
	LinkedAccountsAssociationEntityQuery *EntityQueryInput `json:"linkedAccountsAssociationEntityQuery"`
}

// Input for `setIncidentState`.
type SetStateIncidentInput struct {
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The unique identifier of the incident to be updated (see `Incident:incidentId`).
	IncidentID string `json:"incidentId"`
	// The updated lifecycle stage.
	LifeCycleStage IncidentLifeCycleStageInput `json:"lifeCycleStage"`
	// The reason for this change.
	Reason *string `json:"reason,omitempty"`
}

// The default implementation for `ErrorDetails`.
type SimpleErrorDetails struct {
	// A human-readable error message describing an error or failure.
	Message string `json:"message"`
}

func (SimpleErrorDetails) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this SimpleErrorDetails) GetMessage() string { return this.Message }

// A specialized `ErrorDetails` type for SSO activities.
type SsoErrorDetails struct {
	// A human-readable error message describing an error or failure.
	Message string `json:"message"`
	// SSO activity result reason.
	SsoError SsoError `json:"ssoError"`
}

func (SsoErrorDetails) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this SsoErrorDetails) GetMessage() string { return this.Message }

type SsoGroupAccountDescriptorImpl struct {
	Archived                          bool                     `json:"archived"`
	ContainingGroupEntities           []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds                []string                 `json:"containingGroupIds"`
	ContainingRoleEntities            []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime                      string                   `json:"creationTime"`
	DataSource                        DataSource               `json:"dataSource"`
	DataSourceConfigurationIdentifier string                   `json:"dataSourceConfigurationIdentifier"`
	DataSourceParticipantIdentifier   string                   `json:"dataSourceParticipantIdentifier"`
	Description                       *string                  `json:"description,omitempty"`
	Enabled                           bool                     `json:"enabled"`
	FlattenedContainingGroupEntities  []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds       []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities   []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	Tenant                            *string                  `json:"tenant,omitempty"`
}

func (SsoGroupAccountDescriptorImpl) IsSsoGroupAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this SsoGroupAccountDescriptorImpl) GetArchived() bool { return this.Archived }
func (this SsoGroupAccountDescriptorImpl) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoGroupAccountDescriptorImpl) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoGroupAccountDescriptorImpl) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoGroupAccountDescriptorImpl) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this SsoGroupAccountDescriptorImpl) GetDataSource() DataSource { return this.DataSource }
func (this SsoGroupAccountDescriptorImpl) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this SsoGroupAccountDescriptorImpl) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this SsoGroupAccountDescriptorImpl) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this SsoGroupAccountDescriptorImpl) GetEnabled() bool { return this.Enabled }
func (this SsoGroupAccountDescriptorImpl) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoGroupAccountDescriptorImpl) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoGroupAccountDescriptorImpl) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoGroupAccountDescriptorImpl) GetTenant() *string { return this.Tenant }

func (SsoGroupAccountDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// An association to Azure RBAC role assignments, including role assignment inherited from groups.
type SsoRbacAssignmentAssociation struct {
	// RBAC_ASSIGNMENT
	BindingType BindingType `json:"bindingType"`
	// AZURE
	DataSource DataSource `json:"dataSource"`
	// The Azure id of the assigned roles
	RoleIds []string `json:"roleIds"`
	// The assigned roles
	Roles []*RbacRoleDescriptor `json:"roles"`
	// The assignment scope (e.g. subscription)
	Scope *RbacSubscriptionDescriptor `json:"scope,omitempty"`
	// The Azure id of the assignment scope
	ScopeID string `json:"scopeId"`
}

func (SsoRbacAssignmentAssociation) IsAssociation() {}

// The association binding type, which also determines the specific `Association` subtype of this instance.
func (this SsoRbacAssignmentAssociation) GetBindingType() BindingType { return this.BindingType }

type SsoRoleAccountDescriptorImpl struct {
	Archived                          bool       `json:"archived"`
	CreationTime                      string     `json:"creationTime"`
	DataSource                        DataSource `json:"dataSource"`
	DataSourceConfigurationIdentifier string     `json:"dataSourceConfigurationIdentifier"`
	DataSourceParticipantIdentifier   string     `json:"dataSourceParticipantIdentifier"`
	Description                       *string    `json:"description,omitempty"`
	Enabled                           bool       `json:"enabled"`
	Tenant                            *string    `json:"tenant,omitempty"`
}

func (SsoRoleAccountDescriptorImpl) IsSsoRoleAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this SsoRoleAccountDescriptorImpl) GetArchived() bool       { return this.Archived }
func (this SsoRoleAccountDescriptorImpl) GetCreationTime() string { return this.CreationTime }

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this SsoRoleAccountDescriptorImpl) GetDataSource() DataSource { return this.DataSource }
func (this SsoRoleAccountDescriptorImpl) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this SsoRoleAccountDescriptorImpl) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this SsoRoleAccountDescriptorImpl) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this SsoRoleAccountDescriptorImpl) GetEnabled() bool   { return this.Enabled }
func (this SsoRoleAccountDescriptorImpl) GetTenant() *string { return this.Tenant }

func (SsoRoleAccountDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

type SsoUserAccountDescriptorImpl struct {
	Archived                          bool                     `json:"archived"`
	ContainingEntities                []*EntityContainerEntity `json:"containingEntities"`
	ContainingGroupEntities           []*EntityContainerEntity `json:"containingGroupEntities"`
	ContainingGroupIds                []string                 `json:"containingGroupIds"`
	ContainingRoleEntities            []*EntityContainerEntity `json:"containingRoleEntities"`
	CreationTime                      string                   `json:"creationTime"`
	CredentialsDataSource             *DataSource              `json:"credentialsDataSource,omitempty"`
	DataSource                        DataSource               `json:"dataSource"`
	DataSourceConfigurationIdentifier string                   `json:"dataSourceConfigurationIdentifier"`
	DataSourceLoginIdentifier         *string                  `json:"dataSourceLoginIdentifier,omitempty"`
	DataSourceParticipantIdentifier   string                   `json:"dataSourceParticipantIdentifier"`
	Department                        *string                  `json:"department,omitempty"`
	Description                       *string                  `json:"description,omitempty"`
	Enabled                           bool                     `json:"enabled"`
	FlattenedContainingGroupEntities  []*EntityContainerEntity `json:"flattenedContainingGroupEntities"`
	FlattenedContainingGroupIds       []string                 `json:"flattenedContainingGroupIds"`
	FlattenedContainingRoleEntities   []*EntityContainerEntity `json:"flattenedContainingRoleEntities"`
	MostRecentActivity                *string                  `json:"mostRecentActivity,omitempty"`
	PasswordAttributes                PasswordAttributes       `json:"passwordAttributes,omitempty"`
	Tenant                            *string                  `json:"tenant,omitempty"`
	Title                             *string                  `json:"title,omitempty"`
}

func (SsoUserAccountDescriptorImpl) IsSsoUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.
func (this SsoUserAccountDescriptorImpl) GetArchived() bool { return this.Archived }
func (this SsoUserAccountDescriptorImpl) GetContainingEntities() []*EntityContainerEntity {
	if this.ContainingEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingEntities))
	for _, concrete := range this.ContainingEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoUserAccountDescriptorImpl) GetContainingGroupEntities() []*EntityContainerEntity {
	if this.ContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingGroupEntities))
	for _, concrete := range this.ContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoUserAccountDescriptorImpl) GetContainingGroupIds() []string {
	if this.ContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.ContainingGroupIds))
	for _, concrete := range this.ContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoUserAccountDescriptorImpl) GetContainingRoleEntities() []*EntityContainerEntity {
	if this.ContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.ContainingRoleEntities))
	for _, concrete := range this.ContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoUserAccountDescriptorImpl) GetCreationTime() string { return this.CreationTime }
func (this SsoUserAccountDescriptorImpl) GetCredentialsDataSource() *DataSource {
	return this.CredentialsDataSource
}

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.
func (this SsoUserAccountDescriptorImpl) GetDataSource() DataSource { return this.DataSource }

// The ID of the connector configuration associated with this account.
func (this SsoUserAccountDescriptorImpl) GetDataSourceConfigurationIdentifier() string {
	return this.DataSourceConfigurationIdentifier
}
func (this SsoUserAccountDescriptorImpl) GetDataSourceLoginIdentifier() *string {
	return this.DataSourceLoginIdentifier
}

// A unique identifier used by the connector to identify this account.
func (this SsoUserAccountDescriptorImpl) GetDataSourceParticipantIdentifier() string {
	return this.DataSourceParticipantIdentifier
}
func (this SsoUserAccountDescriptorImpl) GetDepartment() *string  { return this.Department }
func (this SsoUserAccountDescriptorImpl) GetDescription() *string { return this.Description }

// If `true`, the account is currently enabled; if `false`, the account no longer exists.
func (this SsoUserAccountDescriptorImpl) GetEnabled() bool { return this.Enabled }
func (this SsoUserAccountDescriptorImpl) GetFlattenedContainingGroupEntities() []*EntityContainerEntity {
	if this.FlattenedContainingGroupEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingGroupEntities))
	for _, concrete := range this.FlattenedContainingGroupEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoUserAccountDescriptorImpl) GetFlattenedContainingGroupIds() []string {
	if this.FlattenedContainingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.FlattenedContainingGroupIds))
	for _, concrete := range this.FlattenedContainingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this SsoUserAccountDescriptorImpl) GetFlattenedContainingRoleEntities() []*EntityContainerEntity {
	if this.FlattenedContainingRoleEntities == nil {
		return nil
	}
	interfaceSlice := make([]*EntityContainerEntity, 0, len(this.FlattenedContainingRoleEntities))
	for _, concrete := range this.FlattenedContainingRoleEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this SsoUserAccountDescriptorImpl) GetMostRecentActivity() *string {
	return this.MostRecentActivity
}

// Information regarding the account's password.
func (this SsoUserAccountDescriptorImpl) GetPasswordAttributes() PasswordAttributes {
	return this.PasswordAttributes
}
func (this SsoUserAccountDescriptorImpl) GetTenant() *string { return this.Tenant }
func (this SsoUserAccountDescriptorImpl) GetTitle() *string  { return this.Title }

func (SsoUserAccountDescriptorImpl) IsActivityParticipatingAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// The date and time of the account's latest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

func (SsoUserAccountDescriptorImpl) IsUserAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

func (SsoUserAccountDescriptorImpl) IsAccountDescriptor() {}

// If `true`, the account no longer exists; if `false`, the account is currently enabled.

// The data source of this account. Together with the entity type, the data
// source determines the account descriptor subtype to be used.

// If `true`, the account is currently enabled; if `false`, the account no longer exists.

// An error descriptor. This common interface contains just a human-readable error
// message. For more structural data which can be used programmatically, see the
// specialized sub-types of this interface.
type SystemLoginFailureDetails struct {
	// A human-readable error message describing an error or failure.
	Message string                   `json:"message"`
	Result  SystemLoginFailureReason `json:"result"`
}

func (SystemLoginFailureDetails) IsErrorDetails() {}

// A human-readable error message describing an error or failure.
func (this SystemLoginFailureDetails) GetMessage() string { return this.Message }

type SystemNotificationQueryInput struct {
	RuleIds []string `json:"ruleIds,omitempty"`
}

// The descriptor of a system user.
type SystemUser struct {
	// The system user display name. `Entity:primaryDisplayName` is used if the user is associated with an entity.
	DisplayName string `json:"displayName"`
	// The system user type.
	Type SystemUserType `json:"type"`
	// The user entity associated with the system user, if any.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

// A `timeline` event indicating the creation of an account in some data source (see `Entity:accounts`).
type TimelineAccountCreatedEvent struct {
	// A descriptor of the new account
	AccountDescriptor AccountDescriptor `json:"accountDescriptor"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAccountCreatedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAccountCreatedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAccountCreatedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAccountCreatedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAccountCreatedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAccountCreatedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAccountCreatedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineAccountCreatedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAccountCreatedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAccountCreatedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAccountCreatedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineAccountDisabledEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAccountDisabledEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAccountDisabledEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAccountDisabledEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAccountDisabledEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAccountDisabledEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAccountDisabledEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAccountDisabledEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineAccountDisabledEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAccountDisabledEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAccountDisabledEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAccountDisabledEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineAccountEnabledEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAccountEnabledEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAccountEnabledEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAccountEnabledEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAccountEnabledEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAccountEnabledEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAccountEnabledEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAccountEnabledEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineAccountEnabledEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAccountEnabledEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAccountEnabledEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAccountEnabledEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineAccountLockedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAccountLockedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAccountLockedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAccountLockedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAccountLockedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAccountLockedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAccountLockedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAccountLockedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineAccountLockedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAccountLockedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAccountLockedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAccountLockedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a primary account name change of an `Entity`. The
// field used as the account name depends on the account type (see
// `AccountDescriptor` subtypes). For Active Directory accounts,
// `ActiveDirectoryAccountDescriptor:samAccountName` is used.
type TimelineAccountNameChangeEvent struct {
	// The primary account name associated with the entity following the event.
	CurrentName string `json:"currentName"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The primary account name associated with the entity prior to the event.
	PreviousName string `json:"previousName"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAccountNameChangeEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAccountNameChangeEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAccountNameChangeEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAccountNameChangeEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAccountNameChangeEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAccountNameChangeEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAccountNameChangeEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineAccountNameChangeEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAccountNameChangeEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAccountNameChangeEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAccountNameChangeEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineAccountUnlockedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAccountUnlockedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAccountUnlockedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAccountUnlockedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAccountUnlockedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAccountUnlockedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAccountUnlockedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAccountUnlockedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineAccountUnlockedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAccountUnlockedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAccountUnlockedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAccountUnlockedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a new `Incident` alert.
//
// Unlike most timeline events, this event is continuous. That is to say, the
// `endTime` may differ significantly from the `startTime`, which is the value used
// for sorting the events in timeline queries.
type TimelineAlertEvent struct {
	// A unique identifier of the alert.
	AlertID string `json:"alertId"`
	// The alert type.
	AlertType AlertType `json:"alertType"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The single endpoint entity associated with the alert, if any. This is set to
	// `null` if multiple endpoints are associated with the alert, of if no endpoint
	// is associated with it at all. For a list of all entities involved in the
	// alert, project the `Entities` field.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A list of all entities associated with this alert.
	Entities []Entity `json:"entities"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The containing incident of the alert.
	Incident  *Incident `json:"incident"`
	PatternID int       `json:"patternId"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// `True` is returned if the alert is resolved.
	Resolved     bool                 `json:"resolved"`
	SourceEntity UserOrEndpointEntity `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string         `json:"startTime"`
	State     *IncidentState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
	// The single user entity associated with the alert, if any. This is set to
	// `null` if multiple users are associated with the alert, of if no user is
	// associated with it at all. For a list of all entities involved in the alert,
	// project the `Entities` field.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineAlertEvent) IsTimelineIncidentLifeCycleEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAlertEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAlertEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAlertEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAlertEvent) GetEventSeverity() TimelineEventSeverity { return this.EventSeverity }

// The event type.
func (this TimelineAlertEvent) GetEventType() TimelineEventType { return this.EventType }

// The containing incident of the alert.
func (this TimelineAlertEvent) GetIncident() *Incident { return this.Incident }

// A connection of related events.
func (this TimelineAlertEvent) GetRelatedEvents() *TimelineEventConnection { return this.RelatedEvents }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAlertEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAlertEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAlertEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineAlertExceptionModifiedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	PatternID int               `json:"patternId"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAlertExceptionModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAlertExceptionModifiedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAlertExceptionModifiedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAlertExceptionModifiedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAlertExceptionModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAlertExceptionModifiedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineAlertExceptionModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAlertExceptionModifiedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineAlertExceptionModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineAlertExceptionModifiedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAlertExceptionModifiedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAlertExceptionModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineAlertExceptionModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineAuthorizerChangeNotificationEvent struct {
	AddedAuthorizers  []Entity    `json:"addedAuthorizers"`
	CurrentAuthorizer *UserEntity `json:"currentAuthorizer,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType          TimelineEventType `json:"eventType"`
	PreviousAuthorizer *UserEntity       `json:"previousAuthorizer,omitempty"`
	// A connection of related events.
	RelatedEvents      *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RemovedAuthorizers []Entity                 `json:"removedAuthorizers"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineAuthorizerChangeNotificationEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineAuthorizerChangeNotificationEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineAuthorizerChangeNotificationEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineAuthorizerChangeNotificationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineAuthorizerChangeNotificationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineAuthorizerChangeNotificationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineAuthorizerChangeNotificationEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineAuthorizerChangeNotificationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineAuthorizerChangeNotificationEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineAuthorizerChangeNotificationEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineAuthorizerChangeNotificationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineConnectorConfigurationAddedEvent struct {
	Category string `json:"category"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
	Type      string `json:"type"`
}

func (TimelineConnectorConfigurationAddedEvent) IsTimelineConnectorConfigurationEvent() {}
func (this TimelineConnectorConfigurationAddedEvent) GetCategory() string               { return this.Category }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineConnectorConfigurationAddedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineConnectorConfigurationAddedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineConnectorConfigurationAddedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineConnectorConfigurationAddedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineConnectorConfigurationAddedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineConnectorConfigurationAddedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineConnectorConfigurationAddedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineConnectorConfigurationAddedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineConnectorConfigurationAddedEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineConnectorConfigurationAddedEvent) GetTimestamp() string { return this.Timestamp }
func (this TimelineConnectorConfigurationAddedEvent) GetType() string      { return this.Type }

func (TimelineConnectorConfigurationAddedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorConfigurationAddedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorConfigurationAddedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineConnectorConfigurationDeletedEvent struct {
	Category string `json:"category"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
	Type      string `json:"type"`
}

func (TimelineConnectorConfigurationDeletedEvent) IsTimelineConnectorConfigurationEvent() {}
func (this TimelineConnectorConfigurationDeletedEvent) GetCategory() string               { return this.Category }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineConnectorConfigurationDeletedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineConnectorConfigurationDeletedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineConnectorConfigurationDeletedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineConnectorConfigurationDeletedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineConnectorConfigurationDeletedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineConnectorConfigurationDeletedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineConnectorConfigurationDeletedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineConnectorConfigurationDeletedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineConnectorConfigurationDeletedEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineConnectorConfigurationDeletedEvent) GetTimestamp() string { return this.Timestamp }
func (this TimelineConnectorConfigurationDeletedEvent) GetType() string      { return this.Type }

func (TimelineConnectorConfigurationDeletedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorConfigurationDeletedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorConfigurationDeletedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineConnectorConfigurationModifiedEvent struct {
	Category string `json:"category"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
	Type      string `json:"type"`
}

func (TimelineConnectorConfigurationModifiedEvent) IsTimelineConnectorConfigurationEvent() {}
func (this TimelineConnectorConfigurationModifiedEvent) GetCategory() string               { return this.Category }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineConnectorConfigurationModifiedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineConnectorConfigurationModifiedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineConnectorConfigurationModifiedEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineConnectorConfigurationModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineConnectorConfigurationModifiedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineConnectorConfigurationModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineConnectorConfigurationModifiedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineConnectorConfigurationModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineConnectorConfigurationModifiedEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineConnectorConfigurationModifiedEvent) GetTimestamp() string { return this.Timestamp }
func (this TimelineConnectorConfigurationModifiedEvent) GetType() string      { return this.Type }

func (TimelineConnectorConfigurationModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorConfigurationModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorConfigurationModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `TimelineEvent` interface common to system notification `timeline` events.
type TimelineConnectorFailureEvent struct {
	ConnectorStatus ConnectorStatus `json:"connectorStatus"`
	ConnectorType   string          `json:"connectorType"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// Information regarding the error.
	ErrorDetails ErrorDetails `json:"errorDetails"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType    TimelineEventType `json:"eventType"`
	ProviderType *string           `json:"providerType,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineConnectorFailureEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineConnectorFailureEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineConnectorFailureEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineConnectorFailureEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineConnectorFailureEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineConnectorFailureEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineConnectorFailureEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineConnectorFailureEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineConnectorFailureEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineConnectorFailureEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineConnectorFailureEvent) IsTimelineErrorEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// Information regarding the error.
func (this TimelineConnectorFailureEvent) GetErrorDetails() ErrorDetails { return this.ErrorDetails }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineConnectorFailureEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event type indicating a [DCE/RPC](http://www.dcerpc.org/) activity associated with a particular signature.
type TimelineDceRPCEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string      `json:"activeDirectorySiteName,omitempty"`
	BrowserInfo             *BrowserInfo `json:"browserInfo,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	// The DCE-RPC activity signature.
	DcerpcSignature DcerpcSignature `json:"dcerpcSignature"`
	DeviceName      *string         `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	LdapSecurityType     *LdapSecurityType  `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	SourceEntity  UserOrEndpointEntity     `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineDceRPCEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineDceRPCEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}
func (this TimelineDceRPCEvent) GetBrowserInfo() *BrowserInfo { return this.BrowserInfo }

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineDceRPCEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineDceRPCEvent) GetDataSourceVendorName() *string { return this.DataSourceVendorName }
func (this TimelineDceRPCEvent) GetDeviceName() *string           { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineDceRPCEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineDceRPCEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineDceRPCEvent) GetEndpointDisplayName() *string { return this.EndpointDisplayName }

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineDceRPCEvent) GetEndpointEntity() *EndpointEntity { return this.EndpointEntity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineDceRPCEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineDceRPCEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineDceRPCEvent) GetEventSeverity() TimelineEventSeverity { return this.EventSeverity }

// The event type.
func (this TimelineDceRPCEvent) GetEventType() TimelineEventType { return this.EventType }

// The geolocation associated with the activity, if any.
func (this TimelineDceRPCEvent) GetGeoLocation() *GeoLocation { return this.GeoLocation }

// The origin endpoint host name.
func (this TimelineDceRPCEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineDceRPCEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineDceRPCEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineDceRPCEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineDceRPCEvent) GetIspDomain() *string                  { return this.IspDomain }
func (this TimelineDceRPCEvent) GetLdapSecurityType() *LdapSecurityType { return this.LdapSecurityType }

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineDceRPCEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineDceRPCEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineDceRPCEvent) GetNetworkType() NetworkType { return this.NetworkType }

// Information about the origin endpoint operating system.
func (this TimelineDceRPCEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineDceRPCEvent) GetProtocolType() ProtocolType { return this.ProtocolType }
func (this TimelineDceRPCEvent) GetProtocolVersion() *string   { return this.ProtocolVersion }

// A connection of related events.
func (this TimelineDceRPCEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineDceRPCEvent) GetSourceEntity() UserOrEndpointEntity { return this.SourceEntity }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineDceRPCEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineDceRPCEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineDceRPCEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineDceRPCEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineDceRPCEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineDceRPCEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineDceRPCEvent) GetTargetServiceType() *ServiceType { return this.TargetServiceType }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineDceRPCEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineDceRPCEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineDceRPCEvent) GetUserDisplayName() string { return this.UserDisplayName }

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineDceRPCEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineDceRPCEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a change in the `Department` field of an entity's primary account.
type TimelineDepartmentChangeEvent struct {
	// The department associated with the primary account of the entity after the event.
	CurrentDepartment *string `json:"currentDepartment,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The department associated with the primary account of the entity prior to the event.
	PreviousDepartment *string `json:"previousDepartment,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineDepartmentChangeEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineDepartmentChangeEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineDepartmentChangeEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineDepartmentChangeEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineDepartmentChangeEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineDepartmentChangeEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineDepartmentChangeEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineDepartmentChangeEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineDepartmentChangeEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineDepartmentChangeEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineDepartmentChangeEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineDetectionAggressionConfigurationModifiedEvent struct {
	CurrentAggressionLevel *AggressionLevel `json:"currentAggressionLevel,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType               TimelineEventType `json:"eventType"`
	PreviousAggressionLevel *AggressionLevel  `json:"previousAggressionLevel,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineDetectionAggressionConfigurationModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetEndTime() string {
	return this.EndTime
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetEventID() string {
	return this.EventID
}

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetStartTime() string {
	return this.StartTime
}
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineDetectionAggressionConfigurationModifiedEvent) GetTimestamp() string {
	return this.Timestamp
}

func (TimelineDetectionAggressionConfigurationModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineDetectionAggressionConfigurationModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `TimelineEvent` interface common to system notification `timeline` events.
type TimelineDomainRemovalEvent struct {
	Domain string `json:"domain"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineDomainRemovalEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineDomainRemovalEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineDomainRemovalEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineDomainRemovalEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineDomainRemovalEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineDomainRemovalEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineDomainRemovalEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineDomainRemovalEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineDomainRemovalEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineDomainRemovalEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineDomainRemovalEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a change in a user's `UserEntity:emailAddresses` list.
type TimelineEmailAddressChangeEvent struct {
	// The list of email addresses associated with the entity after the event.
	CurrentEmailAddresses []string `json:"currentEmailAddresses"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The list of email addresses associated with the entity prior to the event.
	PreviousEmailAddresses []string `json:"previousEmailAddresses"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEmailAddressChangeEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEmailAddressChangeEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEmailAddressChangeEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEmailAddressChangeEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEmailAddressChangeEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEmailAddressChangeEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEmailAddressChangeEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEmailAddressChangeEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEmailAddressChangeEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEmailAddressChangeEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEmailAddressChangeEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineEmailNotificationConfigurationModifiedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEmailNotificationConfigurationModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetEndTime() string {
	return this.EndTime
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetEventID() string {
	return this.EventID
}

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetStartTime() string {
	return this.StartTime
}
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEmailNotificationConfigurationModifiedEvent) GetTimestamp() string {
	return this.Timestamp
}

func (TimelineEmailNotificationConfigurationModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineEmailNotificationConfigurationModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityArchivedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityArchivedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityArchivedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityArchivedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityArchivedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityArchivedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityArchivedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityArchivedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityArchivedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityArchivedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityArchivedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityArchivedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityInactiveEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType          TimelineEventType `json:"eventType"`
	MostRecentActivity *string           `json:"mostRecentActivity,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityInactiveEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityInactiveEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityInactiveEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityInactiveEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityInactiveEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityInactiveEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityInactiveEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityInactiveEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityInactiveEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityInactiveEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityInactiveEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityLearnedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityLearnedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityLearnedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityLearnedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityLearnedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityLearnedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityLearnedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityLearnedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityLearnedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityLearnedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityLearnedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityLearnedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityMarkedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityMarkedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityMarkedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityMarkedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityMarkedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityMarkedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityMarkedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityMarkedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityMarkedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityMarkedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityMarkedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityMarkedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityNotSharedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityNotSharedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityNotSharedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityNotSharedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityNotSharedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityNotSharedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityNotSharedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityNotSharedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityNotSharedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityNotSharedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityNotSharedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityNotSharedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityResurgenceEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType          TimelineEventType `json:"eventType"`
	MostRecentActivity *string           `json:"mostRecentActivity,omitempty"`
	PrecedingActivity  *string           `json:"precedingActivity,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityResurgenceEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityResurgenceEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityResurgenceEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityResurgenceEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityResurgenceEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityResurgenceEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityResurgenceEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityResurgenceEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityResurgenceEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityResurgenceEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityResurgenceEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntitySharedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntitySharedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntitySharedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntitySharedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntitySharedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntitySharedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntitySharedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntitySharedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntitySharedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntitySharedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntitySharedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntitySharedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityStaleEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType          TimelineEventType `json:"eventType"`
	MostRecentActivity *string           `json:"mostRecentActivity,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityStaleEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityStaleEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityStaleEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityStaleEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityStaleEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityStaleEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityStaleEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityStaleEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityStaleEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityStaleEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityStaleEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityUnarchivedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityUnarchivedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityUnarchivedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityUnarchivedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityUnarchivedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityUnarchivedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityUnarchivedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityUnarchivedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityUnarchivedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityUnarchivedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityUnarchivedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityUnarchivedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityUnmarkedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityUnmarkedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityUnmarkedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityUnmarkedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityUnmarkedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityUnmarkedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityUnmarkedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityUnmarkedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityUnmarkedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityUnmarkedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityUnmarkedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityUnmarkedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityUnwatchedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime  string      `json:"startTime"`
	SystemUser *SystemUser `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityUnwatchedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityUnwatchedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityUnwatchedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityUnwatchedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityUnwatchedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityUnwatchedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityUnwatchedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityUnwatchedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityUnwatchedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityUnwatchedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityUnwatchedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineEntityWatchedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime  string      `json:"startTime"`
	SystemUser *SystemUser `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineEntityWatchedEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEntityWatchedEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineEntityWatchedEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEntityWatchedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEntityWatchedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEntityWatchedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineEntityWatchedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEntityWatchedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEntityWatchedEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEntityWatchedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineEntityWatchedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A [Relay-Compatible](https://facebook.github.io/relay/graphql/connections.htm)
// Connection type for paginating over `TimelineEvent` elements.
type TimelineEventConnection struct {
	// List of `TimelineEvent` edges.
	Edges []*TimelineEventEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// A convenience extension to the standard Relay Connection type, directly
	// exposing the `TimelineEvent` elements, which may be used *instead* of edges.
	// It is primarily useful in conjunction with `startCursor` and `endCursor`, or
	// when exploring the API interactively (e.g. in GraphiQL).
	Nodes []TimelineEvent `json:"nodes"`
}

// A `TimelineEvent` edge in a connection.
type TimelineEventEdge struct {
	// Cursor pointing to this edge, to be used in standard pagination query arguments (`before`, `after`).
	Cursor string `json:"cursor"`
	// The `TimelineEvent` item at the end of this edge.
	Node TimelineEvent `json:"node"`
}

type TimelineEventImpl struct {
	EndTime       string                   `json:"endTime"`
	EventID       string                   `json:"eventId"`
	EventLabel    string                   `json:"eventLabel"`
	EventSeverity TimelineEventSeverity    `json:"eventSeverity"`
	EventType     TimelineEventType        `json:"eventType"`
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	StartTime     string                   `json:"startTime"`
	Timestamp     string                   `json:"timestamp"`
}

func (TimelineEventImpl) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineEventImpl) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineEventImpl) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineEventImpl) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineEventImpl) GetEventSeverity() TimelineEventSeverity { return this.EventSeverity }

// The event type.
func (this TimelineEventImpl) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineEventImpl) GetRelatedEvents() *TimelineEventConnection { return this.RelatedEvents }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineEventImpl) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineEventImpl) GetTimestamp() string { return this.Timestamp }

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineExposedPasswordEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineExposedPasswordEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineExposedPasswordEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineExposedPasswordEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineExposedPasswordEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineExposedPasswordEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineExposedPasswordEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineExposedPasswordEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineExposedPasswordEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineExposedPasswordEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineExposedPasswordEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineExposedPasswordEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating one or more failed user authentications on an endpoint within one minute.
type TimelineFailedAuthenticationEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string `json:"activeDirectorySiteName,omitempty"`
	// The number of failed authentication attempts.
	ActivityCount int `json:"activityCount"`
	// The authentication type.
	AuthenticationType AuthenticationType `json:"authenticationType"`
	// If `true`, the authentication failure is a result of policy enforcement.
	Blocked     bool         `json:"blocked"`
	BrowserInfo *BrowserInfo `json:"browserInfo,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	DeviceName           *string `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// Additional information about the reason for the authentication failure.
	ErrorDetails ErrorDetails `json:"errorDetails"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	// The list of Kerberos encryption types specified by the client. Only set for
	// activities performed over the Kerberos protocol (see `protocolType`),
	KerberosEncryptionTypes []KerberosEncryptionType `json:"kerberosEncryptionTypes,omitempty"`
	LdapSecurityType        *LdapSecurityType        `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	SmbDialect    *SmbDialect              `json:"smbDialect,omitempty"`
	SourceEntity  UserOrEndpointEntity     `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineFailedAuthenticationEvent) IsTimelineAuthenticationEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineFailedAuthenticationEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}

// The authentication type.
func (this TimelineFailedAuthenticationEvent) GetAuthenticationType() AuthenticationType {
	return this.AuthenticationType
}
func (this TimelineFailedAuthenticationEvent) GetBrowserInfo() *BrowserInfo { return this.BrowserInfo }

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineFailedAuthenticationEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineFailedAuthenticationEvent) GetDataSourceVendorName() *string {
	return this.DataSourceVendorName
}
func (this TimelineFailedAuthenticationEvent) GetDeviceName() *string { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineFailedAuthenticationEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineFailedAuthenticationEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineFailedAuthenticationEvent) GetEndpointDisplayName() *string {
	return this.EndpointDisplayName
}

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineFailedAuthenticationEvent) GetEndpointEntity() *EndpointEntity {
	return this.EndpointEntity
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineFailedAuthenticationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineFailedAuthenticationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineFailedAuthenticationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineFailedAuthenticationEvent) GetEventType() TimelineEventType { return this.EventType }

// The geolocation associated with the activity, if any.
func (this TimelineFailedAuthenticationEvent) GetGeoLocation() *GeoLocation { return this.GeoLocation }

// The origin endpoint host name.
func (this TimelineFailedAuthenticationEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineFailedAuthenticationEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineFailedAuthenticationEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineFailedAuthenticationEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineFailedAuthenticationEvent) GetIspDomain() *string { return this.IspDomain }

// The list of Kerberos encryption types specified by the client. Only set for
// activities performed over the Kerberos protocol (see `protocolType`),
func (this TimelineFailedAuthenticationEvent) GetKerberosEncryptionTypes() []KerberosEncryptionType {
	if this.KerberosEncryptionTypes == nil {
		return nil
	}
	interfaceSlice := make([]KerberosEncryptionType, 0, len(this.KerberosEncryptionTypes))
	for _, concrete := range this.KerberosEncryptionTypes {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineFailedAuthenticationEvent) GetLdapSecurityType() *LdapSecurityType {
	return this.LdapSecurityType
}

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineFailedAuthenticationEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineFailedAuthenticationEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineFailedAuthenticationEvent) GetNetworkType() NetworkType { return this.NetworkType }

// Information about the origin endpoint operating system.
func (this TimelineFailedAuthenticationEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineFailedAuthenticationEvent) GetProtocolType() ProtocolType {
	return this.ProtocolType
}
func (this TimelineFailedAuthenticationEvent) GetProtocolVersion() *string {
	return this.ProtocolVersion
}

// A connection of related events.
func (this TimelineFailedAuthenticationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineFailedAuthenticationEvent) GetSmbDialect() *SmbDialect { return this.SmbDialect }
func (this TimelineFailedAuthenticationEvent) GetSourceEntity() UserOrEndpointEntity {
	return this.SourceEntity
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineFailedAuthenticationEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineFailedAuthenticationEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineFailedAuthenticationEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineFailedAuthenticationEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineFailedAuthenticationEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineFailedAuthenticationEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineFailedAuthenticationEvent) GetTargetServiceType() *ServiceType {
	return this.TargetServiceType
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineFailedAuthenticationEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineFailedAuthenticationEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineFailedAuthenticationEvent) GetUserDisplayName() string {
	return this.UserDisplayName
}

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineFailedAuthenticationEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineFailedAuthenticationEvent) IsTimelineErrorEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// Information regarding the error.
func (this TimelineFailedAuthenticationEvent) GetErrorDetails() ErrorDetails {
	return this.ErrorDetails
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineFailedAuthenticationEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.

// A display-oriented label for the data source associated with the activity.

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// The geolocation associated with the activity, if any.

// The origin endpoint host name.

// The origin endpoint IP address, if available.

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.

// Information about the origin endpoint operating system.

// The primary network protocol used for performing the activity.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The target endpoint associated with this activity (such as a domain controller), if any.

// The target service entity.

// The target service raw identifier.

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).

// The event start time. This is the primary sort-key in `timeline` queries.

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.

func (TimelineFailedAuthenticationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event type indicating a file operation.
type TimelineFileOperationEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string      `json:"activeDirectorySiteName,omitempty"`
	BrowserInfo             *BrowserInfo `json:"browserInfo,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	DeviceName           *string `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The location of the file as reported by the vendor.
	FileLocation string `json:"fileLocation"`
	// The accessed file name.
	FileName string `json:"fileName"`
	// The operation applied.
	FileOperationType FileOperationType `json:"fileOperationType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	LdapSecurityType     *LdapSecurityType  `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The mime-type of the accessed file.
	MimeType *string `json:"mimeType,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	SourceEntity  UserOrEndpointEntity     `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineFileOperationEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineFileOperationEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}
func (this TimelineFileOperationEvent) GetBrowserInfo() *BrowserInfo { return this.BrowserInfo }

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineFileOperationEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineFileOperationEvent) GetDataSourceVendorName() *string {
	return this.DataSourceVendorName
}
func (this TimelineFileOperationEvent) GetDeviceName() *string { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineFileOperationEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineFileOperationEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineFileOperationEvent) GetEndpointDisplayName() *string {
	return this.EndpointDisplayName
}

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineFileOperationEvent) GetEndpointEntity() *EndpointEntity {
	return this.EndpointEntity
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineFileOperationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineFileOperationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineFileOperationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineFileOperationEvent) GetEventType() TimelineEventType { return this.EventType }

// The geolocation associated with the activity, if any.
func (this TimelineFileOperationEvent) GetGeoLocation() *GeoLocation { return this.GeoLocation }

// The origin endpoint host name.
func (this TimelineFileOperationEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineFileOperationEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineFileOperationEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineFileOperationEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineFileOperationEvent) GetIspDomain() *string { return this.IspDomain }
func (this TimelineFileOperationEvent) GetLdapSecurityType() *LdapSecurityType {
	return this.LdapSecurityType
}

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineFileOperationEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineFileOperationEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineFileOperationEvent) GetNetworkType() NetworkType { return this.NetworkType }

// Information about the origin endpoint operating system.
func (this TimelineFileOperationEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineFileOperationEvent) GetProtocolType() ProtocolType { return this.ProtocolType }
func (this TimelineFileOperationEvent) GetProtocolVersion() *string   { return this.ProtocolVersion }

// A connection of related events.
func (this TimelineFileOperationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineFileOperationEvent) GetSourceEntity() UserOrEndpointEntity {
	return this.SourceEntity
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineFileOperationEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineFileOperationEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineFileOperationEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineFileOperationEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineFileOperationEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineFileOperationEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineFileOperationEvent) GetTargetServiceType() *ServiceType {
	return this.TargetServiceType
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineFileOperationEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineFileOperationEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineFileOperationEvent) GetUserDisplayName() string { return this.UserDisplayName }

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineFileOperationEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineFileOperationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineGenericSensorWatchdogEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents     *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RemediationAction string                   `json:"remediationAction"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp        string `json:"timestamp"`
	TriggeringMetric string `json:"triggeringMetric"`
}

func (TimelineGenericSensorWatchdogEvent) IsTimelineDomainControllerNotificationEvent() {}

// The domain controller entity.
func (this TimelineGenericSensorWatchdogEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineGenericSensorWatchdogEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineGenericSensorWatchdogEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineGenericSensorWatchdogEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineGenericSensorWatchdogEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineGenericSensorWatchdogEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineGenericSensorWatchdogEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineGenericSensorWatchdogEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineGenericSensorWatchdogEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineGenericSensorWatchdogEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineGenericSensorWatchdogEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineGenericSensorWatchdogEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a change in `Incident:lifeCycleStage`.
type TimelineIncidentLifeCycleStageChangeEvent struct {
	// The lifecycle stage after the event.
	CurrentStage IncidentLifeCycleStage `json:"currentStage"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The containing incident of the alert.
	Incident *Incident `json:"incident"`
	// The lifecycle stage prior to the event.
	PreviousStage IncidentLifeCycleStage `json:"previousStage"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineIncidentLifeCycleStageChangeEvent) IsTimelineIncidentLifeCycleEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineIncidentLifeCycleStageChangeEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// The containing incident of the alert.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetIncident() *Incident { return this.Incident }

// A connection of related events.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineIncidentLifeCycleStageChangeEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineIncidentLifeCycleStageChangeEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

func (this TimelineIncidentLifeCycleStageChangeEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineIncidentLifeCycleStageChangeEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineIncidentLifeCycleStageChangeEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a change in `Incident:severity`.
type TimelineIncidentSeverityChange struct {
	// The incident severity prior to the event.
	CurrentIncidentSeverity IncidentSeverity `json:"currentIncidentSeverity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The containing incident of the alert.
	Incident *Incident `json:"incident"`
	// The incident severity after the event.
	PreviousIncidentSeverity IncidentSeverity `json:"previousIncidentSeverity"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineIncidentSeverityChange) IsTimelineIncidentLifeCycleEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineIncidentSeverityChange) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineIncidentSeverityChange) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineIncidentSeverityChange) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineIncidentSeverityChange) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineIncidentSeverityChange) GetEventType() TimelineEventType { return this.EventType }

// The containing incident of the alert.
func (this TimelineIncidentSeverityChange) GetIncident() *Incident { return this.Incident }

// A connection of related events.
func (this TimelineIncidentSeverityChange) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineIncidentSeverityChange) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineIncidentSeverityChange) GetTimestamp() string { return this.Timestamp }

func (TimelineIncidentSeverityChange) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a change in `Incident:type`.
type TimelineIncidentTypeChange struct {
	// The incident type after the event.
	CurrentIncidentType IncidentType `json:"currentIncidentType"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The containing incident of the alert.
	Incident *Incident `json:"incident"`
	// The incident type prior to the event.
	PreviousIncidentType IncidentType `json:"previousIncidentType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineIncidentTypeChange) IsTimelineIncidentLifeCycleEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineIncidentTypeChange) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineIncidentTypeChange) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineIncidentTypeChange) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineIncidentTypeChange) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineIncidentTypeChange) GetEventType() TimelineEventType { return this.EventType }

// The containing incident of the alert.
func (this TimelineIncidentTypeChange) GetIncident() *Incident { return this.Incident }

// A connection of related events.
func (this TimelineIncidentTypeChange) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineIncidentTypeChange) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineIncidentTypeChange) GetTimestamp() string { return this.Timestamp }

func (TimelineIncidentTypeChange) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event type indicating that one or more LDAP searches of a common
// pattern have been issued within a particular minute timeframe. An LDAP search
// pattern is based on the exact structural shape of the query, but discards bound
// query values (such as a particular LDAP DN).
type TimelineLdapSearchEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string      `json:"activeDirectorySiteName,omitempty"`
	BrowserInfo             *BrowserInfo `json:"browserInfo,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	DeviceName           *string `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	// The request LDAP attributes.
	LdapSearchAttributes []string `json:"ldapSearchAttributes,omitempty"`
	// A filter sample taken from one of the raw search activities group by this event.
	LdapSearchFilterSample string `json:"ldapSearchFilterSample"`
	// The list of query signatures the system has identified for this activity.
	LdapSearchQuerySignatures []LdapQuerySignature `json:"ldapSearchQuerySignatures"`
	// The specified LDAP search scope.
	LdapSearchScope int `json:"ldapSearchScope"`
	// The specified LDAP search size limit.
	LdapSearchSizeLimit int               `json:"ldapSearchSizeLimit"`
	LdapSecurityType    *LdapSecurityType `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	SourceEntity  UserOrEndpointEntity     `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineLdapSearchEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineLdapSearchEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}
func (this TimelineLdapSearchEvent) GetBrowserInfo() *BrowserInfo { return this.BrowserInfo }

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineLdapSearchEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineLdapSearchEvent) GetDataSourceVendorName() *string {
	return this.DataSourceVendorName
}
func (this TimelineLdapSearchEvent) GetDeviceName() *string { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineLdapSearchEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineLdapSearchEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineLdapSearchEvent) GetEndpointDisplayName() *string { return this.EndpointDisplayName }

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineLdapSearchEvent) GetEndpointEntity() *EndpointEntity { return this.EndpointEntity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineLdapSearchEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineLdapSearchEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineLdapSearchEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineLdapSearchEvent) GetEventType() TimelineEventType { return this.EventType }

// The geolocation associated with the activity, if any.
func (this TimelineLdapSearchEvent) GetGeoLocation() *GeoLocation { return this.GeoLocation }

// The origin endpoint host name.
func (this TimelineLdapSearchEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineLdapSearchEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineLdapSearchEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineLdapSearchEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineLdapSearchEvent) GetIspDomain() *string { return this.IspDomain }
func (this TimelineLdapSearchEvent) GetLdapSecurityType() *LdapSecurityType {
	return this.LdapSecurityType
}

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineLdapSearchEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineLdapSearchEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineLdapSearchEvent) GetNetworkType() NetworkType { return this.NetworkType }

// Information about the origin endpoint operating system.
func (this TimelineLdapSearchEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineLdapSearchEvent) GetProtocolType() ProtocolType { return this.ProtocolType }
func (this TimelineLdapSearchEvent) GetProtocolVersion() *string   { return this.ProtocolVersion }

// A connection of related events.
func (this TimelineLdapSearchEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineLdapSearchEvent) GetSourceEntity() UserOrEndpointEntity { return this.SourceEntity }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineLdapSearchEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineLdapSearchEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineLdapSearchEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineLdapSearchEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineLdapSearchEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineLdapSearchEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineLdapSearchEvent) GetTargetServiceType() *ServiceType {
	return this.TargetServiceType
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineLdapSearchEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineLdapSearchEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineLdapSearchEvent) GetUserDisplayName() string { return this.UserDisplayName }

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineLdapSearchEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineLdapSearchEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineLinkedAccountChangeNotificationEvent struct {
	AddedLinkedAccounts []Entity `json:"addedLinkedAccounts"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents         *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RemovedLinkedAccounts []Entity                 `json:"removedLinkedAccounts"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineLinkedAccountChangeNotificationEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineLinkedAccountChangeNotificationEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineLinkedAccountChangeNotificationEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineLinkedAccountChangeNotificationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineLinkedAccountChangeNotificationEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineLinkedAccountChangeNotificationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineLinkedAccountChangeNotificationEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineLinkedAccountChangeNotificationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineLinkedAccountChangeNotificationEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineLinkedAccountChangeNotificationEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineLinkedAccountChangeNotificationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineMfaFallbackPeriodEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType         TimelineEventType `json:"eventType"`
	MfaFallbackPeriod string            `json:"mfaFallbackPeriod"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineMfaFallbackPeriodEvent) IsTimelineUserEngagementChangedEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineMfaFallbackPeriodEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineMfaFallbackPeriodEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineMfaFallbackPeriodEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineMfaFallbackPeriodEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineMfaFallbackPeriodEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineMfaFallbackPeriodEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineMfaFallbackPeriodEvent) GetStartTime() string { return this.StartTime }
func (this TimelineMfaFallbackPeriodEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineMfaFallbackPeriodEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineMfaFallbackPeriodEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineMfaFallbackPeriodEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineMfaFallbackPeriodEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineMfaFallbackPeriodEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineMfaServiceEnrollmentEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime           string                   `json:"endTime"`
	EngagementSummary *CommonEngagementSummary `json:"engagementSummary"`
	Entities          []*UserEntity            `json:"entities"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineMfaServiceEnrollmentEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineMfaServiceEnrollmentEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineMfaServiceEnrollmentEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineMfaServiceEnrollmentEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineMfaServiceEnrollmentEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineMfaServiceEnrollmentEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineMfaServiceEnrollmentEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineMfaServiceEnrollmentEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineMfaServiceEnrollmentEvent) GetTimestamp() string { return this.Timestamp }

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineNetExtractorStoppedPolicyEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp         string   `json:"timestamp"`
	TriggeringMetrics []string `json:"triggeringMetrics"`
}

func (TimelineNetExtractorStoppedPolicyEvent) IsTimelineDomainControllerNotificationEvent() {}

// The domain controller entity.
func (this TimelineNetExtractorStoppedPolicyEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNetExtractorStoppedPolicyEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNetExtractorStoppedPolicyEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNetExtractorStoppedPolicyEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNetExtractorStoppedPolicyEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNetExtractorStoppedPolicyEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineNetExtractorStoppedPolicyEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNetExtractorStoppedPolicyEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineNetExtractorStoppedPolicyEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNetExtractorStoppedPolicyEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineNetExtractorStoppedPolicyEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineNetExtractorStoppedPolicyEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineNetExtractorStoppedPublishEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp         string   `json:"timestamp"`
	TriggeringMetrics []string `json:"triggeringMetrics"`
}

func (TimelineNetExtractorStoppedPublishEvent) IsTimelineDomainControllerNotificationEvent() {}

// The domain controller entity.
func (this TimelineNetExtractorStoppedPublishEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNetExtractorStoppedPublishEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNetExtractorStoppedPublishEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNetExtractorStoppedPublishEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNetExtractorStoppedPublishEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNetExtractorStoppedPublishEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineNetExtractorStoppedPublishEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNetExtractorStoppedPublishEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineNetExtractorStoppedPublishEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNetExtractorStoppedPublishEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineNetExtractorStoppedPublishEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineNetExtractorStoppedPublishEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineNetExtractorStoppedTrafficEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp         string   `json:"timestamp"`
	TriggeringMetrics []string `json:"triggeringMetrics"`
}

func (TimelineNetExtractorStoppedTrafficEvent) IsTimelineDomainControllerNotificationEvent() {}

// The domain controller entity.
func (this TimelineNetExtractorStoppedTrafficEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNetExtractorStoppedTrafficEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNetExtractorStoppedTrafficEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNetExtractorStoppedTrafficEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNetExtractorStoppedTrafficEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNetExtractorStoppedTrafficEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineNetExtractorStoppedTrafficEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNetExtractorStoppedTrafficEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineNetExtractorStoppedTrafficEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNetExtractorStoppedTrafficEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineNetExtractorStoppedTrafficEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineNetExtractorStoppedTrafficEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp         string   `json:"timestamp"`
	TriggeringMetrics []string `json:"triggeringMetrics"`
}

func (TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) IsTimelineDomainControllerNotificationEvent() {
}

// The domain controller entity.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetEndTime() string {
	return this.EndTime
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetEventID() string {
	return this.EventID
}

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetStartTime() string {
	return this.StartTime
}

// The system notification status.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetState() *NotificationState {
	return this.State
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) GetTimestamp() string {
	return this.Timestamp
}

func (TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineNetExtractorWatchdogAnalyzerServiceRestartEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineNetExtractorWatchdogManagementServiceRestartEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp         string   `json:"timestamp"`
	TriggeringMetrics []string `json:"triggeringMetrics"`
}

func (TimelineNetExtractorWatchdogManagementServiceRestartEvent) IsTimelineDomainControllerNotificationEvent() {
}

// The domain controller entity.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetEndTime() string {
	return this.EndTime
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetEventID() string {
	return this.EventID
}

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetStartTime() string {
	return this.StartTime
}

// The system notification status.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetState() *NotificationState {
	return this.State
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNetExtractorWatchdogManagementServiceRestartEvent) GetTimestamp() string {
	return this.Timestamp
}

func (TimelineNetExtractorWatchdogManagementServiceRestartEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineNetExtractorWatchdogManagementServiceRestartEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineNetExtractorWatchdogMonitoringServiceRestartEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp         string   `json:"timestamp"`
	TriggeringMetrics []string `json:"triggeringMetrics"`
}

func (TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) IsTimelineDomainControllerNotificationEvent() {
}

// The domain controller entity.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetEndTime() string {
	return this.EndTime
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetEventID() string {
	return this.EventID
}

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetStartTime() string {
	return this.StartTime
}

// The system notification status.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetState() *NotificationState {
	return this.State
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) GetTimestamp() string {
	return this.Timestamp
}

func (TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineNetExtractorWatchdogMonitoringServiceRestartEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a new incident.
type TimelineNewIncidentEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The containing incident of the alert.
	Incident *Incident `json:"incident"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineNewIncidentEvent) IsTimelineIncidentLifeCycleEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineNewIncidentEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineNewIncidentEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineNewIncidentEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineNewIncidentEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineNewIncidentEvent) GetEventType() TimelineEventType { return this.EventType }

// The containing incident of the alert.
func (this TimelineNewIncidentEvent) GetIncident() *Incident { return this.Incident }

// A connection of related events.
func (this TimelineNewIncidentEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineNewIncidentEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineNewIncidentEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineNewIncidentEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a change in the `ou` field of an entity's primary account.
type TimelineOuChangeEvent struct {
	// The `ou` associated with the primary account of the entity after the event.
	CurrentOu *string `json:"currentOu,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The `ou` associated with the primary account of the entity prior to the event.
	PreviousOu *string `json:"previousOu,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineOuChangeEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineOuChangeEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineOuChangeEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineOuChangeEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineOuChangeEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineOuChangeEvent) GetEventSeverity() TimelineEventSeverity { return this.EventSeverity }

// The event type.
func (this TimelineOuChangeEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineOuChangeEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineOuChangeEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineOuChangeEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineOuChangeEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelinePasswordChangeEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePasswordChangeEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePasswordChangeEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelinePasswordChangeEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePasswordChangeEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePasswordChangeEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePasswordChangeEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePasswordChangeEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePasswordChangeEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePasswordChangeEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePasswordChangeEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePasswordChangeEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyAppliedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePolicyAppliedEvent) IsTimelinePolicyConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePolicyAppliedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePolicyAppliedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePolicyAppliedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePolicyAppliedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePolicyAppliedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePolicyAppliedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePolicyAppliedEvent) GetStartTime() string { return this.StartTime }
func (this TimelinePolicyAppliedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelinePolicyAppliedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePolicyAppliedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePolicyAppliedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyAppliedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyAppliedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyRuleAddedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RuleID        string                   `json:"ruleId"`
	RuleName      string                   `json:"ruleName"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePolicyRuleAddedEvent) IsTimelinePolicySingleRuleChangedEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePolicyRuleAddedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePolicyRuleAddedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePolicyRuleAddedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePolicyRuleAddedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePolicyRuleAddedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePolicyRuleAddedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelinePolicyRuleAddedEvent) GetRuleID() string   { return this.RuleID }
func (this TimelinePolicyRuleAddedEvent) GetRuleName() string { return this.RuleName }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePolicyRuleAddedEvent) GetStartTime() string { return this.StartTime }
func (this TimelinePolicyRuleAddedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelinePolicyRuleAddedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePolicyRuleAddedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePolicyRuleAddedEvent) IsTimelinePolicyConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleAddedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleAddedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleAddedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyRuleDeletedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RuleID        string                   `json:"ruleId"`
	RuleName      string                   `json:"ruleName"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePolicyRuleDeletedEvent) IsTimelinePolicySingleRuleChangedEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePolicyRuleDeletedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePolicyRuleDeletedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePolicyRuleDeletedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePolicyRuleDeletedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePolicyRuleDeletedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePolicyRuleDeletedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelinePolicyRuleDeletedEvent) GetRuleID() string   { return this.RuleID }
func (this TimelinePolicyRuleDeletedEvent) GetRuleName() string { return this.RuleName }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePolicyRuleDeletedEvent) GetStartTime() string { return this.StartTime }
func (this TimelinePolicyRuleDeletedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelinePolicyRuleDeletedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePolicyRuleDeletedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePolicyRuleDeletedEvent) IsTimelinePolicyConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleDeletedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleDeletedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleDeletedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyRuleMatchEvent struct {
	Action           RuleAction `json:"action"`
	ActionLabel      string     `json:"actionLabel"`
	AuditTimestamp   string     `json:"auditTimestamp"`
	AuthorizerEntity Entity     `json:"authorizerEntity,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	Inline    bool              `json:"inline"`
	// A connection of related events.
	RelatedEvents             *TimelineEventConnection `json:"relatedEvents,omitempty"`
	ResultDescription         string                   `json:"resultDescription"`
	RuleID                    string                   `json:"ruleId"`
	RuleName                  *string                  `json:"ruleName,omitempty"`
	SimulationMode            bool                     `json:"simulationMode"`
	SourceEndpoint            Entity                   `json:"sourceEndpoint,omitempty"`
	SourceEndpointDisplayName *string                  `json:"sourceEndpointDisplayName,omitempty"`
	SourceEntity              Entity                   `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime               string  `json:"startTime"`
	Successful              bool    `json:"successful"`
	TargetEndpoint          Entity  `json:"targetEndpoint,omitempty"`
	TargetEntity            Entity  `json:"targetEntity,omitempty"`
	TargetEntityDescription *string `json:"targetEntityDescription,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp        string      `json:"timestamp"`
	TransactionID    string      `json:"transactionId"`
	Trigger          RuleTrigger `json:"trigger"`
	TriggerLabel     string      `json:"triggerLabel"`
	TriggerTimestamp string      `json:"triggerTimestamp"`
}

func (TimelinePolicyRuleMatchEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePolicyRuleMatchEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePolicyRuleMatchEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePolicyRuleMatchEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePolicyRuleMatchEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePolicyRuleMatchEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePolicyRuleMatchEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePolicyRuleMatchEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePolicyRuleMatchEvent) GetTimestamp() string { return this.Timestamp }

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyRuleModifiedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RuleID        string                   `json:"ruleId"`
	RuleName      string                   `json:"ruleName"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePolicyRuleModifiedEvent) IsTimelinePolicySingleRuleChangedEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePolicyRuleModifiedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePolicyRuleModifiedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePolicyRuleModifiedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePolicyRuleModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePolicyRuleModifiedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePolicyRuleModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelinePolicyRuleModifiedEvent) GetRuleID() string   { return this.RuleID }
func (this TimelinePolicyRuleModifiedEvent) GetRuleName() string { return this.RuleName }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePolicyRuleModifiedEvent) GetStartTime() string { return this.StartTime }
func (this TimelinePolicyRuleModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelinePolicyRuleModifiedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePolicyRuleModifiedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePolicyRuleModifiedEvent) IsTimelinePolicyConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRuleModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelinePolicyRulesReorderedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePolicyRulesReorderedEvent) IsTimelinePolicyConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePolicyRulesReorderedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePolicyRulesReorderedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePolicyRulesReorderedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePolicyRulesReorderedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePolicyRulesReorderedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePolicyRulesReorderedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePolicyRulesReorderedEvent) GetStartTime() string { return this.StartTime }
func (this TimelinePolicyRulesReorderedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelinePolicyRulesReorderedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePolicyRulesReorderedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePolicyRulesReorderedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRulesReorderedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelinePolicyRulesReorderedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating `Entity` privilege deescalation. Entity privileges
// are determined by `AdminAccountRole` entity roles.
type TimelinePrivilegeDeEscalationEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// List of removed privileges. All returned types are guaranteed to be subtypes of `AdminAccountRole`.
	RemovedPrivileges []EntityRoleType `json:"removedPrivileges"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePrivilegeDeEscalationEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePrivilegeDeEscalationEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelinePrivilegeDeEscalationEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePrivilegeDeEscalationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePrivilegeDeEscalationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePrivilegeDeEscalationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePrivilegeDeEscalationEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelinePrivilegeDeEscalationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePrivilegeDeEscalationEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePrivilegeDeEscalationEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePrivilegeDeEscalationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating `Entity` privilege escalation. Entity privileges
// are determined by `AdminAccountRole` entity roles.
type TimelinePrivilegeEscalationEvent struct {
	// List of added privileges. All returned types are guaranteed to be subtypes of `AdminAccountRole`.
	AddedPrivileges []EntityRoleType `json:"addedPrivileges"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelinePrivilegeEscalationEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelinePrivilegeEscalationEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelinePrivilegeEscalationEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelinePrivilegeEscalationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelinePrivilegeEscalationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelinePrivilegeEscalationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelinePrivilegeEscalationEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelinePrivilegeEscalationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelinePrivilegeEscalationEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelinePrivilegeEscalationEvent) GetTimestamp() string { return this.Timestamp }

func (TimelinePrivilegeEscalationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `TimelineEvent` interface common to `timeline` events related to end user
// activity on endpoints, such as authentication and service access activities.
// This is the primary interface to be used in projections when querying the
// timeline for `user` activities.
//
// When available, the user and endpoint `Entity` data is exposed through the
// corresponding fields. However, in some cases the data regarding the user or
// endpoint may be too limited to be associated with particular entities. For
// example, a `FAILED_AUTHENTICATION` event may be a result of a misspelled user
// name, and a `SUCCESSFUL_AUTHENTICATION` may originate outside the organization,
// limiting the available data about the source endpoint. For this reason,
// additional fields exposing more elementary data are also available, alongside
// the `Entity` fields.
type TimelineRemoteCodeExecutionEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string      `json:"activeDirectorySiteName,omitempty"`
	BrowserInfo             *BrowserInfo `json:"browserInfo,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	DeviceName           *string `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	LdapSecurityType     *LdapSecurityType  `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents             *TimelineEventConnection  `json:"relatedEvents,omitempty"`
	RemoteCodeExecutionMethod RemoteCodeExecutionMethod `json:"remoteCodeExecutionMethod"`
	SourceEntity              UserOrEndpointEntity      `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineRemoteCodeExecutionEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineRemoteCodeExecutionEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}
func (this TimelineRemoteCodeExecutionEvent) GetBrowserInfo() *BrowserInfo { return this.BrowserInfo }

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineRemoteCodeExecutionEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineRemoteCodeExecutionEvent) GetDataSourceVendorName() *string {
	return this.DataSourceVendorName
}
func (this TimelineRemoteCodeExecutionEvent) GetDeviceName() *string { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineRemoteCodeExecutionEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineRemoteCodeExecutionEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineRemoteCodeExecutionEvent) GetEndpointDisplayName() *string {
	return this.EndpointDisplayName
}

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineRemoteCodeExecutionEvent) GetEndpointEntity() *EndpointEntity {
	return this.EndpointEntity
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineRemoteCodeExecutionEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineRemoteCodeExecutionEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineRemoteCodeExecutionEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineRemoteCodeExecutionEvent) GetEventType() TimelineEventType { return this.EventType }

// The geolocation associated with the activity, if any.
func (this TimelineRemoteCodeExecutionEvent) GetGeoLocation() *GeoLocation { return this.GeoLocation }

// The origin endpoint host name.
func (this TimelineRemoteCodeExecutionEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineRemoteCodeExecutionEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineRemoteCodeExecutionEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineRemoteCodeExecutionEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineRemoteCodeExecutionEvent) GetIspDomain() *string { return this.IspDomain }
func (this TimelineRemoteCodeExecutionEvent) GetLdapSecurityType() *LdapSecurityType {
	return this.LdapSecurityType
}

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineRemoteCodeExecutionEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineRemoteCodeExecutionEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineRemoteCodeExecutionEvent) GetNetworkType() NetworkType { return this.NetworkType }

// Information about the origin endpoint operating system.
func (this TimelineRemoteCodeExecutionEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineRemoteCodeExecutionEvent) GetProtocolType() ProtocolType { return this.ProtocolType }
func (this TimelineRemoteCodeExecutionEvent) GetProtocolVersion() *string {
	return this.ProtocolVersion
}

// A connection of related events.
func (this TimelineRemoteCodeExecutionEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineRemoteCodeExecutionEvent) GetSourceEntity() UserOrEndpointEntity {
	return this.SourceEntity
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineRemoteCodeExecutionEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineRemoteCodeExecutionEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineRemoteCodeExecutionEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineRemoteCodeExecutionEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineRemoteCodeExecutionEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineRemoteCodeExecutionEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineRemoteCodeExecutionEvent) GetTargetServiceType() *ServiceType {
	return this.TargetServiceType
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineRemoteCodeExecutionEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineRemoteCodeExecutionEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineRemoteCodeExecutionEvent) GetUserDisplayName() string { return this.UserDisplayName }

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineRemoteCodeExecutionEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineRemoteCodeExecutionEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineReportAddedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// A unique identifier for the report.
	ReportID string `json:"reportId"`
	// The report name.
	ReportName string `json:"reportName"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineReportAddedEvent) IsTimelineConfigurationReportEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineReportAddedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineReportAddedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineReportAddedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineReportAddedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineReportAddedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineReportAddedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// A unique identifier for the report.
func (this TimelineReportAddedEvent) GetReportID() string { return this.ReportID }

// The report name.
func (this TimelineReportAddedEvent) GetReportName() string { return this.ReportName }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineReportAddedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineReportAddedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineReportAddedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineReportAddedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineReportAddedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineReportAddedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineReportAddedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineReportDeletedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// A unique identifier for the report.
	ReportID string `json:"reportId"`
	// The report name.
	ReportName string `json:"reportName"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineReportDeletedEvent) IsTimelineConfigurationReportEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineReportDeletedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineReportDeletedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineReportDeletedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineReportDeletedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineReportDeletedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineReportDeletedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// A unique identifier for the report.
func (this TimelineReportDeletedEvent) GetReportID() string { return this.ReportID }

// The report name.
func (this TimelineReportDeletedEvent) GetReportName() string { return this.ReportName }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineReportDeletedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineReportDeletedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineReportDeletedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineReportDeletedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineReportDeletedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineReportDeletedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineReportDeletedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineReportModifiedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// A unique identifier for the report.
	ReportID string `json:"reportId"`
	// The report name.
	ReportName string `json:"reportName"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineReportModifiedEvent) IsTimelineConfigurationReportEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineReportModifiedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineReportModifiedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineReportModifiedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineReportModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineReportModifiedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineReportModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// A unique identifier for the report.
func (this TimelineReportModifiedEvent) GetReportID() string { return this.ReportID }

// The report name.
func (this TimelineReportModifiedEvent) GetReportName() string { return this.ReportName }

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineReportModifiedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineReportModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineReportModifiedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineReportModifiedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineReportModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineReportModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineReportModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineRiskFactorsConfigurationModifiedEvent struct {
	DisabledRiskFactors []RiskFactorType `json:"disabledRiskFactors"`
	EnabledRiskFactors  []RiskFactorType `json:"enabledRiskFactors"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineRiskFactorsConfigurationModifiedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetEventLabel() string {
	return this.EventLabel
}

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetStartTime() string {
	return this.StartTime
}
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetSystemUser() *SystemUser {
	return this.SystemUser
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineRiskFactorsConfigurationModifiedEvent) GetTimestamp() string {
	return this.Timestamp
}

func (TimelineRiskFactorsConfigurationModifiedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineRiskFactorsConfigurationModifiedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to `timeline` events focused on a single `Entity`.
type TimelineScoreDeEscalationEvent struct {
	CurrentScore    string `json:"currentScore"`
	CurrentSeverity string `json:"currentSeverity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType        TimelineEventType `json:"eventType"`
	PreviousScore    *string           `json:"previousScore,omitempty"`
	PreviousSeverity *ScoreSeverity    `json:"previousSeverity,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineScoreDeEscalationEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineScoreDeEscalationEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineScoreDeEscalationEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineScoreDeEscalationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineScoreDeEscalationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineScoreDeEscalationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineScoreDeEscalationEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineScoreDeEscalationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineScoreDeEscalationEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineScoreDeEscalationEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineScoreDeEscalationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating an escalation in the risk score severity of an entity (see `UserOrEndpointEntity:riskScore`).
type TimelineScoreEscalationEvent struct {
	// The risk score value associated with the entity after the event.
	CurrentScore string `json:"currentScore"`
	// The risk score severity value associated with the entity after the event.
	CurrentSeverity string `json:"currentSeverity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The risk score value associated with the entity prior to the event.
	PreviousScore *string `json:"previousScore,omitempty"`
	// The risk score severity value associated with the entity prior to the event.
	PreviousSeverity *ScoreSeverity `json:"previousSeverity,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineScoreEscalationEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineScoreEscalationEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineScoreEscalationEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineScoreEscalationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineScoreEscalationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineScoreEscalationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineScoreEscalationEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineScoreEscalationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineScoreEscalationEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineScoreEscalationEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineScoreEscalationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A specialized `TimelineEvent` interface common to system notifications
// concerning a specific Active Directory domain controller.
type TimelineSensorWatchdogEvent struct {
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType                      TimelineEventType `json:"eventType"`
	LastSampledMemoryValueMb       int               `json:"lastSampledMemoryValueMB"`
	MemoryThresholdDurationMinutes int               `json:"memoryThresholdDurationMinutes"`
	MemoryThresholdMb              int               `json:"memoryThresholdMB"`
	// A connection of related events.
	RelatedEvents     *TimelineEventConnection `json:"relatedEvents,omitempty"`
	RemediationAction string                   `json:"remediationAction"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp        string `json:"timestamp"`
	TriggeringMetric string `json:"triggeringMetric"`
}

func (TimelineSensorWatchdogEvent) IsTimelineDomainControllerNotificationEvent() {}

// The domain controller entity.
func (this TimelineSensorWatchdogEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineSensorWatchdogEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineSensorWatchdogEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineSensorWatchdogEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineSensorWatchdogEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineSensorWatchdogEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineSensorWatchdogEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineSensorWatchdogEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineSensorWatchdogEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineSensorWatchdogEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineSensorWatchdogEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineSensorWatchdogEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a service access network activity.
type TimelineServiceAccessEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string      `json:"activeDirectorySiteName,omitempty"`
	BrowserInfo             *BrowserInfo `json:"browserInfo,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	DeviceName           *string `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	// The list of Kerberos encryption types specified by the client. Only set for
	// activities performed over the Kerberos protocol (see `protocolType`),
	KerberosEncryptionTypes []KerberosEncryptionType `json:"kerberosEncryptionTypes,omitempty"`
	LdapSecurityType        *LdapSecurityType        `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// *Deprecated*: Use `TimelineUserOnEndpointActivityEvent:targetServiceType` instead
	ServiceType  ServiceType          `json:"serviceType"`
	SourceEntity UserOrEndpointEntity `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// *Deprecated*: Use `TimelineUserOnEndpointActivityEvent:targetEntity` instead
	TargetServiceEntity Entity `json:"targetServiceEntity"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineServiceAccessEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineServiceAccessEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}
func (this TimelineServiceAccessEvent) GetBrowserInfo() *BrowserInfo { return this.BrowserInfo }

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineServiceAccessEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineServiceAccessEvent) GetDataSourceVendorName() *string {
	return this.DataSourceVendorName
}
func (this TimelineServiceAccessEvent) GetDeviceName() *string { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineServiceAccessEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineServiceAccessEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineServiceAccessEvent) GetEndpointDisplayName() *string {
	return this.EndpointDisplayName
}

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineServiceAccessEvent) GetEndpointEntity() *EndpointEntity {
	return this.EndpointEntity
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineServiceAccessEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineServiceAccessEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineServiceAccessEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineServiceAccessEvent) GetEventType() TimelineEventType { return this.EventType }

// The geolocation associated with the activity, if any.
func (this TimelineServiceAccessEvent) GetGeoLocation() *GeoLocation { return this.GeoLocation }

// The origin endpoint host name.
func (this TimelineServiceAccessEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineServiceAccessEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineServiceAccessEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineServiceAccessEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineServiceAccessEvent) GetIspDomain() *string { return this.IspDomain }
func (this TimelineServiceAccessEvent) GetLdapSecurityType() *LdapSecurityType {
	return this.LdapSecurityType
}

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineServiceAccessEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineServiceAccessEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineServiceAccessEvent) GetNetworkType() NetworkType { return this.NetworkType }

// Information about the origin endpoint operating system.
func (this TimelineServiceAccessEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineServiceAccessEvent) GetProtocolType() ProtocolType { return this.ProtocolType }
func (this TimelineServiceAccessEvent) GetProtocolVersion() *string   { return this.ProtocolVersion }

// A connection of related events.
func (this TimelineServiceAccessEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineServiceAccessEvent) GetSourceEntity() UserOrEndpointEntity {
	return this.SourceEntity
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineServiceAccessEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineServiceAccessEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineServiceAccessEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineServiceAccessEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineServiceAccessEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineServiceAccessEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineServiceAccessEvent) GetTargetServiceType() *ServiceType {
	return this.TargetServiceType
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineServiceAccessEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineServiceAccessEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineServiceAccessEvent) GetUserDisplayName() string { return this.UserDisplayName }

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineServiceAccessEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineServiceAccessEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating a successful user authentication on an endpoint.
type TimelineSuccessfulAuthenticationEvent struct {
	// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
	ActiveDirectorySiteName *string `json:"activeDirectorySiteName,omitempty"`
	// The authentication type.
	AuthenticationType   AuthenticationType `json:"authenticationType"`
	BrowserInfo          *BrowserInfo       `json:"browserInfo,omitempty"`
	CertificateBasedAuth *bool              `json:"certificateBasedAuth,omitempty"`
	// The data source associated with this activity. Because the `DataSource`
	// enumeration contains some fallback values for generic sources,
	// `dataSourceVendorName` is provided as an alternative.
	DataSource DataSource `json:"dataSource"`
	// A display-oriented label for the data source associated with the activity.
	DataSourceVendorName *string `json:"dataSourceVendorName,omitempty"`
	DeviceName           *string `json:"deviceName,omitempty"`
	// A display-oriented label reflecting the origin endpoint operating system, as
	// exposed by the `operatingSystemInfo` field. The semantics of this value are
	// not rrigorously restricted.
	// Therefore, the data is supposed to used programmatically, it is always
	// recommended to project the underlying `operatingSystemInfo` field instead.
	DeviceType *string `json:"deviceType,omitempty"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A display-oriented label reflecting the best available display name for the
	// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
	// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
	EndpointDisplayName *string `json:"endpointDisplayName,omitempty"`
	// The origin endpoint entity associated with the activity, if available. Note
	// that `endpointDisplayName` is available even when the entity is unknown.
	EndpointEntity *EndpointEntity `json:"endpointEntity,omitempty"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// The geolocation associated with the activity, if any.
	GeoLocation *GeoLocation `json:"geoLocation,omitempty"`
	// The origin endpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// The origin endpoint IP address, if available.
	IPAddress            *string            `json:"ipAddress,omitempty"`
	IPAddressReputations []IPReputation     `json:"ipAddressReputations"`
	IspClassification    *IspClassification `json:"ispClassification,omitempty"`
	IspDomain            *string            `json:"ispDomain,omitempty"`
	// The list of Kerberos encryption types specified by the client. Only set for
	// activities performed over the Kerberos protocol (see `protocolType`),
	KerberosEncryptionTypes []KerberosEncryptionType `json:"kerberosEncryptionTypes,omitempty"`
	LdapSecurityType        *LdapSecurityType        `json:"ldapSecurityType,omitempty"`
	// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
	//
	// Returns `null` if no location data is available for this activity or if the
	// user associated with this activity couldn't be correlated with a user entity.
	LocationAssociatedWithUser *bool `json:"locationAssociatedWithUser,omitempty"`
	// The subnet label, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkTag *string `json:"networkTag,omitempty"`
	// The subnet type, as defined in the system configuration, associated with the
	// origin endpoint IP address at the time the activity was performed.
	NetworkType NetworkType `json:"networkType"`
	// Information about the origin endpoint operating system.
	OperatingSystemInfo *OperatingSystemInfo `json:"operatingSystemInfo,omitempty"`
	// The primary network protocol used for performing the activity.
	ProtocolType    ProtocolType `json:"protocolType"`
	ProtocolVersion *string      `json:"protocolVersion,omitempty"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	SmbDialect    *SmbDialect              `json:"smbDialect,omitempty"`
	SourceEntity  UserOrEndpointEntity     `json:"sourceEntity,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The target endpoint associated with this activity (such as a domain controller), if any.
	TargetEndpointEntity *EndpointEntity `json:"targetEndpointEntity,omitempty"`
	// The target service entity.
	TargetEntity             Entity  `json:"targetEntity,omitempty"`
	TargetServiceDescription *string `json:"targetServiceDescription,omitempty"`
	TargetServiceDisplayName *string `json:"targetServiceDisplayName,omitempty"`
	// The target service raw identifier.
	TargetServiceIdentifier *string `json:"targetServiceIdentifier,omitempty"`
	// A classification value of the service accessed, based on the raw identifier
	// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
	TargetServiceType *ServiceType `json:"targetServiceType,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp  string      `json:"timestamp"`
	TLSVersion *TLSVersion `json:"tlsVersion,omitempty"`
	// A display-oriented label of the best available display name for the user
	// associated with this event. `UserEntity:primaryDisplayName` is used if
	// available. Otherwise, the raw user identifier used for performing this
	// activity is applied.
	UserDisplayName string `json:"userDisplayName"`
	// The user entity associated with the activity, if available. Note that
	// `userDisplayName` is available even when the entity is unknown.
	UserEntity *UserEntity `json:"userEntity,omitempty"`
}

func (TimelineSuccessfulAuthenticationEvent) IsTimelineAuthenticationEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.
func (this TimelineSuccessfulAuthenticationEvent) GetActiveDirectorySiteName() *string {
	return this.ActiveDirectorySiteName
}

// The authentication type.
func (this TimelineSuccessfulAuthenticationEvent) GetAuthenticationType() AuthenticationType {
	return this.AuthenticationType
}
func (this TimelineSuccessfulAuthenticationEvent) GetBrowserInfo() *BrowserInfo {
	return this.BrowserInfo
}

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.
func (this TimelineSuccessfulAuthenticationEvent) GetDataSource() DataSource { return this.DataSource }

// A display-oriented label for the data source associated with the activity.
func (this TimelineSuccessfulAuthenticationEvent) GetDataSourceVendorName() *string {
	return this.DataSourceVendorName
}
func (this TimelineSuccessfulAuthenticationEvent) GetDeviceName() *string { return this.DeviceName }

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.
func (this TimelineSuccessfulAuthenticationEvent) GetDeviceType() *string { return this.DeviceType }

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineSuccessfulAuthenticationEvent) GetEndTime() string { return this.EndTime }

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.
func (this TimelineSuccessfulAuthenticationEvent) GetEndpointDisplayName() *string {
	return this.EndpointDisplayName
}

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.
func (this TimelineSuccessfulAuthenticationEvent) GetEndpointEntity() *EndpointEntity {
	return this.EndpointEntity
}

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineSuccessfulAuthenticationEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineSuccessfulAuthenticationEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineSuccessfulAuthenticationEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineSuccessfulAuthenticationEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// The geolocation associated with the activity, if any.
func (this TimelineSuccessfulAuthenticationEvent) GetGeoLocation() *GeoLocation {
	return this.GeoLocation
}

// The origin endpoint host name.
func (this TimelineSuccessfulAuthenticationEvent) GetHostName() *string { return this.HostName }

// The origin endpoint IP address, if available.
func (this TimelineSuccessfulAuthenticationEvent) GetIPAddress() *string { return this.IPAddress }
func (this TimelineSuccessfulAuthenticationEvent) GetIPAddressReputations() []IPReputation {
	if this.IPAddressReputations == nil {
		return nil
	}
	interfaceSlice := make([]IPReputation, 0, len(this.IPAddressReputations))
	for _, concrete := range this.IPAddressReputations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineSuccessfulAuthenticationEvent) GetIspClassification() *IspClassification {
	return this.IspClassification
}
func (this TimelineSuccessfulAuthenticationEvent) GetIspDomain() *string { return this.IspDomain }

// The list of Kerberos encryption types specified by the client. Only set for
// activities performed over the Kerberos protocol (see `protocolType`),
func (this TimelineSuccessfulAuthenticationEvent) GetKerberosEncryptionTypes() []KerberosEncryptionType {
	if this.KerberosEncryptionTypes == nil {
		return nil
	}
	interfaceSlice := make([]KerberosEncryptionType, 0, len(this.KerberosEncryptionTypes))
	for _, concrete := range this.KerberosEncryptionTypes {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this TimelineSuccessfulAuthenticationEvent) GetLdapSecurityType() *LdapSecurityType {
	return this.LdapSecurityType
}

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.
func (this TimelineSuccessfulAuthenticationEvent) GetLocationAssociatedWithUser() *bool {
	return this.LocationAssociatedWithUser
}

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineSuccessfulAuthenticationEvent) GetNetworkTag() *string { return this.NetworkTag }

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.
func (this TimelineSuccessfulAuthenticationEvent) GetNetworkType() NetworkType {
	return this.NetworkType
}

// Information about the origin endpoint operating system.
func (this TimelineSuccessfulAuthenticationEvent) GetOperatingSystemInfo() *OperatingSystemInfo {
	return this.OperatingSystemInfo
}

// The primary network protocol used for performing the activity.
func (this TimelineSuccessfulAuthenticationEvent) GetProtocolType() ProtocolType {
	return this.ProtocolType
}
func (this TimelineSuccessfulAuthenticationEvent) GetProtocolVersion() *string {
	return this.ProtocolVersion
}

// A connection of related events.
func (this TimelineSuccessfulAuthenticationEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}
func (this TimelineSuccessfulAuthenticationEvent) GetSmbDialect() *SmbDialect { return this.SmbDialect }
func (this TimelineSuccessfulAuthenticationEvent) GetSourceEntity() UserOrEndpointEntity {
	return this.SourceEntity
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineSuccessfulAuthenticationEvent) GetStartTime() string { return this.StartTime }

// The target endpoint associated with this activity (such as a domain controller), if any.
func (this TimelineSuccessfulAuthenticationEvent) GetTargetEndpointEntity() *EndpointEntity {
	return this.TargetEndpointEntity
}

// The target service entity.
func (this TimelineSuccessfulAuthenticationEvent) GetTargetEntity() Entity { return this.TargetEntity }
func (this TimelineSuccessfulAuthenticationEvent) GetTargetServiceDescription() *string {
	return this.TargetServiceDescription
}
func (this TimelineSuccessfulAuthenticationEvent) GetTargetServiceDisplayName() *string {
	return this.TargetServiceDisplayName
}

// The target service raw identifier.
func (this TimelineSuccessfulAuthenticationEvent) GetTargetServiceIdentifier() *string {
	return this.TargetServiceIdentifier
}

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).
func (this TimelineSuccessfulAuthenticationEvent) GetTargetServiceType() *ServiceType {
	return this.TargetServiceType
}

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineSuccessfulAuthenticationEvent) GetTimestamp() string       { return this.Timestamp }
func (this TimelineSuccessfulAuthenticationEvent) GetTLSVersion() *TLSVersion { return this.TLSVersion }

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.
func (this TimelineSuccessfulAuthenticationEvent) GetUserDisplayName() string {
	return this.UserDisplayName
}

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.
func (this TimelineSuccessfulAuthenticationEvent) GetUserEntity() *UserEntity { return this.UserEntity }

func (TimelineSuccessfulAuthenticationEvent) IsTimelineUserOnEndpointActivityEvent() {}

// If the activity is known to have occurred within an Active Directory site, this is set to the site's name.

// The data source associated with this activity. Because the `DataSource`
// enumeration contains some fallback values for generic sources,
// `dataSourceVendorName` is provided as an alternative.

// A display-oriented label for the data source associated with the activity.

// A display-oriented label reflecting the origin endpoint operating system, as
// exposed by the `operatingSystemInfo` field. The semantics of this value are
// not rrigorously restricted.
// Therefore, the data is supposed to used programmatically, it is always
// recommended to project the underlying `operatingSystemInfo` field instead.

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A display-oriented label reflecting the best available display name for the
// origin endpoint. `EndpointEntity:primaryDisplayName` is used if available,
// otherwise either `hostName` or `ipAddress` may be used as a fallback option.

// The origin endpoint entity associated with the activity, if available. Note
// that `endpointDisplayName` is available even when the entity is unknown.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// The geolocation associated with the activity, if any.

// The origin endpoint host name.

// The origin endpoint IP address, if available.

// If `true`, `userEntity` is associated with `geoLocation` by a `BindingType:GEO_LOCATION` `association`.
//
// Returns `null` if no location data is available for this activity or if the
// user associated with this activity couldn't be correlated with a user entity.

// The subnet label, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.

// The subnet type, as defined in the system configuration, associated with the
// origin endpoint IP address at the time the activity was performed.

// Information about the origin endpoint operating system.

// The primary network protocol used for performing the activity.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The target endpoint associated with this activity (such as a domain controller), if any.

// The target service entity.

// The target service raw identifier.

// A classification value of the service accessed, based on the raw identifier
// (`targetServiceIdentifier`) and the target entity (`targetServiceEntity`).

// The event start time. This is the primary sort-key in `timeline` queries.

// A display-oriented label of the best available display name for the user
// associated with this event. `UserEntity:primaryDisplayName` is used if
// available. Otherwise, the raw user identifier used for performing this
// activity is applied.

// The user entity associated with the activity, if available. Note that
// `userDisplayName` is available even when the entity is unknown.

func (TimelineSuccessfulAuthenticationEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A common interface for all events exposed by the `timeline` API.
type TimelineToolDeletedEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	Name      string            `json:"name"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime       string          `json:"startTime"`
	SystemComponent SystemComponent `json:"systemComponent"`
	SystemUser      *SystemUser     `json:"systemUser,omitempty"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineToolDeletedEvent) IsTimelineSystemConfigurationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineToolDeletedEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineToolDeletedEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineToolDeletedEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineToolDeletedEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineToolDeletedEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineToolDeletedEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineToolDeletedEvent) GetStartTime() string { return this.StartTime }
func (this TimelineToolDeletedEvent) GetSystemComponent() SystemComponent {
	return this.SystemComponent
}
func (this TimelineToolDeletedEvent) GetSystemUser() *SystemUser { return this.SystemUser }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineToolDeletedEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineToolDeletedEvent) IsTimelineAuditEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineToolDeletedEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `TimelineEvent` interface common to system notification `timeline` events.
type TimelineToolFailureEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// Information regarding the error.
	ErrorDetails ErrorDetails `json:"errorDetails"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	Name      string            `json:"name"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineToolFailureEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineToolFailureEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineToolFailureEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineToolFailureEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineToolFailureEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineToolFailureEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineToolFailureEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineToolFailureEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineToolFailureEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineToolFailureEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineToolFailureEvent) IsTimelineErrorEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// Information regarding the error.
func (this TimelineToolFailureEvent) GetErrorDetails() ErrorDetails { return this.ErrorDetails }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineToolFailureEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event type indicating a potential coverage issue for some domain controller traffic.
type TimelineUncoveredDomainControllerEvent struct {
	// The domain controller's domain.
	Domain string `json:"domain"`
	// The domain controller entity.
	DomainControllerEntity *EndpointEntity `json:"domainControllerEntity"`
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The system notification status.
	State *NotificationState `json:"state"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineUncoveredDomainControllerEvent) IsTimelineDomainControllerNotificationEvent() {}

// The domain controller entity.
func (this TimelineUncoveredDomainControllerEvent) GetDomainControllerEntity() *EndpointEntity {
	return this.DomainControllerEntity
}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineUncoveredDomainControllerEvent) GetEndTime() string { return this.EndTime }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineUncoveredDomainControllerEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineUncoveredDomainControllerEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineUncoveredDomainControllerEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineUncoveredDomainControllerEvent) GetEventType() TimelineEventType {
	return this.EventType
}

// A connection of related events.
func (this TimelineUncoveredDomainControllerEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineUncoveredDomainControllerEvent) GetStartTime() string { return this.StartTime }

// The system notification status.
func (this TimelineUncoveredDomainControllerEvent) GetState() *NotificationState { return this.State }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineUncoveredDomainControllerEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineUncoveredDomainControllerEvent) IsTimelineNotificationEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The system notification status.

// The event start time. This is the primary sort-key in `timeline` queries.

func (TimelineUncoveredDomainControllerEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

// A `timeline` event indicating that the system has detected a weak password set for some user.
type TimelineWeakPasswordEvent struct {
	// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
	EndTime string `json:"endTime"`
	// The `Entity` associated with this event.
	Entity Entity `json:"entity"`
	// A unique identifier for the event. The event ID can later be used either to
	// re-fetch the event or to query related events using the  `relatedTo`
	// `timeline` query argument.
	EventID string `json:"eventId"`
	// The display name for the event. This is typically based on the event type, but
	// may also depend on additional data, such as the event data source. There are
	// no strict guidelines for the semantics or structure of this value for each
	// event type, and they may change at any time. **This is merely a display value
	// and it should be treated as such. For programmatic purposes, always prefer the
	// raw data fields.**
	EventLabel string `json:"eventLabel"`
	// The event severity. Defaults to `NEUTRAL`.
	EventSeverity TimelineEventSeverity `json:"eventSeverity"`
	// The event type.
	EventType TimelineEventType `json:"eventType"`
	// A connection of related events.
	RelatedEvents *TimelineEventConnection `json:"relatedEvents,omitempty"`
	// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
	StartTime string `json:"startTime"`
	// The event start time. This is the primary sort-key in `timeline` queries.
	Timestamp string `json:"timestamp"`
}

func (TimelineWeakPasswordEvent) IsTimelineEntityEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.
func (this TimelineWeakPasswordEvent) GetEndTime() string { return this.EndTime }

// The `Entity` associated with this event.
func (this TimelineWeakPasswordEvent) GetEntity() Entity { return this.Entity }

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.
func (this TimelineWeakPasswordEvent) GetEventID() string { return this.EventID }

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**
func (this TimelineWeakPasswordEvent) GetEventLabel() string { return this.EventLabel }

// The event severity. Defaults to `NEUTRAL`.
func (this TimelineWeakPasswordEvent) GetEventSeverity() TimelineEventSeverity {
	return this.EventSeverity
}

// The event type.
func (this TimelineWeakPasswordEvent) GetEventType() TimelineEventType { return this.EventType }

// A connection of related events.
func (this TimelineWeakPasswordEvent) GetRelatedEvents() *TimelineEventConnection {
	return this.RelatedEvents
}

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.
func (this TimelineWeakPasswordEvent) GetStartTime() string { return this.StartTime }

// The event start time. This is the primary sort-key in `timeline` queries.
func (this TimelineWeakPasswordEvent) GetTimestamp() string { return this.Timestamp }

func (TimelineWeakPasswordEvent) IsTimelineEvent() {}

// The event end time. For non-continuous events, its value is identical with `startTime` and `timestamp`.

// A unique identifier for the event. The event ID can later be used either to
// re-fetch the event or to query related events using the  `relatedTo`
// `timeline` query argument.

// The display name for the event. This is typically based on the event type, but
// may also depend on additional data, such as the event data source. There are
// no strict guidelines for the semantics or structure of this value for each
// event type, and they may change at any time. **This is merely a display value
// and it should be treated as such. For programmatic purposes, always prefer the
// raw data fields.**

// The event severity. Defaults to `NEUTRAL`.

// The event type.

// A connection of related events.

// An alias for the `timestamp` field. Use it in conjunction with `endTime` for continuous events.

// The event start time. This is the primary sort-key in `timeline` queries.

type TrafficInspectionExclusionListInput struct {
	IP       string                                  `json:"ip"`
	Port     *int                                    `json:"port,omitempty"`
	Protocol *TrafficInspectionExclusionListProtocol `json:"protocol,omitempty"`
}

type UnconstrainedServiceDelegationAdminRole struct {
	AffectedEntities                 []Entity       `json:"affectedEntities"`
	AuthorizingContainingEntitiesIds []string       `json:"authorizingContainingEntitiesIds"`
	AuthorizingGroupIds              []string       `json:"authorizingGroupIds"`
	Builtin                          bool           `json:"builtin"`
	Confirmed                        bool           `json:"confirmed"`
	EffectedEntityIds                []string       `json:"effectedEntityIds,omitempty"`
	FullPath                         *string        `json:"fullPath,omitempty"`
	Probability                      *float64       `json:"probability,omitempty"`
	Type                             EntityRoleType `json:"type"`
}

func (UnconstrainedServiceDelegationAdminRole) IsServiceDelegationAdminRole() {}
func (this UnconstrainedServiceDelegationAdminRole) GetAffectedEntities() []Entity {
	if this.AffectedEntities == nil {
		return nil
	}
	interfaceSlice := make([]Entity, 0, len(this.AffectedEntities))
	for _, concrete := range this.AffectedEntities {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this UnconstrainedServiceDelegationAdminRole) GetAuthorizingContainingEntitiesIds() []string {
	if this.AuthorizingContainingEntitiesIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingContainingEntitiesIds))
	for _, concrete := range this.AuthorizingContainingEntitiesIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this UnconstrainedServiceDelegationAdminRole) GetAuthorizingGroupIds() []string {
	if this.AuthorizingGroupIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.AuthorizingGroupIds))
	for _, concrete := range this.AuthorizingGroupIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this UnconstrainedServiceDelegationAdminRole) GetBuiltin() bool   { return this.Builtin }
func (this UnconstrainedServiceDelegationAdminRole) GetConfirmed() bool { return this.Confirmed }
func (this UnconstrainedServiceDelegationAdminRole) GetEffectedEntityIds() []string {
	if this.EffectedEntityIds == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.EffectedEntityIds))
	for _, concrete := range this.EffectedEntityIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this UnconstrainedServiceDelegationAdminRole) GetFullPath() *string { return this.FullPath }
func (this UnconstrainedServiceDelegationAdminRole) GetProbability() *float64 {
	return this.Probability
}
func (this UnconstrainedServiceDelegationAdminRole) GetType() EntityRoleType { return this.Type }

func (UnconstrainedServiceDelegationAdminRole) IsEffectiveAdminRole() {}

func (UnconstrainedServiceDelegationAdminRole) IsAdminAccountRole() {}

func (UnconstrainedServiceDelegationAdminRole) IsEntityRole() {}

// A specialized `Entity` interface for users, used when `Entity:type` is `USER`.
//
// Bear in mind that the entity type, as opposed to its classification, is a
// structural attribute. If you wish to differentiate between human and
// programmatic user entities, check their classification (see `roles` field).
type UserEntity struct {
	// A list of external, elementary account descriptors used to construct this
	// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
	// domain entry and an IDAAS account will include
	// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
	Accounts []AccountDescriptor `json:"accounts"`
	// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
	//
	// For entities derived with external data sources, such as LDAP users, an entity
	// is considered archived if its primary account (see `Entity:primaryAccount` is
	// deleted. Entities not associated with any external sources, such as unmanaged
	// endpoints, may also be archived based on a long period of inactivity. Except
	// the `archived` attribute itself, no other attribute of an archived entity is
	// updated. The attributes of an archived entity represent the state of the
	// entity at the time when it was archived.
	Archived bool `json:"archived"`
	// A list of associations of various types (see `Association:bindingType`) that
	// this entity has with other objects, most commonly with other entities. For
	// example, a `UserEntity` may have an `OWNERSHIP` association with an
	// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
	// The semantics for each association type are detailed in `BindingType`.
	Associations     []Association `json:"associations"`
	AuthorizerEntity *UserEntity   `json:"authorizerEntity,omitempty"`
	CreationTime     string        `json:"creationTime"`
	// The date and time of the entity's earliest recorded network activity. This
	// takes into account both the data reported by external sources and the actual
	// traffic seen by the system.
	EarliestSeenTraffic *string `json:"earliestSeenTraffic,omitempty"`
	// The list of unique email addresses available for this entity from all known data sources.
	EmailAddresses []string `json:"emailAddresses"`
	// The entity's unique identifier.
	EntityID             string `json:"entityId"`
	HasADDomainAdminRole *bool  `json:"hasADDomainAdminRole,omitempty"`
	// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
	//
	// ```graphql
	// {
	//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
	//   {
	//     nodes
	//     {
	//       type
	//       primaryDisplayName
	//       ... on UserEntity
	//       {
	//         isHuman: hasRole(type: HumanUserAccountRole)
	//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
	//         isAdmin: hasRole(type: AdminAccountRole)
	//       }
	//       ... on EndpointEntity
	//       {
	//         isWorkstation: hasRole(type: WorkstationRole)
	//         isServer: hasRole(type: WorkstationRole)
	//       }
	//       isManuallyClassified: hasRole(confirmed: true)
	//     }
	//   }
	// }
	// ```
	HasRole *bool `json:"hasRole,omitempty"`
	// The latest calculated impact score for this entity.
	ImpactScore string `json:"impactScore"`
	// If `true`, the entity is inactive. An entity is considered inactive after 21
	// days since its latest recorded network activity (see `mostRecentActivity`).
	Inactive bool `json:"inactive"`
	// If `true`, the system has gathered enough information to consider this entity *learned*.
	Learned          bool      `json:"learned"`
	LinkedAccountIds []*string `json:"linkedAccountIds,omitempty"`
	// For marked entities, this is set to the last time the entity was marked.
	MarkTime *string `json:"markTime,omitempty"`
	// The date and time of the entity's latest recorded network activity. This takes
	// into account both the data reported by external sources and the actual traffic
	// seen by the system.
	MostRecentActivity *string `json:"mostRecentActivity,omitempty"`
	// Query open incidents for this entity.
	OpenIncidents *IncidentConnection `json:"openIncidents,omitempty"`
	// The primary display name representing this user in user-facing data. This is
	// derived from the explicit display name or an analogous attribute of the user's
	// primary account.
	PrimaryDisplayName string `json:"primaryDisplayName"`
	// A list of risk factors contributing to the overall risk of this entity, sorted
	// by `RiskFactorContribution:score` in descending order.
	RiskFactors []EntityRiskFactor `json:"riskFactors"`
	// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
	RiskScore string `json:"riskScore"`
	// The entity's risk score derived from `riskScore`.
	RiskScoreSeverity              ScoreSeverity `json:"riskScoreSeverity"`
	RiskScoreWithoutLinkedAccounts string        `json:"riskScoreWithoutLinkedAccounts"`
	// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
	//
	// For example, a `UserEntity` representing an *account operator* in an Active
	// Directory domain should have an `AccountOperatorsAdminRole` entry on this
	// list. Should the system later learn this privileged account is used by a
	// script rather than a human, its associated entity will also have a
	// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
	// `EndpointEntity` belongs to a VDI cluster, it tags it with a
	// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
	// aforementioned `AccountOperatorsAdminRole` is a specialization of
	// `OperatorLevelAdminRole`, which by itself is a specialization of
	// `AdminAccountRole`.
	//
	// When roles are queried, this hierarchy is always taken into account.
	// Therefore, querying an entity about the existence of a role also implies that
	// all of its direct and indirect specializations will be queried too. This
	// hierarchy is completely reflected by GraphQL inheritance. For instance, you
	// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
	// that the latter implements `ServerRole`.
	//
	// For your convenience, `EntityRole:fullPath` can be projected on the role
	// itself, reperesenting the role type ancestry as breadcrumbs. See
	// `EntityRoleType` for query examples.
	Roles []EntityRole `json:"roles,omitempty"`
	// The secondary display name is used to represent unique name for this entity in the organization or the network.
	SecondaryDisplayName string `json:"secondaryDisplayName"`
	// Returns `true` if the system considers this entity shared.
	Shared bool `json:"shared"`
	// If `true`, the entity is stale. An entity is considered stale after 90 days of
	// inactivity (see `mostRecentActivity`), as long as it is still effectively part
	// of the network. An account-based entity is not considered part of the network
	// when all of its base accounts are disabled (see `primaryAccount` and
	// `secondaryAccounts`).
	Stale bool `json:"stale"`
	// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
	Type EntityType `json:"type"`
	// If `true`, this entity appears on the system watchlist.
	Watched bool `json:"watched"`
}

func (UserEntity) IsUserOrEndpointEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.
func (this UserEntity) GetAccounts() []AccountDescriptor {
	if this.Accounts == nil {
		return nil
	}
	interfaceSlice := make([]AccountDescriptor, 0, len(this.Accounts))
	for _, concrete := range this.Accounts {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.
func (this UserEntity) GetArchived() bool { return this.Archived }

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.
func (this UserEntity) GetAssociations() []Association {
	if this.Associations == nil {
		return nil
	}
	interfaceSlice := make([]Association, 0, len(this.Associations))
	for _, concrete := range this.Associations {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this UserEntity) GetCreationTime() string { return this.CreationTime }

// The date and time of the entity's earliest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.
func (this UserEntity) GetEarliestSeenTraffic() *string { return this.EarliestSeenTraffic }

// The entity's unique identifier.
func (this UserEntity) GetEntityID() string            { return this.EntityID }
func (this UserEntity) GetHasADDomainAdminRole() *bool { return this.HasADDomainAdminRole }

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
//
//	{
//	  entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//	  {
//	    nodes
//	    {
//	      type
//	      primaryDisplayName
//	      ... on UserEntity
//	      {
//	        isHuman: hasRole(type: HumanUserAccountRole)
//	        isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//	        isAdmin: hasRole(type: AdminAccountRole)
//	      }
//	      ... on EndpointEntity
//	      {
//	        isWorkstation: hasRole(type: WorkstationRole)
//	        isServer: hasRole(type: WorkstationRole)
//	      }
//	      isManuallyClassified: hasRole(confirmed: true)
//	    }
//	  }
//	}
//
// ```
func (this UserEntity) GetHasRole() *bool { return this.HasRole }

// The latest calculated impact score for this entity.
func (this UserEntity) GetImpactScore() string { return this.ImpactScore }

// If `true`, the entity is inactive. An entity is considered inactive after 21
// days since its latest recorded network activity (see `mostRecentActivity`).
func (this UserEntity) GetInactive() bool { return this.Inactive }

// If `true`, the system has gathered enough information to consider this entity *learned*.
func (this UserEntity) GetLearned() bool { return this.Learned }

// For marked entities, this is set to the last time the entity was marked.
func (this UserEntity) GetMarkTime() *string { return this.MarkTime }

// The date and time of the entity's latest recorded network activity. This takes
// into account both the data reported by external sources and the actual traffic
// seen by the system.
func (this UserEntity) GetMostRecentActivity() *string { return this.MostRecentActivity }

// Query open incidents for this entity.
func (this UserEntity) GetOpenIncidents() *IncidentConnection { return this.OpenIncidents }

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.
func (this UserEntity) GetPrimaryDisplayName() string { return this.PrimaryDisplayName }

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.
func (this UserEntity) GetRiskFactors() []EntityRiskFactor {
	if this.RiskFactors == nil {
		return nil
	}
	interfaceSlice := make([]EntityRiskFactor, 0, len(this.RiskFactors))
	for _, concrete := range this.RiskFactors {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).
func (this UserEntity) GetRiskScore() string { return this.RiskScore }

// The entity's risk score derived from `riskScore`.
func (this UserEntity) GetRiskScoreSeverity() ScoreSeverity { return this.RiskScoreSeverity }

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.
func (this UserEntity) GetRoles() []EntityRole {
	if this.Roles == nil {
		return nil
	}
	interfaceSlice := make([]EntityRole, 0, len(this.Roles))
	for _, concrete := range this.Roles {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

// The secondary display name is used to represent unique name for this entity in the organization or the network.
func (this UserEntity) GetSecondaryDisplayName() string { return this.SecondaryDisplayName }

// Returns `true` if the system considers this entity shared.
func (this UserEntity) GetShared() bool { return this.Shared }

// If `true`, the entity is stale. An entity is considered stale after 90 days of
// inactivity (see `mostRecentActivity`), as long as it is still effectively part
// of the network. An account-based entity is not considered part of the network
// when all of its base accounts are disabled (see `primaryAccount` and
// `secondaryAccounts`).
func (this UserEntity) GetStale() bool { return this.Stale }

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).
func (this UserEntity) GetType() EntityType { return this.Type }

// If `true`, this entity appears on the system watchlist.
func (this UserEntity) GetWatched() bool { return this.Watched }

func (UserEntity) IsActivityParticipatingEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.

// The date and time of the entity's earliest recorded network activity. This
// takes into account both the data reported by external sources and the actual
// traffic seen by the system.

// The entity's unique identifier.

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
// {
//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//   {
//     nodes
//     {
//       type
//       primaryDisplayName
//       ... on UserEntity
//       {
//         isHuman: hasRole(type: HumanUserAccountRole)
//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//         isAdmin: hasRole(type: AdminAccountRole)
//       }
//       ... on EndpointEntity
//       {
//         isWorkstation: hasRole(type: WorkstationRole)
//         isServer: hasRole(type: WorkstationRole)
//       }
//       isManuallyClassified: hasRole(confirmed: true)
//     }
//   }
// }
// ```

// If `true`, the entity is inactive. An entity is considered inactive after 21
// days since its latest recorded network activity (see `mostRecentActivity`).

// If `true`, the system has gathered enough information to consider this entity *learned*.

// For marked entities, this is set to the last time the entity was marked.

// The date and time of the entity's latest recorded network activity. This takes
// into account both the data reported by external sources and the actual traffic
// seen by the system.

// Query open incidents for this entity.

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).

// The entity's risk score derived from `riskScore`.

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.

// The secondary display name is used to represent unique name for this entity in the organization or the network.

// If `true`, the entity is stale. An entity is considered stale after 90 days of
// inactivity (see `mostRecentActivity`), as long as it is still effectively part
// of the network. An account-based entity is not considered part of the network
// when all of its base accounts are disabled (see `primaryAccount` and
// `secondaryAccounts`).

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).

// If `true`, this entity appears on the system watchlist.

func (UserEntity) IsEntity() {}

// A list of external, elementary account descriptors used to construct this
// entity. For instance, the list for a `UserEntity` which is backed by an LDAP
// domain entry and an IDAAS account will include
// `ActiveDirectoryAccountDescriptor` and `SsoUserAccountDescriptor` entries.

// If `true`, the system considers this entity *archived*. It means that the entity no longer exists and can only be viewed.
//
// For entities derived with external data sources, such as LDAP users, an entity
// is considered archived if its primary account (see `Entity:primaryAccount` is
// deleted. Entities not associated with any external sources, such as unmanaged
// endpoints, may also be archived based on a long period of inactivity. Except
// the `archived` attribute itself, no other attribute of an archived entity is
// updated. The attributes of an archived entity represent the state of the
// entity at the time when it was archived.

// A list of associations of various types (see `Association:bindingType`) that
// this entity has with other objects, most commonly with other entities. For
// example, a `UserEntity` may have an `OWNERSHIP` association with an
// `EndpointEntity`, alongside a `GEO_LOCATION` association with a `GeoLocation`.
// The semantics for each association type are detailed in `BindingType`.

// The entity's unique identifier.

// A convenience function that checks the `roles` field for the existence of at least one role matching the criteria.
//
// ```graphql
// {
//   entities(minRiskScoreSeverity: MEDIUM, archived: false, first: 5)
//   {
//     nodes
//     {
//       type
//       primaryDisplayName
//       ... on UserEntity
//       {
//         isHuman: hasRole(type: HumanUserAccountRole)
//         isProgrammatic: hasRole(type: ProgrammaticUserAccountRole)
//         isAdmin: hasRole(type: AdminAccountRole)
//       }
//       ... on EndpointEntity
//       {
//         isWorkstation: hasRole(type: WorkstationRole)
//         isServer: hasRole(type: WorkstationRole)
//       }
//       isManuallyClassified: hasRole(confirmed: true)
//     }
//   }
// }
// ```

// If `true`, the system has gathered enough information to consider this entity *learned*.

// For marked entities, this is set to the last time the entity was marked.

// Query open incidents for this entity.

// The primary display name used to represent this entity in user-facing data.
//
// The primary display name is typically shorter than the secondary display name,
// but is much less likely to be unique across the organization or network. For
// further details on the semantics, see the documentation for specific types.

// A list of risk factors contributing to the overall risk of this entity, sorted
// by `RiskFactorContribution:score` in descending order.

// The entity's risk score represented as a number from 0 (no or unknown risk) through 1 (maximum risk).

// The entity's risk score derived from `riskScore`.

// A list of roles fulfilled by this entity, each defining the entity's classification or organizational-function aspect.
//
// For example, a `UserEntity` representing an *account operator* in an Active
// Directory domain should have an `AccountOperatorsAdminRole` entry on this
// list. Should the system later learn this privileged account is used by a
// script rather than a human, its associated entity will also have a
// `ProgrammaticUserAccountRole`. Similarly, when the system learns that some
// `EndpointEntity` belongs to a VDI cluster, it tags it with a
// `VdiEndpointRole`.The model for roles is hierarchical. For example, the
// aforementioned `AccountOperatorsAdminRole` is a specialization of
// `OperatorLevelAdminRole`, which by itself is a specialization of
// `AdminAccountRole`.
//
// When roles are queried, this hierarchy is always taken into account.
// Therefore, querying an entity about the existence of a role also implies that
// all of its direct and indirect specializations will be queried too. This
// hierarchy is completely reflected by GraphQL inheritance. For instance, you
// can see that `ExchangeServerRole` implements `ApplicationServerRole`,  and
// that the latter implements `ServerRole`.
//
// For your convenience, `EntityRole:fullPath` can be projected on the role
// itself, reperesenting the role type ancestry as breadcrumbs. See
// `EntityRoleType` for query examples.

// The secondary display name is used to represent unique name for this entity in the organization or the network.

// The entity type, which also determines the specialized Entity subclass to be returned (see `EntityType`).

// If `true`, this entity appears on the system watchlist.

type UsesLocallyAdministratedMachinesRiskFactor struct {
	LocallyAdministratedMachines []*EndpointEntity `json:"locallyAdministratedMachines"`
	Score                        string            `json:"score"`
	Severity                     ScoreSeverity     `json:"severity"`
	Type                         RiskFactorType    `json:"type"`
}

func (UsesLocallyAdministratedMachinesRiskFactor) IsEntityRiskFactor()   {}
func (this UsesLocallyAdministratedMachinesRiskFactor) GetScore() string { return this.Score }
func (this UsesLocallyAdministratedMachinesRiskFactor) GetSeverity() ScoreSeverity {
	return this.Severity
}
func (this UsesLocallyAdministratedMachinesRiskFactor) GetType() RiskFactorType { return this.Type }

type VdiEndpointRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (VdiEndpointRole) IsClassificationRole()         {}
func (this VdiEndpointRole) GetConfirmed() bool       { return this.Confirmed }
func (this VdiEndpointRole) GetFullPath() *string     { return this.FullPath }
func (this VdiEndpointRole) GetProbability() *float64 { return this.Probability }
func (this VdiEndpointRole) GetType() EntityRoleType  { return this.Type }

func (VdiEndpointRole) IsEntityRole() {}

type WorkstationRole struct {
	Confirmed   bool           `json:"confirmed"`
	FullPath    *string        `json:"fullPath,omitempty"`
	Probability *float64       `json:"probability,omitempty"`
	Type        EntityRoleType `json:"type"`
}

func (WorkstationRole) IsClassificationRole()         {}
func (this WorkstationRole) GetConfirmed() bool       { return this.Confirmed }
func (this WorkstationRole) GetFullPath() *string     { return this.FullPath }
func (this WorkstationRole) GetProbability() *float64 { return this.Probability }
func (this WorkstationRole) GetType() EntityRoleType  { return this.Type }

func (WorkstationRole) IsEntityRole() {}

type ActiveDirectoryGroupScope string

const (
	ActiveDirectoryGroupScopeUniversal   ActiveDirectoryGroupScope = "Universal"
	ActiveDirectoryGroupScopeGlobal      ActiveDirectoryGroupScope = "Global"
	ActiveDirectoryGroupScopeDomainLocal ActiveDirectoryGroupScope = "DomainLocal"
)

var AllActiveDirectoryGroupScope = []ActiveDirectoryGroupScope{
	ActiveDirectoryGroupScopeUniversal,
	ActiveDirectoryGroupScopeGlobal,
	ActiveDirectoryGroupScopeDomainLocal,
}

func (e ActiveDirectoryGroupScope) IsValid() bool {
	switch e {
	case ActiveDirectoryGroupScopeUniversal, ActiveDirectoryGroupScopeGlobal, ActiveDirectoryGroupScopeDomainLocal:
		return true
	}
	return false
}

func (e ActiveDirectoryGroupScope) String() string {
	return string(e)
}

func (e *ActiveDirectoryGroupScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActiveDirectoryGroupScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActiveDirectoryGroupScope", str)
	}
	return nil
}

func (e ActiveDirectoryGroupScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ActiveDirectoryPasswordPolicySourceType string

const (
	ActiveDirectoryPasswordPolicySourceTypeDomainPolicy      ActiveDirectoryPasswordPolicySourceType = "DOMAIN_POLICY"
	ActiveDirectoryPasswordPolicySourceTypeFineGrainedPolicy ActiveDirectoryPasswordPolicySourceType = "FINE_GRAINED_POLICY"
	ActiveDirectoryPasswordPolicySourceTypeUnknown           ActiveDirectoryPasswordPolicySourceType = "UNKNOWN"
)

var AllActiveDirectoryPasswordPolicySourceType = []ActiveDirectoryPasswordPolicySourceType{
	ActiveDirectoryPasswordPolicySourceTypeDomainPolicy,
	ActiveDirectoryPasswordPolicySourceTypeFineGrainedPolicy,
	ActiveDirectoryPasswordPolicySourceTypeUnknown,
}

func (e ActiveDirectoryPasswordPolicySourceType) IsValid() bool {
	switch e {
	case ActiveDirectoryPasswordPolicySourceTypeDomainPolicy, ActiveDirectoryPasswordPolicySourceTypeFineGrainedPolicy, ActiveDirectoryPasswordPolicySourceTypeUnknown:
		return true
	}
	return false
}

func (e ActiveDirectoryPasswordPolicySourceType) String() string {
	return string(e)
}

func (e *ActiveDirectoryPasswordPolicySourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActiveDirectoryPasswordPolicySourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActiveDirectoryPasswordPolicySourceType", str)
	}
	return nil
}

func (e ActiveDirectoryPasswordPolicySourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AggressionLevel string

const (
	AggressionLevelMostAggressive    AggressionLevel = "MOST_AGGRESSIVE"
	AggressionLevelDefaultAggression AggressionLevel = "DEFAULT_AGGRESSION"
)

var AllAggressionLevel = []AggressionLevel{
	AggressionLevelMostAggressive,
	AggressionLevelDefaultAggression,
}

func (e AggressionLevel) IsValid() bool {
	switch e {
	case AggressionLevelMostAggressive, AggressionLevelDefaultAggression:
		return true
	}
	return false
}

func (e AggressionLevel) String() string {
	return string(e)
}

func (e *AggressionLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AggressionLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AggressionLevel", str)
	}
	return nil
}

func (e AggressionLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of alert types.
type AlertType string

const (
	// A single end user password was repeatedly entered incorrectly from a machine
	// that is unusual for that end user, until the end user was locked out.
	AlertTypePasswordBruteForceAlert AlertType = "PasswordBruteForceAlert"
	// A ticket has been used for more than ten hours (the default Kerberos ticket validity period).
	AlertTypeGoldenTicketAlert AlertType = "GoldenTicketAlert"
	// An NTLM authentication was captured and redirected to gain access to another resource
	AlertTypeNtlmRelayAlert AlertType = "NtlmRelayAlert"
	// A machine that usually does not perform domain replication has performed a domain replication (DRSUAPI) request.
	AlertTypeDcSyncAlert AlertType = "DcSyncAlert"
	// The user account is being used from a location that is not common to the user
	// and is not common in general in the organizations network.
	AlertTypeGeoLocationAnomalyAlert AlertType = "GeoLocationAnomalyAlert"
	// A task creation RPC request was sent to a domain controller at the same time as an RDP ticket request.
	AlertTypeCredSspVulnerabilityAlert AlertType = "CredSspVulnerabilityAlert"
	// An activity was reported as malicious by an end-user through policy-triggered MFA or Email Verification.
	AlertTypeIdentityVerificationDenyAlert AlertType = "IdentityVerificationDenyAlert"
	// An account was hidden from being enumerated in LDAP.
	AlertTypeHiddenObjectAlert AlertType = "HiddenObjectAlert"
	// An account attempting to access multiple servers or workstations.
	AlertTypeDailyTargetVolumeAnomalyAlert AlertType = "DailyTargetVolumeAnomalyAlert"
	// A new or stale user generates unusual traffic.
	AlertTypeNewEntityAbnormalUsageAlert AlertType = "NewEntityAbnormalUsageAlert"
	// A DCE/RPC command to configure a domain controller was issued, but was never used in the endpoint or network.
	AlertTypeAnomalousRPCAlert AlertType = "AnomalousRpcAlert"
	// An end user accessed the enterprise network/cloud from a blacklisted country
	// or a region or outside the whitelisted regions.
	AlertTypeForbiddenCountryAlert AlertType = "ForbiddenCountryAlert"
	// The user account was used from more than one location in close time proximity
	// where the distance between the locations was greater than theoretical speed of
	// travel between them.
	AlertTypeGeoLocationVelocityAnomalyAlert AlertType = "GeoLocationVelocityAnomalyAlert"
	// A protocol (e.g. NTLM or Kerberos) was used in an abnormal manner consistent
	// with known ubiquitous attack tools, such as Mimikatz or Impacket. Such
	// behavior could indicate that an attack (Pass the Hash,Diamond PAC, etc.) took place.
	AlertTypePassTheHashAlert AlertType = "PassTheHashAlert"
	// An end user account that has not been active in the network for longer than 90 days was used again.
	AlertTypeStaleAccountUsageAlert AlertType = "StaleAccountUsageAlert"
	// Multiple failed authentication attempts in a short time frame from the same machine.
	AlertTypeCredentialScanningAlert AlertType = "CredentialScanningAlert"
	// An end-user accessed a server that they had not previously used. The access
	// was deemed anomalous based on several factors such as server usage (volume,
	// frequency), user role and server access within the user’s peer group.
	AlertTypeNewServerAccessAlert AlertType = "NewServerAccessAlert"
	// Legacy alert type. Unused in new data.
	AlertTypeStaleServiceUsageAlert AlertType = "StaleServiceUsageAlert"
	// An account's credentials were used to authenticate to a machine to which it
	// was not previously connected. The authentication was considered anomalous
	// based on several factors such as machine role and the user role.
	AlertTypeCredentialTheftAlert AlertType = "CredentialTheftAlert"
	// A forged PAC ([MS14-068](https://docs.microsoft.com/en-us/security-updates/securitybulletins/2014/ms14-068)) or a Diamond PAC attack was carried out in the network.
	AlertTypeForgedPacAlert AlertType = "ForgedPacAlert"
	// An end-user account was used to configure a workstation or a server from an unusual machine.
	AlertTypeLateralMovementAlert AlertType = "LateralMovementAlert"
	// The domain controller is rejecting current cryptographic algorithms and supports only RC4.
	AlertTypeSkeletonKeyAlert AlertType = "SkeletonKeyAlert"
	// The user did not respond to an MFA request triggered by a policy rule match.
	AlertTypeIdentityVerificationTimeoutAlert AlertType = "IdentityVerificationTimeoutAlert"
	// An end-user accessed a server that they had not previously used. The access
	// was deemed anomalous based on several factors such as server usage (volume or
	// frequency), the user role and monitored server access within the user’s peer group.
	AlertTypeAbnormalUsageAlert AlertType = "AbnormalUsageAlert"
	// A recognized LDAP search request usually performed by a known attacking tool
	// (e.g. Bloodhound, impacket) was used in the network.
	AlertTypeLdapReconnaissanceAlert AlertType = "LdapReconnaissanceAlert"
	// A Kerberos service ticket generated one one machine was used on another machine.
	AlertTypePassTheTicketAlert AlertType = "PassTheTicketAlert"
	// A life-cycle supportive alert type used for automatic resolution of incidents based on successful identity verification.
	AlertTypeIdentityVerificationApproveAlert AlertType = "IdentityVerificationApproveAlert"
	// An endpoint that was not used in the network for a considerable amount of time was used again.
	AlertTypeStaleHostUsageAlert AlertType = "StaleHostUsageAlert"
	// Generic alert type generated for policy rule matches, if the matched rule is explicitly configured to create alerts.
	AlertTypePolicyRuleMatchAlert AlertType = "PolicyRuleMatchAlert"
	// An account accessed an anomalous number of workstations or servers that
	// exceeds the previous usage volume for that account.
	AlertTypeDailyVolumeAnomalyAlert   AlertType = "DailyVolumeAnomalyAlert"
	AlertTypeRemoteCodeExecutionAlert  AlertType = "RemoteCodeExecutionAlert"
	AlertTypeBadReputationIPUsageAlert AlertType = "BadReputationIpUsageAlert"
	AlertTypeBronzeBitAlert            AlertType = "BronzeBitAlert"
	// The privileges of a user/endpoint/cloud service have been changed
	AlertTypePrivilegeEscalationAlert AlertType = "PrivilegeEscalationAlert"
	// Machine account was modified in a way that indicates potential exploitation of CVE-2021-42287/CVE-2021-42278
	AlertTypeSuspiciousMachineAccountAlterationAlert AlertType = "SuspiciousMachineAccountAlterationAlert"
	// A honeytoken account activity was detected
	AlertTypeHoneytokenActivityAlert AlertType = "HoneytokenActivityAlert"
	// A honeytoken account was altered in a way that can indicate an exploitation attempt
	AlertTypeHoneytokenAlterationAlert AlertType = "HoneytokenAlterationAlert"
	// An unusual certificate-based activity was detected
	AlertTypeAnomalousCertificateBasedActivityAlert AlertType = "AnomalousCertificateBasedActivityAlert"
	// A web-based activity was detected as anomalous by ML model
	AlertTypeSuspiciousCloudActivityMLAlert AlertType = "SuspiciousCloudActivityMLAlert"
)

var AllAlertType = []AlertType{
	AlertTypePasswordBruteForceAlert,
	AlertTypeGoldenTicketAlert,
	AlertTypeNtlmRelayAlert,
	AlertTypeDcSyncAlert,
	AlertTypeGeoLocationAnomalyAlert,
	AlertTypeCredSspVulnerabilityAlert,
	AlertTypeIdentityVerificationDenyAlert,
	AlertTypeHiddenObjectAlert,
	AlertTypeDailyTargetVolumeAnomalyAlert,
	AlertTypeNewEntityAbnormalUsageAlert,
	AlertTypeAnomalousRPCAlert,
	AlertTypeForbiddenCountryAlert,
	AlertTypeGeoLocationVelocityAnomalyAlert,
	AlertTypePassTheHashAlert,
	AlertTypeStaleAccountUsageAlert,
	AlertTypeCredentialScanningAlert,
	AlertTypeNewServerAccessAlert,
	AlertTypeStaleServiceUsageAlert,
	AlertTypeCredentialTheftAlert,
	AlertTypeForgedPacAlert,
	AlertTypeLateralMovementAlert,
	AlertTypeSkeletonKeyAlert,
	AlertTypeIdentityVerificationTimeoutAlert,
	AlertTypeAbnormalUsageAlert,
	AlertTypeLdapReconnaissanceAlert,
	AlertTypePassTheTicketAlert,
	AlertTypeIdentityVerificationApproveAlert,
	AlertTypeStaleHostUsageAlert,
	AlertTypePolicyRuleMatchAlert,
	AlertTypeDailyVolumeAnomalyAlert,
	AlertTypeRemoteCodeExecutionAlert,
	AlertTypeBadReputationIPUsageAlert,
	AlertTypeBronzeBitAlert,
	AlertTypePrivilegeEscalationAlert,
	AlertTypeSuspiciousMachineAccountAlterationAlert,
	AlertTypeHoneytokenActivityAlert,
	AlertTypeHoneytokenAlterationAlert,
	AlertTypeAnomalousCertificateBasedActivityAlert,
	AlertTypeSuspiciousCloudActivityMLAlert,
}

func (e AlertType) IsValid() bool {
	switch e {
	case AlertTypePasswordBruteForceAlert, AlertTypeGoldenTicketAlert, AlertTypeNtlmRelayAlert, AlertTypeDcSyncAlert, AlertTypeGeoLocationAnomalyAlert, AlertTypeCredSspVulnerabilityAlert, AlertTypeIdentityVerificationDenyAlert, AlertTypeHiddenObjectAlert, AlertTypeDailyTargetVolumeAnomalyAlert, AlertTypeNewEntityAbnormalUsageAlert, AlertTypeAnomalousRPCAlert, AlertTypeForbiddenCountryAlert, AlertTypeGeoLocationVelocityAnomalyAlert, AlertTypePassTheHashAlert, AlertTypeStaleAccountUsageAlert, AlertTypeCredentialScanningAlert, AlertTypeNewServerAccessAlert, AlertTypeStaleServiceUsageAlert, AlertTypeCredentialTheftAlert, AlertTypeForgedPacAlert, AlertTypeLateralMovementAlert, AlertTypeSkeletonKeyAlert, AlertTypeIdentityVerificationTimeoutAlert, AlertTypeAbnormalUsageAlert, AlertTypeLdapReconnaissanceAlert, AlertTypePassTheTicketAlert, AlertTypeIdentityVerificationApproveAlert, AlertTypeStaleHostUsageAlert, AlertTypePolicyRuleMatchAlert, AlertTypeDailyVolumeAnomalyAlert, AlertTypeRemoteCodeExecutionAlert, AlertTypeBadReputationIPUsageAlert, AlertTypeBronzeBitAlert, AlertTypePrivilegeEscalationAlert, AlertTypeSuspiciousMachineAccountAlterationAlert, AlertTypeHoneytokenActivityAlert, AlertTypeHoneytokenAlterationAlert, AlertTypeAnomalousCertificateBasedActivityAlert, AlertTypeSuspiciousCloudActivityMLAlert:
		return true
	}
	return false
}

func (e AlertType) String() string {
	return string(e)
}

func (e *AlertType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertType", str)
	}
	return nil
}

func (e AlertType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the Microsoft extended error codes used in their Kerberos implementation.
type ApplicationSpecificError string

const (
	ApplicationSpecificErrorStatusAccountDisabled    ApplicationSpecificError = "STATUS_ACCOUNT_DISABLED"
	ApplicationSpecificErrorStatusAccountExpired     ApplicationSpecificError = "STATUS_ACCOUNT_EXPIRED"
	ApplicationSpecificErrorStatusAccountLockedOut   ApplicationSpecificError = "STATUS_ACCOUNT_LOCKED_OUT"
	ApplicationSpecificErrorStatusInvalidWorkstation ApplicationSpecificError = "STATUS_INVALID_WORKSTATION"
)

var AllApplicationSpecificError = []ApplicationSpecificError{
	ApplicationSpecificErrorStatusAccountDisabled,
	ApplicationSpecificErrorStatusAccountExpired,
	ApplicationSpecificErrorStatusAccountLockedOut,
	ApplicationSpecificErrorStatusInvalidWorkstation,
}

func (e ApplicationSpecificError) IsValid() bool {
	switch e {
	case ApplicationSpecificErrorStatusAccountDisabled, ApplicationSpecificErrorStatusAccountExpired, ApplicationSpecificErrorStatusAccountLockedOut, ApplicationSpecificErrorStatusInvalidWorkstation:
		return true
	}
	return false
}

func (e ApplicationSpecificError) String() string {
	return string(e)
}

func (e *ApplicationSpecificError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationSpecificError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationSpecificError", str)
	}
	return nil
}

func (e ApplicationSpecificError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AttackPathRelation string

const (
	AttackPathRelationAdmin                                            AttackPathRelation = "ADMIN"
	AttackPathRelationPasswordResetter                                 AttackPathRelation = "PASSWORD_RESETTER"
	AttackPathRelationAllowedToAddToGroup                              AttackPathRelation = "ALLOWED_TO_ADD_TO_GROUP"
	AttackPathRelationAllowedToModifyPermissions                       AttackPathRelation = "ALLOWED_TO_MODIFY_PERMISSIONS"
	AttackPathRelationInGroup                                          AttackPathRelation = "IN_GROUP"
	AttackPathRelationLoggedOnToEp                                     AttackPathRelation = "LOGGED_ON_TO_EP"
	AttackPathRelationLocalAdmin                                       AttackPathRelation = "LOCAL_ADMIN"
	AttackPathRelationDuplicatedLocalAdmin                             AttackPathRelation = "DUPLICATED_LOCAL_ADMIN"
	AttackPathRelationApplicationOwner                                 AttackPathRelation = "APPLICATION_OWNER"
	AttackPathRelationApplicationController                            AttackPathRelation = "APPLICATION_CONTROLLER"
	AttackPathRelationRoleMember                                       AttackPathRelation = "ROLE_MEMBER"
	AttackPathRelationAdminReplicator                                  AttackPathRelation = "ADMIN_REPLICATOR"
	AttackPathRelationAdminSidTakeover                                 AttackPathRelation = "ADMIN_SID_TAKEOVER"
	AttackPathRelationAdminUnconstrainedSvcDelegation                  AttackPathRelation = "ADMIN_UNCONSTRAINED_SVC_DELEGATION"
	AttackPathRelationAdminConstrainedSvcDelegation                    AttackPathRelation = "ADMIN_CONSTRAINED_SVC_DELEGATION"
	AttackPathRelationAdminAuthenticateAsAnyDomainUserCaTemplate       AttackPathRelation = "ADMIN_AUTHENTICATE_AS_ANY_DOMAIN_USER_CA_TEMPLATE"
	AttackPathRelationAdminAuthenticateAsAnyDomainUserWithRequestAgent AttackPathRelation = "ADMIN_AUTHENTICATE_AS_ANY_DOMAIN_USER_WITH_REQUEST_AGENT"
	AttackPathRelationDuplicatePassword                                AttackPathRelation = "DUPLICATE_PASSWORD"
	AttackPathRelationOwnerAdmin                                       AttackPathRelation = "OWNER_ADMIN"
	AttackPathRelationCaTemplate                                       AttackPathRelation = "CA_TEMPLATE"
	AttackPathRelationAllowedToWriteKeyCredential                      AttackPathRelation = "ALLOWED_TO_WRITE_KEY_CREDENTIAL"
	AttackPathRelationAllowedToWriteOwnerCaTemplate                    AttackPathRelation = "ALLOWED_TO_WRITE_OWNER_CA_TEMPLATE"
	AttackPathRelationAllowedToWriteDaclCaTemplate                     AttackPathRelation = "ALLOWED_TO_WRITE_DACL_CA_TEMPLATE"
	AttackPathRelationAllowedToWritePropertyCaTemplate                 AttackPathRelation = "ALLOWED_TO_WRITE_PROPERTY_CA_TEMPLATE"
	AttackPathRelationAllowedToEnrollCaTemplate                        AttackPathRelation = "ALLOWED_TO_ENROLL_CA_TEMPLATE"
)

var AllAttackPathRelation = []AttackPathRelation{
	AttackPathRelationAdmin,
	AttackPathRelationPasswordResetter,
	AttackPathRelationAllowedToAddToGroup,
	AttackPathRelationAllowedToModifyPermissions,
	AttackPathRelationInGroup,
	AttackPathRelationLoggedOnToEp,
	AttackPathRelationLocalAdmin,
	AttackPathRelationDuplicatedLocalAdmin,
	AttackPathRelationApplicationOwner,
	AttackPathRelationApplicationController,
	AttackPathRelationRoleMember,
	AttackPathRelationAdminReplicator,
	AttackPathRelationAdminSidTakeover,
	AttackPathRelationAdminUnconstrainedSvcDelegation,
	AttackPathRelationAdminConstrainedSvcDelegation,
	AttackPathRelationAdminAuthenticateAsAnyDomainUserCaTemplate,
	AttackPathRelationAdminAuthenticateAsAnyDomainUserWithRequestAgent,
	AttackPathRelationDuplicatePassword,
	AttackPathRelationOwnerAdmin,
	AttackPathRelationCaTemplate,
	AttackPathRelationAllowedToWriteKeyCredential,
	AttackPathRelationAllowedToWriteOwnerCaTemplate,
	AttackPathRelationAllowedToWriteDaclCaTemplate,
	AttackPathRelationAllowedToWritePropertyCaTemplate,
	AttackPathRelationAllowedToEnrollCaTemplate,
}

func (e AttackPathRelation) IsValid() bool {
	switch e {
	case AttackPathRelationAdmin, AttackPathRelationPasswordResetter, AttackPathRelationAllowedToAddToGroup, AttackPathRelationAllowedToModifyPermissions, AttackPathRelationInGroup, AttackPathRelationLoggedOnToEp, AttackPathRelationLocalAdmin, AttackPathRelationDuplicatedLocalAdmin, AttackPathRelationApplicationOwner, AttackPathRelationApplicationController, AttackPathRelationRoleMember, AttackPathRelationAdminReplicator, AttackPathRelationAdminSidTakeover, AttackPathRelationAdminUnconstrainedSvcDelegation, AttackPathRelationAdminConstrainedSvcDelegation, AttackPathRelationAdminAuthenticateAsAnyDomainUserCaTemplate, AttackPathRelationAdminAuthenticateAsAnyDomainUserWithRequestAgent, AttackPathRelationDuplicatePassword, AttackPathRelationOwnerAdmin, AttackPathRelationCaTemplate, AttackPathRelationAllowedToWriteKeyCredential, AttackPathRelationAllowedToWriteOwnerCaTemplate, AttackPathRelationAllowedToWriteDaclCaTemplate, AttackPathRelationAllowedToWritePropertyCaTemplate, AttackPathRelationAllowedToEnrollCaTemplate:
		return true
	}
	return false
}

func (e AttackPathRelation) String() string {
	return string(e)
}

func (e *AttackPathRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttackPathRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AttackPathRelation", str)
	}
	return nil
}

func (e AttackPathRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuthenticationType string

const (
	AuthenticationTypeDomainLogin            AuthenticationType = "DOMAIN_LOGIN"
	AuthenticationTypeSsoLogin               AuthenticationType = "SSO_LOGIN"
	AuthenticationTypeLdapAuthentication     AuthenticationType = "LDAP_AUTHENTICATION"
	AuthenticationTypeNtlmAuthentication     AuthenticationType = "NTLM_AUTHENTICATION"
	AuthenticationTypeKerberosAuthentication AuthenticationType = "KERBEROS_AUTHENTICATION"
	AuthenticationTypeSmbSessionSetup        AuthenticationType = "SMB_SESSION_SETUP"
)

var AllAuthenticationType = []AuthenticationType{
	AuthenticationTypeDomainLogin,
	AuthenticationTypeSsoLogin,
	AuthenticationTypeLdapAuthentication,
	AuthenticationTypeNtlmAuthentication,
	AuthenticationTypeKerberosAuthentication,
	AuthenticationTypeSmbSessionSetup,
}

func (e AuthenticationType) IsValid() bool {
	switch e {
	case AuthenticationTypeDomainLogin, AuthenticationTypeSsoLogin, AuthenticationTypeLdapAuthentication, AuthenticationTypeNtlmAuthentication, AuthenticationTypeKerberosAuthentication, AuthenticationTypeSmbSessionSetup:
		return true
	}
	return false
}

func (e AuthenticationType) String() string {
	return string(e)
}

func (e *AuthenticationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthenticationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthenticationType", str)
	}
	return nil
}

func (e AuthenticationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The binding type of an `Association` between two entities.
//
// Binding types can be **Symmetric** or **Asymmetric** (see `Association` for a detailed explanation).
type BindingType string

const (
	// A non-interactive, regular-usage origin association between a `UserEntity` and an `EndpointEntity`.
	//
	// * **Symmetric**: yes
	// * **Association subtype**: `OriginAssociation`
	BindingTypeActivityOrigin BindingType = "ACTIVITY_ORIGIN"
	// An interactive regular-usage origin association between a `UserEntity` and an `EndpointEntity`.
	//
	// * **Symmetric**: yes
	// * **Association subtype**: `OriginAssociation`
	BindingTypeLogin BindingType = "LOGIN"
	// An interactive *mostly-exclusive* regular-usage origin association between a `UserEntity` and an `EndpointEntity`.
	//
	// * **Symmetric**: yes
	// * **Association subtype**: `OriginAssociation`
	BindingTypeOwnership BindingType = "OWNERSHIP"
	// An origin association between a `UserEntity` and an `EndpointEntity` briefly
	// established after a user explicitly confirms the usage of an endpoint.
	//
	// * **Symmetric**: yes
	// * **Association subtype**: `RecentlyVerifiedLoginBindingAssociation`
	BindingTypeRecentlyVerifiedLogin BindingType = "RECENTLY_VERIFIED_LOGIN"
	// A regular target-access association. When set on a `UserEntity`, the
	// SERVICE_ACCESS binding implies that the user regularly accesses the
	// destination using their credentials. When set on an `EndpointEntity`, it
	// implies that the endpoint is regularly used to access a service.
	//
	// * **Symmetric**: no
	// * **Association subtype**: `ServiceAssociation`
	BindingTypeServiceAccess BindingType = "SERVICE_ACCESS"
	// This association represents a regular LDAP authentication of a `UserEntity` on an `EndpointEntity`.
	//
	// * **Symmetric**: no
	// * **Association subtype**: `OriginAssociation`
	BindingTypeLdapAuthentication BindingType = "LDAP_AUTHENTICATION"
	// A *structural* association indicating that a `UserEntity` is configured to execute a service on an `EndpointEntity`.
	//
	// * **Symmetric**: yes
	// * **Association subtype**: `ServiceAssociation`
	BindingTypeServiceExecution BindingType = "SERVICE_EXECUTION"
	// A *structural* origin association indicating that a `UserEntity` is allowed to log into an `EndpointEntity`.
	//
	// * **Symmetric**: yes
	// * **Association subtype**: `OriginAssociation`
	BindingTypeEndpointAuthorization BindingType = "ENDPOINT_AUTHORIZATION"
	// A regular target-access association for cloud services. This association can be set on `UserEntity` only.
	//
	// * **Symmetric**: no
	// * **Association subtype**: `CloudServiceAssociation`
	BindingTypeCloudServiceAccess BindingType = "CLOUD_SERVICE_ACCESS"
	// A regular origin association indicating that the user regularly performs
	// network activities from a certain geographical location.
	//
	// * **Symmetric**: no
	// * **Association subtype**: `GeoLocationAssociation`
	BindingTypeGeoLocation        BindingType = "GEO_LOCATION"
	BindingTypeLocalAdministrator BindingType = "LOCAL_ADMINISTRATOR"
	BindingTypeManage             BindingType = "MANAGE"
	BindingTypeManaged            BindingType = "MANAGED"
	BindingTypeAuthorizer         BindingType = "AUTHORIZER"
	BindingTypeAuthorized         BindingType = "AUTHORIZED"
	BindingTypeRbacAssignment     BindingType = "RBAC_ASSIGNMENT"
	BindingTypeLinkedAccount      BindingType = "LINKED_ACCOUNT"
)

var AllBindingType = []BindingType{
	BindingTypeActivityOrigin,
	BindingTypeLogin,
	BindingTypeOwnership,
	BindingTypeRecentlyVerifiedLogin,
	BindingTypeServiceAccess,
	BindingTypeLdapAuthentication,
	BindingTypeServiceExecution,
	BindingTypeEndpointAuthorization,
	BindingTypeCloudServiceAccess,
	BindingTypeGeoLocation,
	BindingTypeLocalAdministrator,
	BindingTypeManage,
	BindingTypeManaged,
	BindingTypeAuthorizer,
	BindingTypeAuthorized,
	BindingTypeRbacAssignment,
	BindingTypeLinkedAccount,
}

func (e BindingType) IsValid() bool {
	switch e {
	case BindingTypeActivityOrigin, BindingTypeLogin, BindingTypeOwnership, BindingTypeRecentlyVerifiedLogin, BindingTypeServiceAccess, BindingTypeLdapAuthentication, BindingTypeServiceExecution, BindingTypeEndpointAuthorization, BindingTypeCloudServiceAccess, BindingTypeGeoLocation, BindingTypeLocalAdministrator, BindingTypeManage, BindingTypeManaged, BindingTypeAuthorizer, BindingTypeAuthorized, BindingTypeRbacAssignment, BindingTypeLinkedAccount:
		return true
	}
	return false
}

func (e BindingType) String() string {
	return string(e)
}

func (e *BindingType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BindingType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BindingType", str)
	}
	return nil
}

func (e BindingType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BusinessPrivilegeImpact string

const (
	BusinessPrivilegeImpactLow    BusinessPrivilegeImpact = "LOW"
	BusinessPrivilegeImpactMedium BusinessPrivilegeImpact = "MEDIUM"
	BusinessPrivilegeImpactHigh   BusinessPrivilegeImpact = "HIGH"
)

var AllBusinessPrivilegeImpact = []BusinessPrivilegeImpact{
	BusinessPrivilegeImpactLow,
	BusinessPrivilegeImpactMedium,
	BusinessPrivilegeImpactHigh,
}

func (e BusinessPrivilegeImpact) IsValid() bool {
	switch e {
	case BusinessPrivilegeImpactLow, BusinessPrivilegeImpactMedium, BusinessPrivilegeImpactHigh:
		return true
	}
	return false
}

func (e BusinessPrivilegeImpact) String() string {
	return string(e)
}

func (e *BusinessPrivilegeImpact) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusinessPrivilegeImpact(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusinessPrivilegeImpact", str)
	}
	return nil
}

func (e BusinessPrivilegeImpact) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BusinessRole string

const (
	BusinessRoleRegular   BusinessRole = "REGULAR"
	BusinessRoleExecutive BusinessRole = "EXECUTIVE"
	BusinessRoleAdmin     BusinessRole = "ADMIN"
	BusinessRoleFinance   BusinessRole = "FINANCE"
	BusinessRoleIt        BusinessRole = "IT"
	BusinessRoleGuest     BusinessRole = "GUEST"
)

var AllBusinessRole = []BusinessRole{
	BusinessRoleRegular,
	BusinessRoleExecutive,
	BusinessRoleAdmin,
	BusinessRoleFinance,
	BusinessRoleIt,
	BusinessRoleGuest,
}

func (e BusinessRole) IsValid() bool {
	switch e {
	case BusinessRoleRegular, BusinessRoleExecutive, BusinessRoleAdmin, BusinessRoleFinance, BusinessRoleIt, BusinessRoleGuest:
		return true
	}
	return false
}

func (e BusinessRole) String() string {
	return string(e)
}

func (e *BusinessRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusinessRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusinessRole", str)
	}
	return nil
}

func (e BusinessRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConnectorStatus string

const (
	ConnectorStatusInitial                      ConnectorStatus = "INITIAL"
	ConnectorStatusSuccess                      ConnectorStatus = "SUCCESS"
	ConnectorStatusCommonError                  ConnectorStatus = "COMMON_ERROR"
	ConnectorStatusCommonConnectionError        ConnectorStatus = "COMMON_CONNECTION_ERROR"
	ConnectorStatusAuthenticationError          ConnectorStatus = "AUTHENTICATION_ERROR"
	ConnectorStatusAuthorizationError           ConnectorStatus = "AUTHORIZATION_ERROR"
	ConnectorStatusDomainNotInWhitelistError    ConnectorStatus = "DOMAIN_NOT_IN_WHITELIST_ERROR"
	ConnectorStatusInvalidClientIDOrSecretError ConnectorStatus = "INVALID_CLIENT_ID_OR_SECRET_ERROR"
	ConnectorStatusMissingPermission            ConnectorStatus = "MISSING_PERMISSION"
	ConnectorStatusMissingPartialPermission     ConnectorStatus = "MISSING_PARTIAL_PERMISSION"
	ConnectorStatusRateLimitExceeded            ConnectorStatus = "RATE_LIMIT_EXCEEDED"
	ConnectorStatusLicenseWillExpireSoon        ConnectorStatus = "LICENSE_WILL_EXPIRE_SOON"
	ConnectorStatusLicenseExpired               ConnectorStatus = "LICENSE_EXPIRED"
)

var AllConnectorStatus = []ConnectorStatus{
	ConnectorStatusInitial,
	ConnectorStatusSuccess,
	ConnectorStatusCommonError,
	ConnectorStatusCommonConnectionError,
	ConnectorStatusAuthenticationError,
	ConnectorStatusAuthorizationError,
	ConnectorStatusDomainNotInWhitelistError,
	ConnectorStatusInvalidClientIDOrSecretError,
	ConnectorStatusMissingPermission,
	ConnectorStatusMissingPartialPermission,
	ConnectorStatusRateLimitExceeded,
	ConnectorStatusLicenseWillExpireSoon,
	ConnectorStatusLicenseExpired,
}

func (e ConnectorStatus) IsValid() bool {
	switch e {
	case ConnectorStatusInitial, ConnectorStatusSuccess, ConnectorStatusCommonError, ConnectorStatusCommonConnectionError, ConnectorStatusAuthenticationError, ConnectorStatusAuthorizationError, ConnectorStatusDomainNotInWhitelistError, ConnectorStatusInvalidClientIDOrSecretError, ConnectorStatusMissingPermission, ConnectorStatusMissingPartialPermission, ConnectorStatusRateLimitExceeded, ConnectorStatusLicenseWillExpireSoon, ConnectorStatusLicenseExpired:
		return true
	}
	return false
}

func (e ConnectorStatus) String() string {
	return string(e)
}

func (e *ConnectorStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectorStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectorStatus", str)
	}
	return nil
}

func (e ConnectorStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of data sources in which system data may originate.
//
// `SNIFFER` is the data source used for on-premises traffic monitored by sensors.
// Otherwise, most entries are well-known vendor names the system accepts as input.
type DataSource string

const (
	DataSourceSniffer         DataSource = "SNIFFER"
	DataSourceActiveDirectory DataSource = "ACTIVE_DIRECTORY"
	DataSourceAdfs            DataSource = "ADFS"
	DataSourceOkta            DataSource = "OKTA"
	DataSourceAzure           DataSource = "AZURE"
	DataSourcePingIDEntity    DataSource = "PING_IDENTITY"
	DataSourceAws             DataSource = "AWS"
)

var AllDataSource = []DataSource{
	DataSourceSniffer,
	DataSourceActiveDirectory,
	DataSourceAdfs,
	DataSourceOkta,
	DataSourceAzure,
	DataSourcePingIDEntity,
	DataSourceAws,
}

func (e DataSource) IsValid() bool {
	switch e {
	case DataSourceSniffer, DataSourceActiveDirectory, DataSourceAdfs, DataSourceOkta, DataSourceAzure, DataSourcePingIDEntity, DataSourceAws:
		return true
	}
	return false
}

func (e DataSource) String() string {
	return string(e)
}

func (e *DataSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DataSource", str)
	}
	return nil
}

func (e DataSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DataSourceCategory string

const (
	DataSourceCategoryOnPremisesTraffic DataSourceCategory = "ON_PREMISES_TRAFFIC"
	DataSourceCategoryIdaas             DataSourceCategory = "IDAAS"
	DataSourceCategoryOnPremisesSso     DataSourceCategory = "ON_PREMISES_SSO"
	DataSourceCategoryPam               DataSourceCategory = "PAM"
	DataSourceCategoryTraffic           DataSourceCategory = "TRAFFIC"
	DataSourceCategorySso               DataSourceCategory = "SSO"
)

var AllDataSourceCategory = []DataSourceCategory{
	DataSourceCategoryOnPremisesTraffic,
	DataSourceCategoryIdaas,
	DataSourceCategoryOnPremisesSso,
	DataSourceCategoryPam,
	DataSourceCategoryTraffic,
	DataSourceCategorySso,
}

func (e DataSourceCategory) IsValid() bool {
	switch e {
	case DataSourceCategoryOnPremisesTraffic, DataSourceCategoryIdaas, DataSourceCategoryOnPremisesSso, DataSourceCategoryPam, DataSourceCategoryTraffic, DataSourceCategorySso:
		return true
	}
	return false
}

func (e DataSourceCategory) String() string {
	return string(e)
}

func (e *DataSourceCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataSourceCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DataSourceCategory", str)
	}
	return nil
}

func (e DataSourceCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of [DCE/RPC](http://www.dcerpc.org/) activity signatures.
type DcerpcSignature string

const (
	DcerpcSignatureDcSync                        DcerpcSignature = "DC_SYNC"
	DcerpcSignatureSpnModification               DcerpcSignature = "SPN_MODIFICATION"
	DcerpcSignatureReplicationServerRegistration DcerpcSignature = "REPLICATION_SERVER_REGISTRATION"
	DcerpcSignatureScheduledTaskCreation         DcerpcSignature = "SCHEDULED_TASK_CREATION"
	DcerpcSignatureRemoteServiceInterface        DcerpcSignature = "REMOTE_SERVICE_INTERFACE"
	DcerpcSignatureNetSessionEnumeration         DcerpcSignature = "NET_SESSION_ENUMERATION"
	DcerpcSignatureSamrInterface                 DcerpcSignature = "SAMR_INTERFACE"
	DcerpcSignatureDcomInterface                 DcerpcSignature = "DCOM_INTERFACE"
	DcerpcSignatureTaskSchduleInterface          DcerpcSignature = "TASK_SCHDULE_INTERFACE"
	DcerpcSignatureIremoteWinspoolInterface      DcerpcSignature = "IREMOTE_WINSPOOL_INTERFACE"
	DcerpcSignatureZerologonExploit              DcerpcSignature = "ZEROLOGON_EXPLOIT"
	DcerpcSignatureCreateService                 DcerpcSignature = "CREATE_SERVICE"
)

var AllDcerpcSignature = []DcerpcSignature{
	DcerpcSignatureDcSync,
	DcerpcSignatureSpnModification,
	DcerpcSignatureReplicationServerRegistration,
	DcerpcSignatureScheduledTaskCreation,
	DcerpcSignatureRemoteServiceInterface,
	DcerpcSignatureNetSessionEnumeration,
	DcerpcSignatureSamrInterface,
	DcerpcSignatureDcomInterface,
	DcerpcSignatureTaskSchduleInterface,
	DcerpcSignatureIremoteWinspoolInterface,
	DcerpcSignatureZerologonExploit,
	DcerpcSignatureCreateService,
}

func (e DcerpcSignature) IsValid() bool {
	switch e {
	case DcerpcSignatureDcSync, DcerpcSignatureSpnModification, DcerpcSignatureReplicationServerRegistration, DcerpcSignatureScheduledTaskCreation, DcerpcSignatureRemoteServiceInterface, DcerpcSignatureNetSessionEnumeration, DcerpcSignatureSamrInterface, DcerpcSignatureDcomInterface, DcerpcSignatureTaskSchduleInterface, DcerpcSignatureIremoteWinspoolInterface, DcerpcSignatureZerologonExploit, DcerpcSignatureCreateService:
		return true
	}
	return false
}

func (e DcerpcSignature) String() string {
	return string(e)
}

func (e *DcerpcSignature) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DcerpcSignature(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DcerpcSignature", str)
	}
	return nil
}

func (e DcerpcSignature) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EndpointEntityClassification string

const (
	EndpointEntityClassificationWorkstation       EndpointEntityClassification = "WORKSTATION"
	EndpointEntityClassificationServer            EndpointEntityClassification = "SERVER"
	EndpointEntityClassificationImpersonator      EndpointEntityClassification = "IMPERSONATOR"
	EndpointEntityClassificationApplicationServer EndpointEntityClassification = "APPLICATION_SERVER"
	EndpointEntityClassificationFileServer        EndpointEntityClassification = "FILE_SERVER"
	EndpointEntityClassificationVdiEndpoint       EndpointEntityClassification = "VDI_ENDPOINT"
)

var AllEndpointEntityClassification = []EndpointEntityClassification{
	EndpointEntityClassificationWorkstation,
	EndpointEntityClassificationServer,
	EndpointEntityClassificationImpersonator,
	EndpointEntityClassificationApplicationServer,
	EndpointEntityClassificationFileServer,
	EndpointEntityClassificationVdiEndpoint,
}

func (e EndpointEntityClassification) IsValid() bool {
	switch e {
	case EndpointEntityClassificationWorkstation, EndpointEntityClassificationServer, EndpointEntityClassificationImpersonator, EndpointEntityClassificationApplicationServer, EndpointEntityClassificationFileServer, EndpointEntityClassificationVdiEndpoint:
		return true
	}
	return false
}

func (e EndpointEntityClassification) String() string {
	return string(e)
}

func (e *EndpointEntityClassification) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EndpointEntityClassification(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EndpointEntityClassification", str)
	}
	return nil
}

func (e EndpointEntityClassification) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EngagementAuthenticationStatus string

const (
	EngagementAuthenticationStatusPending             EngagementAuthenticationStatus = "PENDING"
	EngagementAuthenticationStatusApprove             EngagementAuthenticationStatus = "APPROVE"
	EngagementAuthenticationStatusAutoApprove         EngagementAuthenticationStatus = "AUTO_APPROVE"
	EngagementAuthenticationStatusAutoDeny            EngagementAuthenticationStatus = "AUTO_DENY"
	EngagementAuthenticationStatusDenyAndNotFraud     EngagementAuthenticationStatus = "DENY_AND_NOT_FRAUD"
	EngagementAuthenticationStatusDenyAndFraudulent   EngagementAuthenticationStatus = "DENY_AND_FRAUDULENT"
	EngagementAuthenticationStatusDenyAndUnknown      EngagementAuthenticationStatus = "DENY_AND_UNKNOWN"
	EngagementAuthenticationStatusInvalidUserInput    EngagementAuthenticationStatus = "INVALID_USER_INPUT"
	EngagementAuthenticationStatusUserResponseTimeout EngagementAuthenticationStatus = "USER_RESPONSE_TIMEOUT"
	EngagementAuthenticationStatusUserNotEnrolled     EngagementAuthenticationStatus = "USER_NOT_ENROLLED"
	EngagementAuthenticationStatusNoValidAuthorizer   EngagementAuthenticationStatus = "NO_VALID_AUTHORIZER"
	EngagementAuthenticationStatusError               EngagementAuthenticationStatus = "ERROR"
)

var AllEngagementAuthenticationStatus = []EngagementAuthenticationStatus{
	EngagementAuthenticationStatusPending,
	EngagementAuthenticationStatusApprove,
	EngagementAuthenticationStatusAutoApprove,
	EngagementAuthenticationStatusAutoDeny,
	EngagementAuthenticationStatusDenyAndNotFraud,
	EngagementAuthenticationStatusDenyAndFraudulent,
	EngagementAuthenticationStatusDenyAndUnknown,
	EngagementAuthenticationStatusInvalidUserInput,
	EngagementAuthenticationStatusUserResponseTimeout,
	EngagementAuthenticationStatusUserNotEnrolled,
	EngagementAuthenticationStatusNoValidAuthorizer,
	EngagementAuthenticationStatusError,
}

func (e EngagementAuthenticationStatus) IsValid() bool {
	switch e {
	case EngagementAuthenticationStatusPending, EngagementAuthenticationStatusApprove, EngagementAuthenticationStatusAutoApprove, EngagementAuthenticationStatusAutoDeny, EngagementAuthenticationStatusDenyAndNotFraud, EngagementAuthenticationStatusDenyAndFraudulent, EngagementAuthenticationStatusDenyAndUnknown, EngagementAuthenticationStatusInvalidUserInput, EngagementAuthenticationStatusUserResponseTimeout, EngagementAuthenticationStatusUserNotEnrolled, EngagementAuthenticationStatusNoValidAuthorizer, EngagementAuthenticationStatusError:
		return true
	}
	return false
}

func (e EngagementAuthenticationStatus) String() string {
	return string(e)
}

func (e *EngagementAuthenticationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EngagementAuthenticationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EngagementAuthenticationStatus", str)
	}
	return nil
}

func (e EngagementAuthenticationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EngagementType string

const (
	EngagementTypeGoogleAuthEnroll  EngagementType = "GOOGLE_AUTH_ENROLL"
	EngagementTypeEmailVerification EngagementType = "EMAIL_VERIFICATION"
	EngagementTypeEmailNotification EngagementType = "EMAIL_NOTIFICATION"
	EngagementTypeSmsNotification   EngagementType = "SMS_NOTIFICATION"
	EngagementTypeSmsVerification   EngagementType = "SMS_VERIFICATION"
	EngagementTypeMfa               EngagementType = "MFA"
)

var AllEngagementType = []EngagementType{
	EngagementTypeGoogleAuthEnroll,
	EngagementTypeEmailVerification,
	EngagementTypeEmailNotification,
	EngagementTypeSmsNotification,
	EngagementTypeSmsVerification,
	EngagementTypeMfa,
}

func (e EngagementType) IsValid() bool {
	switch e {
	case EngagementTypeGoogleAuthEnroll, EngagementTypeEmailVerification, EngagementTypeEmailNotification, EngagementTypeSmsNotification, EngagementTypeSmsVerification, EngagementTypeMfa:
		return true
	}
	return false
}

func (e EngagementType) String() string {
	return string(e)
}

func (e *EngagementType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EngagementType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EngagementType", str)
	}
	return nil
}

func (e EngagementType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityContainerType string

const (
	EntityContainerTypeActiveDirectoryGroup EntityContainerType = "ACTIVE_DIRECTORY_GROUP"
	EntityContainerTypeAzureGroup           EntityContainerType = "AZURE_GROUP"
	EntityContainerTypeAzureRole            EntityContainerType = "AZURE_ROLE"
	EntityContainerTypeAwsGroup             EntityContainerType = "AWS_GROUP"
)

var AllEntityContainerType = []EntityContainerType{
	EntityContainerTypeActiveDirectoryGroup,
	EntityContainerTypeAzureGroup,
	EntityContainerTypeAzureRole,
	EntityContainerTypeAwsGroup,
}

func (e EntityContainerType) IsValid() bool {
	switch e {
	case EntityContainerTypeActiveDirectoryGroup, EntityContainerTypeAzureGroup, EntityContainerTypeAzureRole, EntityContainerTypeAwsGroup:
		return true
	}
	return false
}

func (e EntityContainerType) String() string {
	return string(e)
}

func (e *EntityContainerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityContainerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityContainerType", str)
	}
	return nil
}

func (e EntityContainerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityMembershipType string

const (
	EntityMembershipTypeUserInDepartment         EntityMembershipType = "USER_IN_DEPARTMENT"
	EntityMembershipTypeUserInOrganizationalUnit EntityMembershipType = "USER_IN_ORGANIZATIONAL_UNIT"
)

var AllEntityMembershipType = []EntityMembershipType{
	EntityMembershipTypeUserInDepartment,
	EntityMembershipTypeUserInOrganizationalUnit,
}

func (e EntityMembershipType) IsValid() bool {
	switch e {
	case EntityMembershipTypeUserInDepartment, EntityMembershipTypeUserInOrganizationalUnit:
		return true
	}
	return false
}

func (e EntityMembershipType) String() string {
	return string(e)
}

func (e *EntityMembershipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityMembershipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityMembershipType", str)
	}
	return nil
}

func (e EntityMembershipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EntityRoleType string

const (
	EntityRoleTypeOperatorLevelAdminRole                                 EntityRoleType = "OperatorLevelAdminRole"
	EntityRoleTypeAdminAccountRole                                       EntityRoleType = "AdminAccountRole"
	EntityRoleTypeAzurePrivilegedRole                                    EntityRoleType = "AzurePrivilegedRole"
	EntityRoleTypeAzureGlobalPrivilegesRole                              EntityRoleType = "AzureGlobalPrivilegesRole"
	EntityRoleTypeAzureCredentialsPrivilegesRole                         EntityRoleType = "AzureCredentialsPrivilegesRole"
	EntityRoleTypeAzureAccessPrivilegesRole                              EntityRoleType = "AzureAccessPrivilegesRole"
	EntityRoleTypeAzureApplicationPrivilegesRole                         EntityRoleType = "AzureApplicationPrivilegesRole"
	EntityRoleTypeAzureSecurityPrivilegesRole                            EntityRoleType = "AzureSecurityPrivilegesRole"
	EntityRoleTypeAzurePrivilegedApplicationControllerRole               EntityRoleType = "AzurePrivilegedApplicationControllerRole"
	EntityRoleTypeAzureSecurityGroupRole                                 EntityRoleType = "AzureSecurityGroupRole"
	EntityRoleTypeAzureMicrosoft365GroupRole                             EntityRoleType = "AzureMicrosoft365GroupRole"
	EntityRoleTypeAzureDistributionGroupRole                             EntityRoleType = "AzureDistributionGroupRole"
	EntityRoleTypeEffectiveAdminRole                                     EntityRoleType = "EffectiveAdminRole"
	EntityRoleTypeServerRole                                             EntityRoleType = "ServerRole"
	EntityRoleTypeClassificationRole                                     EntityRoleType = "ClassificationRole"
	EntityRoleTypeDomainLevelAdminRole                                   EntityRoleType = "DomainLevelAdminRole"
	EntityRoleTypeProgrammaticUserAccountRole                            EntityRoleType = "ProgrammaticUserAccountRole"
	EntityRoleTypeForestLevelAdminRole                                   EntityRoleType = "ForestLevelAdminRole"
	EntityRoleTypeApplicationServerRole                                  EntityRoleType = "ApplicationServerRole"
	EntityRoleTypeAccountOperatorsAdminRole                              EntityRoleType = "AccountOperatorsAdminRole"
	EntityRoleTypeEffectiveReplicatorsAdminRole                          EntityRoleType = "EffectiveReplicatorsAdminRole"
	EntityRoleTypeKrbtgtAccountAdminRole                                 EntityRoleType = "KrbtgtAccountAdminRole"
	EntityRoleTypeDomainControllersAdminRole                             EntityRoleType = "DomainControllersAdminRole"
	EntityRoleTypeReadOnlyDomainControllersAdminRole                     EntityRoleType = "ReadOnlyDomainControllersAdminRole"
	EntityRoleTypeReplicatorsAdminRole                                   EntityRoleType = "ReplicatorsAdminRole"
	EntityRoleTypeMailboxRole                                            EntityRoleType = "MailboxRole"
	EntityRoleTypePrivilegedGroupControllerAdminRole                     EntityRoleType = "PrivilegedGroupControllerAdminRole"
	EntityRoleTypeDNSServerRole                                          EntityRoleType = "DnsServerRole"
	EntityRoleTypeDomainAdminsRole                                       EntityRoleType = "DomainAdminsRole"
	EntityRoleTypeSchemaAdminsRole                                       EntityRoleType = "SchemaAdminsRole"
	EntityRoleTypeAdministratorsRole                                     EntityRoleType = "AdministratorsRole"
	EntityRoleTypeBuiltinAdministratorRole                               EntityRoleType = "BuiltinAdministratorRole"
	EntityRoleTypeEnterpriseAdminsRole                                   EntityRoleType = "EnterpriseAdminsRole"
	EntityRoleTypePasswordResetterAdminRole                              EntityRoleType = "PasswordResetterAdminRole"
	EntityRoleTypePermissionsControllerAdminRole                         EntityRoleType = "PermissionsControllerAdminRole"
	EntityRoleTypeObjectSidTakeoverAdminRole                             EntityRoleType = "ObjectSidTakeoverAdminRole"
	EntityRoleTypeBackupOperatorsAdminRole                               EntityRoleType = "BackupOperatorsAdminRole"
	EntityRoleTypePrintOperatorsAdminRole                                EntityRoleType = "PrintOperatorsAdminRole"
	EntityRoleTypeServerOperatorsAdminRole                               EntityRoleType = "ServerOperatorsAdminRole"
	EntityRoleTypeServiceDelegationAdminRole                             EntityRoleType = "ServiceDelegationAdminRole"
	EntityRoleTypeUnconstrainedServiceDelegationAdminRole                EntityRoleType = "UnconstrainedServiceDelegationAdminRole"
	EntityRoleTypeConstrainedServiceDelegationAdminRole                  EntityRoleType = "ConstrainedServiceDelegationAdminRole"
	EntityRoleTypeFileServerRole                                         EntityRoleType = "FileServerRole"
	EntityRoleTypeHumanUserAccountRole                                   EntityRoleType = "HumanUserAccountRole"
	EntityRoleTypeWorkstationRole                                        EntityRoleType = "WorkstationRole"
	EntityRoleTypeNtlmMovementRole                                       EntityRoleType = "NtlmMovementRole"
	EntityRoleTypeDomainControllerRole                                   EntityRoleType = "DomainControllerRole"
	EntityRoleTypeVdiEndpointRole                                        EntityRoleType = "VdiEndpointRole"
	EntityRoleTypeExchangeServerRole                                     EntityRoleType = "ExchangeServerRole"
	EntityRoleTypeLocalAdminRole                                         EntityRoleType = "LocalAdminRole"
	EntityRoleTypeBusinessPrivilegeRole                                  EntityRoleType = "BusinessPrivilegeRole"
	EntityRoleTypeContainerRole                                          EntityRoleType = "ContainerRole"
	EntityRoleTypePermissionAssignerRole                                 EntityRoleType = "PermissionAssignerRole"
	EntityRoleTypeMailingListRole                                        EntityRoleType = "MailingListRole"
	EntityRoleTypeSecurityGroupRole                                      EntityRoleType = "SecurityGroupRole"
	EntityRoleTypeDistributionGroupRole                                  EntityRoleType = "DistributionGroupRole"
	EntityRoleTypeHoneytokenRole                                         EntityRoleType = "HoneytokenRole"
	EntityRoleTypeCertificateAuthorityServerRole                         EntityRoleType = "CertificateAuthorityServerRole"
	EntityRoleTypeCertificateAuthorityAdminRole                          EntityRoleType = "CertificateAuthorityAdminRole"
	EntityRoleTypeAuthenticationCertificateTemplateControllerRole        EntityRoleType = "AuthenticationCertificateTemplateControllerRole"
	EntityRoleTypeKeyCredentialAdminRole                                 EntityRoleType = "KeyCredentialAdminRole"
	EntityRoleTypeOwnerAdminRole                                         EntityRoleType = "OwnerAdminRole"
	EntityRoleTypeCertificateAuthenticationAsAnyDomainUserRole           EntityRoleType = "CertificateAuthenticationAsAnyDomainUserRole"
	EntityRoleTypeAuthenticationAsAnyUserWithCertificateRequestAgentRole EntityRoleType = "AuthenticationAsAnyUserWithCertificateRequestAgentRole"
)

var AllEntityRoleType = []EntityRoleType{
	EntityRoleTypeOperatorLevelAdminRole,
	EntityRoleTypeAdminAccountRole,
	EntityRoleTypeAzurePrivilegedRole,
	EntityRoleTypeAzureGlobalPrivilegesRole,
	EntityRoleTypeAzureCredentialsPrivilegesRole,
	EntityRoleTypeAzureAccessPrivilegesRole,
	EntityRoleTypeAzureApplicationPrivilegesRole,
	EntityRoleTypeAzureSecurityPrivilegesRole,
	EntityRoleTypeAzurePrivilegedApplicationControllerRole,
	EntityRoleTypeAzureSecurityGroupRole,
	EntityRoleTypeAzureMicrosoft365GroupRole,
	EntityRoleTypeAzureDistributionGroupRole,
	EntityRoleTypeEffectiveAdminRole,
	EntityRoleTypeServerRole,
	EntityRoleTypeClassificationRole,
	EntityRoleTypeDomainLevelAdminRole,
	EntityRoleTypeProgrammaticUserAccountRole,
	EntityRoleTypeForestLevelAdminRole,
	EntityRoleTypeApplicationServerRole,
	EntityRoleTypeAccountOperatorsAdminRole,
	EntityRoleTypeEffectiveReplicatorsAdminRole,
	EntityRoleTypeKrbtgtAccountAdminRole,
	EntityRoleTypeDomainControllersAdminRole,
	EntityRoleTypeReadOnlyDomainControllersAdminRole,
	EntityRoleTypeReplicatorsAdminRole,
	EntityRoleTypeMailboxRole,
	EntityRoleTypePrivilegedGroupControllerAdminRole,
	EntityRoleTypeDNSServerRole,
	EntityRoleTypeDomainAdminsRole,
	EntityRoleTypeSchemaAdminsRole,
	EntityRoleTypeAdministratorsRole,
	EntityRoleTypeBuiltinAdministratorRole,
	EntityRoleTypeEnterpriseAdminsRole,
	EntityRoleTypePasswordResetterAdminRole,
	EntityRoleTypePermissionsControllerAdminRole,
	EntityRoleTypeObjectSidTakeoverAdminRole,
	EntityRoleTypeBackupOperatorsAdminRole,
	EntityRoleTypePrintOperatorsAdminRole,
	EntityRoleTypeServerOperatorsAdminRole,
	EntityRoleTypeServiceDelegationAdminRole,
	EntityRoleTypeUnconstrainedServiceDelegationAdminRole,
	EntityRoleTypeConstrainedServiceDelegationAdminRole,
	EntityRoleTypeFileServerRole,
	EntityRoleTypeHumanUserAccountRole,
	EntityRoleTypeWorkstationRole,
	EntityRoleTypeNtlmMovementRole,
	EntityRoleTypeDomainControllerRole,
	EntityRoleTypeVdiEndpointRole,
	EntityRoleTypeExchangeServerRole,
	EntityRoleTypeLocalAdminRole,
	EntityRoleTypeBusinessPrivilegeRole,
	EntityRoleTypeContainerRole,
	EntityRoleTypePermissionAssignerRole,
	EntityRoleTypeMailingListRole,
	EntityRoleTypeSecurityGroupRole,
	EntityRoleTypeDistributionGroupRole,
	EntityRoleTypeHoneytokenRole,
	EntityRoleTypeCertificateAuthorityServerRole,
	EntityRoleTypeCertificateAuthorityAdminRole,
	EntityRoleTypeAuthenticationCertificateTemplateControllerRole,
	EntityRoleTypeKeyCredentialAdminRole,
	EntityRoleTypeOwnerAdminRole,
	EntityRoleTypeCertificateAuthenticationAsAnyDomainUserRole,
	EntityRoleTypeAuthenticationAsAnyUserWithCertificateRequestAgentRole,
}

func (e EntityRoleType) IsValid() bool {
	switch e {
	case EntityRoleTypeOperatorLevelAdminRole, EntityRoleTypeAdminAccountRole, EntityRoleTypeAzurePrivilegedRole, EntityRoleTypeAzureGlobalPrivilegesRole, EntityRoleTypeAzureCredentialsPrivilegesRole, EntityRoleTypeAzureAccessPrivilegesRole, EntityRoleTypeAzureApplicationPrivilegesRole, EntityRoleTypeAzureSecurityPrivilegesRole, EntityRoleTypeAzurePrivilegedApplicationControllerRole, EntityRoleTypeAzureSecurityGroupRole, EntityRoleTypeAzureMicrosoft365GroupRole, EntityRoleTypeAzureDistributionGroupRole, EntityRoleTypeEffectiveAdminRole, EntityRoleTypeServerRole, EntityRoleTypeClassificationRole, EntityRoleTypeDomainLevelAdminRole, EntityRoleTypeProgrammaticUserAccountRole, EntityRoleTypeForestLevelAdminRole, EntityRoleTypeApplicationServerRole, EntityRoleTypeAccountOperatorsAdminRole, EntityRoleTypeEffectiveReplicatorsAdminRole, EntityRoleTypeKrbtgtAccountAdminRole, EntityRoleTypeDomainControllersAdminRole, EntityRoleTypeReadOnlyDomainControllersAdminRole, EntityRoleTypeReplicatorsAdminRole, EntityRoleTypeMailboxRole, EntityRoleTypePrivilegedGroupControllerAdminRole, EntityRoleTypeDNSServerRole, EntityRoleTypeDomainAdminsRole, EntityRoleTypeSchemaAdminsRole, EntityRoleTypeAdministratorsRole, EntityRoleTypeBuiltinAdministratorRole, EntityRoleTypeEnterpriseAdminsRole, EntityRoleTypePasswordResetterAdminRole, EntityRoleTypePermissionsControllerAdminRole, EntityRoleTypeObjectSidTakeoverAdminRole, EntityRoleTypeBackupOperatorsAdminRole, EntityRoleTypePrintOperatorsAdminRole, EntityRoleTypeServerOperatorsAdminRole, EntityRoleTypeServiceDelegationAdminRole, EntityRoleTypeUnconstrainedServiceDelegationAdminRole, EntityRoleTypeConstrainedServiceDelegationAdminRole, EntityRoleTypeFileServerRole, EntityRoleTypeHumanUserAccountRole, EntityRoleTypeWorkstationRole, EntityRoleTypeNtlmMovementRole, EntityRoleTypeDomainControllerRole, EntityRoleTypeVdiEndpointRole, EntityRoleTypeExchangeServerRole, EntityRoleTypeLocalAdminRole, EntityRoleTypeBusinessPrivilegeRole, EntityRoleTypeContainerRole, EntityRoleTypePermissionAssignerRole, EntityRoleTypeMailingListRole, EntityRoleTypeSecurityGroupRole, EntityRoleTypeDistributionGroupRole, EntityRoleTypeHoneytokenRole, EntityRoleTypeCertificateAuthorityServerRole, EntityRoleTypeCertificateAuthorityAdminRole, EntityRoleTypeAuthenticationCertificateTemplateControllerRole, EntityRoleTypeKeyCredentialAdminRole, EntityRoleTypeOwnerAdminRole, EntityRoleTypeCertificateAuthenticationAsAnyDomainUserRole, EntityRoleTypeAuthenticationAsAnyUserWithCertificateRequestAgentRole:
		return true
	}
	return false
}

func (e EntityRoleType) String() string {
	return string(e)
}

func (e *EntityRoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityRoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityRoleType", str)
	}
	return nil
}

func (e EntityRoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of sort options for the `entities` query API.
type EntitySortKey string

const (
	EntitySortKeyEntityID             EntitySortKey = "ENTITY_ID"
	EntitySortKeyRiskScore            EntitySortKey = "RISK_SCORE"
	EntitySortKeyMostRecentActivity   EntitySortKey = "MOST_RECENT_ACTIVITY"
	EntitySortKeyCreationTime         EntitySortKey = "CREATION_TIME"
	EntitySortKeyExpirationTime       EntitySortKey = "EXPIRATION_TIME"
	EntitySortKeyOpenIncidentCount    EntitySortKey = "OPEN_INCIDENT_COUNT"
	EntitySortKeyPrimaryDisplayName   EntitySortKey = "PRIMARY_DISPLAY_NAME"
	EntitySortKeySecondaryDisplayName EntitySortKey = "SECONDARY_DISPLAY_NAME"
	EntitySortKeyOu                   EntitySortKey = "OU"
	EntitySortKeyDepartment           EntitySortKey = "DEPARTMENT"
	EntitySortKeyLastUpdateTime       EntitySortKey = "LAST_UPDATE_TIME"
)

var AllEntitySortKey = []EntitySortKey{
	EntitySortKeyEntityID,
	EntitySortKeyRiskScore,
	EntitySortKeyMostRecentActivity,
	EntitySortKeyCreationTime,
	EntitySortKeyExpirationTime,
	EntitySortKeyOpenIncidentCount,
	EntitySortKeyPrimaryDisplayName,
	EntitySortKeySecondaryDisplayName,
	EntitySortKeyOu,
	EntitySortKeyDepartment,
	EntitySortKeyLastUpdateTime,
}

func (e EntitySortKey) IsValid() bool {
	switch e {
	case EntitySortKeyEntityID, EntitySortKeyRiskScore, EntitySortKeyMostRecentActivity, EntitySortKeyCreationTime, EntitySortKeyExpirationTime, EntitySortKeyOpenIncidentCount, EntitySortKeyPrimaryDisplayName, EntitySortKeySecondaryDisplayName, EntitySortKeyOu, EntitySortKeyDepartment, EntitySortKeyLastUpdateTime:
		return true
	}
	return false
}

func (e EntitySortKey) String() string {
	return string(e)
}

func (e *EntitySortKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntitySortKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntitySortKey", str)
	}
	return nil
}

func (e EntitySortKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of entity types.
type EntityType string

const (
	// A user entity represents a user account by the `UserEntity` interface.
	EntityTypeUser EntityType = "USER"
	// An endpoint entity represents an endpoint in the network or in a directory by the `EndpointEntity` interface.
	EntityTypeEndpoint EntityType = "ENDPOINT"
	// A cloud service entity represents a cloud application participating in SSO
	// activities by the `CloudServiceEntity` interface.
	EntityTypeCloudService EntityType = "CLOUD_SERVICE"
	// An entity-container entity represents an entity group, such as an LDAP group
	// of users, by the `EntityContainerEntity` interface.
	EntityTypeEntityContainer EntityType = "ENTITY_CONTAINER"
)

var AllEntityType = []EntityType{
	EntityTypeUser,
	EntityTypeEndpoint,
	EntityTypeCloudService,
	EntityTypeEntityContainer,
}

func (e EntityType) IsValid() bool {
	switch e {
	case EntityTypeUser, EntityTypeEndpoint, EntityTypeCloudService, EntityTypeEntityContainer:
		return true
	}
	return false
}

func (e EntityType) String() string {
	return string(e)
}

func (e *EntityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityType", str)
	}
	return nil
}

func (e EntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileOperationType string

const (
	FileOperationTypeGenericAccess FileOperationType = "GENERIC_ACCESS"
	FileOperationTypeModify        FileOperationType = "MODIFY"
	FileOperationTypeDownload      FileOperationType = "DOWNLOAD"
	FileOperationTypeMove          FileOperationType = "MOVE"
	FileOperationTypeCopy          FileOperationType = "COPY"
	FileOperationTypeRename        FileOperationType = "RENAME"
	FileOperationTypeDelete        FileOperationType = "DELETE"
	FileOperationTypeUpload        FileOperationType = "UPLOAD"
)

var AllFileOperationType = []FileOperationType{
	FileOperationTypeGenericAccess,
	FileOperationTypeModify,
	FileOperationTypeDownload,
	FileOperationTypeMove,
	FileOperationTypeCopy,
	FileOperationTypeRename,
	FileOperationTypeDelete,
	FileOperationTypeUpload,
}

func (e FileOperationType) IsValid() bool {
	switch e {
	case FileOperationTypeGenericAccess, FileOperationTypeModify, FileOperationTypeDownload, FileOperationTypeMove, FileOperationTypeCopy, FileOperationTypeRename, FileOperationTypeDelete, FileOperationTypeUpload:
		return true
	}
	return false
}

func (e FileOperationType) String() string {
	return string(e)
}

func (e *FileOperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileOperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileOperationType", str)
	}
	return nil
}

func (e FileOperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GeoJSONType string

const (
	GeoJSONTypePoint              GeoJSONType = "Point"
	GeoJSONTypeMultiPoint         GeoJSONType = "MultiPoint"
	GeoJSONTypeLineString         GeoJSONType = "LineString"
	GeoJSONTypeMultiLineString    GeoJSONType = "MultiLineString"
	GeoJSONTypePolygon            GeoJSONType = "Polygon"
	GeoJSONTypeMultiPolygon       GeoJSONType = "MultiPolygon"
	GeoJSONTypeGeometryCollection GeoJSONType = "GeometryCollection"
)

var AllGeoJSONType = []GeoJSONType{
	GeoJSONTypePoint,
	GeoJSONTypeMultiPoint,
	GeoJSONTypeLineString,
	GeoJSONTypeMultiLineString,
	GeoJSONTypePolygon,
	GeoJSONTypeMultiPolygon,
	GeoJSONTypeGeometryCollection,
}

func (e GeoJSONType) IsValid() bool {
	switch e {
	case GeoJSONTypePoint, GeoJSONTypeMultiPoint, GeoJSONTypeLineString, GeoJSONTypeMultiLineString, GeoJSONTypePolygon, GeoJSONTypeMultiPolygon, GeoJSONTypeGeometryCollection:
		return true
	}
	return false
}

func (e GeoJSONType) String() string {
	return string(e)
}

func (e *GeoJSONType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GeoJSONType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GeoJsonType", str)
	}
	return nil
}

func (e GeoJSONType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of `Incident` life-cycle stages.
type IncidentLifeCycleStage string

const (
	IncidentLifeCycleStageNew           IncidentLifeCycleStage = "NEW"
	IncidentLifeCycleStageInProgress    IncidentLifeCycleStage = "IN_PROGRESS"
	IncidentLifeCycleStageDismiss       IncidentLifeCycleStage = "DISMISS"
	IncidentLifeCycleStageFalsePositive IncidentLifeCycleStage = "FALSE_POSITIVE"
	IncidentLifeCycleStageResolved      IncidentLifeCycleStage = "RESOLVED"
	IncidentLifeCycleStageAutoResolved  IncidentLifeCycleStage = "AUTO_RESOLVED"
)

var AllIncidentLifeCycleStage = []IncidentLifeCycleStage{
	IncidentLifeCycleStageNew,
	IncidentLifeCycleStageInProgress,
	IncidentLifeCycleStageDismiss,
	IncidentLifeCycleStageFalsePositive,
	IncidentLifeCycleStageResolved,
	IncidentLifeCycleStageAutoResolved,
}

func (e IncidentLifeCycleStage) IsValid() bool {
	switch e {
	case IncidentLifeCycleStageNew, IncidentLifeCycleStageInProgress, IncidentLifeCycleStageDismiss, IncidentLifeCycleStageFalsePositive, IncidentLifeCycleStageResolved, IncidentLifeCycleStageAutoResolved:
		return true
	}
	return false
}

func (e IncidentLifeCycleStage) String() string {
	return string(e)
}

func (e *IncidentLifeCycleStage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentLifeCycleStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentLifeCycleStage", str)
	}
	return nil
}

func (e IncidentLifeCycleStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of incident life cycle stages valid as input for mutations (a subset of `IncidentLifeCycleStage`).
type IncidentLifeCycleStageInput string

const (
	IncidentLifeCycleStageInputNew           IncidentLifeCycleStageInput = "NEW"
	IncidentLifeCycleStageInputInProgress    IncidentLifeCycleStageInput = "IN_PROGRESS"
	IncidentLifeCycleStageInputDismiss       IncidentLifeCycleStageInput = "DISMISS"
	IncidentLifeCycleStageInputFalsePositive IncidentLifeCycleStageInput = "FALSE_POSITIVE"
	IncidentLifeCycleStageInputResolved      IncidentLifeCycleStageInput = "RESOLVED"
)

var AllIncidentLifeCycleStageInput = []IncidentLifeCycleStageInput{
	IncidentLifeCycleStageInputNew,
	IncidentLifeCycleStageInputInProgress,
	IncidentLifeCycleStageInputDismiss,
	IncidentLifeCycleStageInputFalsePositive,
	IncidentLifeCycleStageInputResolved,
}

func (e IncidentLifeCycleStageInput) IsValid() bool {
	switch e {
	case IncidentLifeCycleStageInputNew, IncidentLifeCycleStageInputInProgress, IncidentLifeCycleStageInputDismiss, IncidentLifeCycleStageInputFalsePositive, IncidentLifeCycleStageInputResolved:
		return true
	}
	return false
}

func (e IncidentLifeCycleStageInput) String() string {
	return string(e)
}

func (e *IncidentLifeCycleStageInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentLifeCycleStageInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentLifeCycleStageInput", str)
	}
	return nil
}

func (e IncidentLifeCycleStageInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of incident severities.
type IncidentSeverity string

const (
	IncidentSeverityInfo   IncidentSeverity = "INFO"
	IncidentSeverityLow    IncidentSeverity = "LOW"
	IncidentSeverityMedium IncidentSeverity = "MEDIUM"
	IncidentSeverityHigh   IncidentSeverity = "HIGH"
)

var AllIncidentSeverity = []IncidentSeverity{
	IncidentSeverityInfo,
	IncidentSeverityLow,
	IncidentSeverityMedium,
	IncidentSeverityHigh,
}

func (e IncidentSeverity) IsValid() bool {
	switch e {
	case IncidentSeverityInfo, IncidentSeverityLow, IncidentSeverityMedium, IncidentSeverityHigh:
		return true
	}
	return false
}

func (e IncidentSeverity) String() string {
	return string(e)
}

func (e *IncidentSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentSeverity", str)
	}
	return nil
}

func (e IncidentSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of sort options for the `Incidents` query API.
type IncidentSortKey string

const (
	// Sort by a value of `Incident:incidentId`.
	IncidentSortKeyIncidentID IncidentSortKey = "INCIDENT_ID"
	// Sort by a value of `Incident:severity`.
	IncidentSortKeySeverity IncidentSortKey = "SEVERITY"
	// Sort by a value of `Incident:startTime`.
	IncidentSortKeyStartTime IncidentSortKey = "START_TIME"
	// Sort by a value of `Incident:endTime`.
	IncidentSortKeyEndTime IncidentSortKey = "END_TIME"
	// Sort by a value of `Incident:type`.
	IncidentSortKeyType IncidentSortKey = "TYPE"
	// Sort by a value of `Incident:lifeCycleStage`.
	IncidentSortKeyStatus IncidentSortKey = "STATUS"
)

var AllIncidentSortKey = []IncidentSortKey{
	IncidentSortKeyIncidentID,
	IncidentSortKeySeverity,
	IncidentSortKeyStartTime,
	IncidentSortKeyEndTime,
	IncidentSortKeyType,
	IncidentSortKeyStatus,
}

func (e IncidentSortKey) IsValid() bool {
	switch e {
	case IncidentSortKeyIncidentID, IncidentSortKeySeverity, IncidentSortKeyStartTime, IncidentSortKeyEndTime, IncidentSortKeyType, IncidentSortKeyStatus:
		return true
	}
	return false
}

func (e IncidentSortKey) String() string {
	return string(e)
}

func (e *IncidentSortKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentSortKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentSortKey", str)
	}
	return nil
}

func (e IncidentSortKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of `Incident` types.
type IncidentType string

const (
	// Activity is classified as anomalous behavior pattern based on baseline and user similarity.
	IncidentTypeUnusualEndpointAccess IncidentType = "UNUSUAL_ENDPOINT_ACCESS"
	// A user request to service is classified as anomalous behavior pattern based on learned profile and user similarity.
	IncidentTypeUnusualServiceAccess IncidentType = "UNUSUAL_SERVICE_ACCESS"
	// User seen coming from a location that deviates from their baseline.
	IncidentTypeUnusualEndpointUse IncidentType = "UNUSUAL_ENDPOINT_USE"
	// Some activity may indicate start of reconnaissance. This happens when
	// adversaries try to gather information on your domain.
	IncidentTypeSuspiciousDomainActivity IncidentType = "SUSPICIOUS_DOMAIN_ACTIVITY"
	// Anomalous user access patterns were detected. Such activities may indicate
	// potential threats, such as endpoint infection, compromised account or other risks.
	IncidentTypePotentialRiskyActivity IncidentType = "POTENTIAL_RISKY_ACTIVITY"
	// In an advanced attack, a Domain Controller vulnerability was exploited and the entire domain has been compromised.
	IncidentTypeDomainCompromise IncidentType = "DOMAIN_COMPROMISE"
	// An account's credentials may have been stolen.
	IncidentTypeCredentialTheft IncidentType = "CREDENTIAL_THEFT"
	// An endpoint may be infected and controlled by a malicious party.
	IncidentTypeEndpointCompromise IncidentType = "ENDPOINT_COMPROMISE"
	// User is accessing and connecting from multiple locations, that are anomalous
	// to the user baseline and their peer users. Such behavior may indicate
	// potential lateral movement, domain reconnaissance, credentials theft and other risks.
	IncidentTypeSuspiciousMovement IncidentType = "SUSPICIOUS_MOVEMENT"
	// Anomalous user access patterns were detected. Such activities may indicate
	// potential threats, such as endpoint infection, compromised account or other risks.
	IncidentTypeUnusualActivity IncidentType = "UNUSUAL_ACTIVITY"
)

var AllIncidentType = []IncidentType{
	IncidentTypeUnusualEndpointAccess,
	IncidentTypeUnusualServiceAccess,
	IncidentTypeUnusualEndpointUse,
	IncidentTypeSuspiciousDomainActivity,
	IncidentTypePotentialRiskyActivity,
	IncidentTypeDomainCompromise,
	IncidentTypeCredentialTheft,
	IncidentTypeEndpointCompromise,
	IncidentTypeSuspiciousMovement,
	IncidentTypeUnusualActivity,
}

func (e IncidentType) IsValid() bool {
	switch e {
	case IncidentTypeUnusualEndpointAccess, IncidentTypeUnusualServiceAccess, IncidentTypeUnusualEndpointUse, IncidentTypeSuspiciousDomainActivity, IncidentTypePotentialRiskyActivity, IncidentTypeDomainCompromise, IncidentTypeCredentialTheft, IncidentTypeEndpointCompromise, IncidentTypeSuspiciousMovement, IncidentTypeUnusualActivity:
		return true
	}
	return false
}

func (e IncidentType) String() string {
	return string(e)
}

func (e *IncidentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentType", str)
	}
	return nil
}

func (e IncidentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IPReputation string

const (
	IPReputationAnonymousActive   IPReputation = "ANONYMOUS_ACTIVE"
	IPReputationAnonymousSuspect  IPReputation = "ANONYMOUS_SUSPECT"
	IPReputationAnonymousInactive IPReputation = "ANONYMOUS_INACTIVE"
	IPReputationAnonymousPrivate  IPReputation = "ANONYMOUS_PRIVATE"
	IPReputationDictionaryAttack  IPReputation = "DICTIONARY_ATTACK"
	IPReputationDdosAttack        IPReputation = "DDOS_ATTACK"
	IPReputationSpam              IPReputation = "SPAM"
	IPReputationHostingFacility   IPReputation = "HOSTING_FACILITY"
)

var AllIPReputation = []IPReputation{
	IPReputationAnonymousActive,
	IPReputationAnonymousSuspect,
	IPReputationAnonymousInactive,
	IPReputationAnonymousPrivate,
	IPReputationDictionaryAttack,
	IPReputationDdosAttack,
	IPReputationSpam,
	IPReputationHostingFacility,
}

func (e IPReputation) IsValid() bool {
	switch e {
	case IPReputationAnonymousActive, IPReputationAnonymousSuspect, IPReputationAnonymousInactive, IPReputationAnonymousPrivate, IPReputationDictionaryAttack, IPReputationDdosAttack, IPReputationSpam, IPReputationHostingFacility:
		return true
	}
	return false
}

func (e IPReputation) String() string {
	return string(e)
}

func (e *IPReputation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPReputation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpReputation", str)
	}
	return nil
}

func (e IPReputation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IspClassification string

const (
	IspClassificationCom    IspClassification = "COM"
	IspClassificationOrg    IspClassification = "ORG"
	IspClassificationGov    IspClassification = "GOV"
	IspClassificationMil    IspClassification = "MIL"
	IspClassificationEdu    IspClassification = "EDU"
	IspClassificationLib    IspClassification = "LIB"
	IspClassificationCdn    IspClassification = "CDN"
	IspClassificationIsp    IspClassification = "ISP"
	IspClassificationMob    IspClassification = "MOB"
	IspClassificationDch    IspClassification = "DCH"
	IspClassificationSes    IspClassification = "SES"
	IspClassificationRsv    IspClassification = "RSV"
	IspClassificationIspMob IspClassification = "ISP_MOB"
	IspClassificationNone   IspClassification = "NONE"
)

var AllIspClassification = []IspClassification{
	IspClassificationCom,
	IspClassificationOrg,
	IspClassificationGov,
	IspClassificationMil,
	IspClassificationEdu,
	IspClassificationLib,
	IspClassificationCdn,
	IspClassificationIsp,
	IspClassificationMob,
	IspClassificationDch,
	IspClassificationSes,
	IspClassificationRsv,
	IspClassificationIspMob,
	IspClassificationNone,
}

func (e IspClassification) IsValid() bool {
	switch e {
	case IspClassificationCom, IspClassificationOrg, IspClassificationGov, IspClassificationMil, IspClassificationEdu, IspClassificationLib, IspClassificationCdn, IspClassificationIsp, IspClassificationMob, IspClassificationDch, IspClassificationSes, IspClassificationRsv, IspClassificationIspMob, IspClassificationNone:
		return true
	}
	return false
}

func (e IspClassification) String() string {
	return string(e)
}

func (e *IspClassification) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IspClassification(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IspClassification", str)
	}
	return nil
}

func (e IspClassification) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type KerberosEncryptionType string

const (
	KerberosEncryptionTypeDesCbcCrc                 KerberosEncryptionType = "DES_CBC_CRC"
	KerberosEncryptionTypeDesCbcMd4                 KerberosEncryptionType = "DES_CBC_MD4"
	KerberosEncryptionTypeDesCbcMd5                 KerberosEncryptionType = "DES_CBC_MD5"
	KerberosEncryptionTypeDesCbcRaw                 KerberosEncryptionType = "DES_CBC_RAW"
	KerberosEncryptionTypeDes3CbcSha                KerberosEncryptionType = "DES3_CBC_SHA"
	KerberosEncryptionTypeDes3CbcRaw                KerberosEncryptionType = "DES3_CBC_RAW"
	KerberosEncryptionTypeDesHmacSha1               KerberosEncryptionType = "DES_HMAC_SHA1"
	KerberosEncryptionTypeDsaSha1Cms                KerberosEncryptionType = "DSA_SHA1_CMS"
	KerberosEncryptionTypeMd5RsaCms                 KerberosEncryptionType = "MD5_RSA_CMS"
	KerberosEncryptionTypeSha1RsaCms                KerberosEncryptionType = "SHA1_RSA_CMS"
	KerberosEncryptionTypeRc2CbcEnv                 KerberosEncryptionType = "RC2_CBC_ENV"
	KerberosEncryptionTypeRsaEnv                    KerberosEncryptionType = "RSA_ENV"
	KerberosEncryptionTypeRsaEsOaepEnv              KerberosEncryptionType = "RSA_ES_OAEP_ENV"
	KerberosEncryptionTypeDes3CbcEnv                KerberosEncryptionType = "DES3_CBC_ENV"
	KerberosEncryptionTypeDes3CbcSha1               KerberosEncryptionType = "DES3_CBC_SHA1"
	KerberosEncryptionTypeAes128CtsHmacSha1_96      KerberosEncryptionType = "AES128_CTS_HMAC_SHA1_96"
	KerberosEncryptionTypeAes256CtsHmacSha1_96      KerberosEncryptionType = "AES256_CTS_HMAC_SHA1_96"
	KerberosEncryptionTypeAes128CtsHmacSha256_128   KerberosEncryptionType = "AES128_CTS_HMAC_SHA256_128"
	KerberosEncryptionTypeDesCbcMd5Nt               KerberosEncryptionType = "DES_CBC_MD5_NT"
	KerberosEncryptionTypeRc4HmacNt                 KerberosEncryptionType = "RC4_HMAC_NT"
	KerberosEncryptionTypeRc4HmacNtExp              KerberosEncryptionType = "RC4_HMAC_NT_EXP"
	KerberosEncryptionTypeCamellia128CtsCmac        KerberosEncryptionType = "CAMELLIA128_CTS_CMAC"
	KerberosEncryptionTypeCamellia256CtsCmac        KerberosEncryptionType = "CAMELLIA256_CTS_CMAC"
	KerberosEncryptionTypeRc4Md4                    KerberosEncryptionType = "RC4_MD4"
	KerberosEncryptionTypeRc4Plain2                 KerberosEncryptionType = "RC4_PLAIN2"
	KerberosEncryptionTypeRc4Lm                     KerberosEncryptionType = "RC4_LM"
	KerberosEncryptionTypeRc4Sha                    KerberosEncryptionType = "RC4_SHA"
	KerberosEncryptionTypeDesPlain                  KerberosEncryptionType = "DES_PLAIN"
	KerberosEncryptionTypeRc4HmacOld                KerberosEncryptionType = "RC4_HMAC_OLD"
	KerberosEncryptionTypeRc4PlainOld               KerberosEncryptionType = "RC4_PLAIN_OLD"
	KerberosEncryptionTypeRc4HmacOldExp             KerberosEncryptionType = "RC4_HMAC_OLD_EXP"
	KerberosEncryptionTypeRc4PlainOldExp            KerberosEncryptionType = "RC4_PLAIN_OLD_EXP"
	KerberosEncryptionTypeRc4Plain                  KerberosEncryptionType = "RC4_PLAIN"
	KerberosEncryptionTypeRc4PlainExp               KerberosEncryptionType = "RC4_PLAIN_EXP"
	KerberosEncryptionTypeAes128CtsHmacSha1_96Plain KerberosEncryptionType = "AES128_CTS_HMAC_SHA1_96_PLAIN"
	KerberosEncryptionTypeAes256CtsHmacSha1_96Plain KerberosEncryptionType = "AES256_CTS_HMAC_SHA1_96_PLAIN"
)

var AllKerberosEncryptionType = []KerberosEncryptionType{
	KerberosEncryptionTypeDesCbcCrc,
	KerberosEncryptionTypeDesCbcMd4,
	KerberosEncryptionTypeDesCbcMd5,
	KerberosEncryptionTypeDesCbcRaw,
	KerberosEncryptionTypeDes3CbcSha,
	KerberosEncryptionTypeDes3CbcRaw,
	KerberosEncryptionTypeDesHmacSha1,
	KerberosEncryptionTypeDsaSha1Cms,
	KerberosEncryptionTypeMd5RsaCms,
	KerberosEncryptionTypeSha1RsaCms,
	KerberosEncryptionTypeRc2CbcEnv,
	KerberosEncryptionTypeRsaEnv,
	KerberosEncryptionTypeRsaEsOaepEnv,
	KerberosEncryptionTypeDes3CbcEnv,
	KerberosEncryptionTypeDes3CbcSha1,
	KerberosEncryptionTypeAes128CtsHmacSha1_96,
	KerberosEncryptionTypeAes256CtsHmacSha1_96,
	KerberosEncryptionTypeAes128CtsHmacSha256_128,
	KerberosEncryptionTypeDesCbcMd5Nt,
	KerberosEncryptionTypeRc4HmacNt,
	KerberosEncryptionTypeRc4HmacNtExp,
	KerberosEncryptionTypeCamellia128CtsCmac,
	KerberosEncryptionTypeCamellia256CtsCmac,
	KerberosEncryptionTypeRc4Md4,
	KerberosEncryptionTypeRc4Plain2,
	KerberosEncryptionTypeRc4Lm,
	KerberosEncryptionTypeRc4Sha,
	KerberosEncryptionTypeDesPlain,
	KerberosEncryptionTypeRc4HmacOld,
	KerberosEncryptionTypeRc4PlainOld,
	KerberosEncryptionTypeRc4HmacOldExp,
	KerberosEncryptionTypeRc4PlainOldExp,
	KerberosEncryptionTypeRc4Plain,
	KerberosEncryptionTypeRc4PlainExp,
	KerberosEncryptionTypeAes128CtsHmacSha1_96Plain,
	KerberosEncryptionTypeAes256CtsHmacSha1_96Plain,
}

func (e KerberosEncryptionType) IsValid() bool {
	switch e {
	case KerberosEncryptionTypeDesCbcCrc, KerberosEncryptionTypeDesCbcMd4, KerberosEncryptionTypeDesCbcMd5, KerberosEncryptionTypeDesCbcRaw, KerberosEncryptionTypeDes3CbcSha, KerberosEncryptionTypeDes3CbcRaw, KerberosEncryptionTypeDesHmacSha1, KerberosEncryptionTypeDsaSha1Cms, KerberosEncryptionTypeMd5RsaCms, KerberosEncryptionTypeSha1RsaCms, KerberosEncryptionTypeRc2CbcEnv, KerberosEncryptionTypeRsaEnv, KerberosEncryptionTypeRsaEsOaepEnv, KerberosEncryptionTypeDes3CbcEnv, KerberosEncryptionTypeDes3CbcSha1, KerberosEncryptionTypeAes128CtsHmacSha1_96, KerberosEncryptionTypeAes256CtsHmacSha1_96, KerberosEncryptionTypeAes128CtsHmacSha256_128, KerberosEncryptionTypeDesCbcMd5Nt, KerberosEncryptionTypeRc4HmacNt, KerberosEncryptionTypeRc4HmacNtExp, KerberosEncryptionTypeCamellia128CtsCmac, KerberosEncryptionTypeCamellia256CtsCmac, KerberosEncryptionTypeRc4Md4, KerberosEncryptionTypeRc4Plain2, KerberosEncryptionTypeRc4Lm, KerberosEncryptionTypeRc4Sha, KerberosEncryptionTypeDesPlain, KerberosEncryptionTypeRc4HmacOld, KerberosEncryptionTypeRc4PlainOld, KerberosEncryptionTypeRc4HmacOldExp, KerberosEncryptionTypeRc4PlainOldExp, KerberosEncryptionTypeRc4Plain, KerberosEncryptionTypeRc4PlainExp, KerberosEncryptionTypeAes128CtsHmacSha1_96Plain, KerberosEncryptionTypeAes256CtsHmacSha1_96Plain:
		return true
	}
	return false
}

func (e KerberosEncryptionType) String() string {
	return string(e)
}

func (e *KerberosEncryptionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KerberosEncryptionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KerberosEncryptionType", str)
	}
	return nil
}

func (e KerberosEncryptionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of the Kerberos protocol standard error codes.
type KrbErrCode string

const (
	KrbErrCodeKdcErrNone                            KrbErrCode = "KDC_ERR_NONE"
	KrbErrCodeKdcErrNameExp                         KrbErrCode = "KDC_ERR_NAME_EXP"
	KrbErrCodeKdcErrServiceExp                      KrbErrCode = "KDC_ERR_SERVICE_EXP"
	KrbErrCodeKdcErrBadPvno                         KrbErrCode = "KDC_ERR_BAD_PVNO"
	KrbErrCodeKdcErrCOldMastKvno                    KrbErrCode = "KDC_ERR_C_OLD_MAST_KVNO"
	KrbErrCodeKdcErrSOldMastKvno                    KrbErrCode = "KDC_ERR_S_OLD_MAST_KVNO"
	KrbErrCodeKdcErrCPrincipalUnknown               KrbErrCode = "KDC_ERR_C_PRINCIPAL_UNKNOWN"
	KrbErrCodeKdcErrSPrincipalUnknown               KrbErrCode = "KDC_ERR_S_PRINCIPAL_UNKNOWN"
	KrbErrCodeKdcErrPrincipalNotUnique              KrbErrCode = "KDC_ERR_PRINCIPAL_NOT_UNIQUE"
	KrbErrCodeKdcErrNullKey                         KrbErrCode = "KDC_ERR_NULL_KEY"
	KrbErrCodeKdcErrCannotPostdate                  KrbErrCode = "KDC_ERR_CANNOT_POSTDATE"
	KrbErrCodeKdcErrNeverValid                      KrbErrCode = "KDC_ERR_NEVER_VALID"
	KrbErrCodeKdcErrPolicy                          KrbErrCode = "KDC_ERR_POLICY"
	KrbErrCodeKdcErrBadoption                       KrbErrCode = "KDC_ERR_BADOPTION"
	KrbErrCodeKdcErrEnctypeNosupp                   KrbErrCode = "KDC_ERR_ENCTYPE_NOSUPP"
	KrbErrCodeKdcErrSumtypeNosupp                   KrbErrCode = "KDC_ERR_SUMTYPE_NOSUPP"
	KrbErrCodeKdcErrPadataTypeNosupp                KrbErrCode = "KDC_ERR_PADATA_TYPE_NOSUPP"
	KrbErrCodeKdcErrTrtypeNosupp                    KrbErrCode = "KDC_ERR_TRTYPE_NOSUPP"
	KrbErrCodeKdcErrClientRevoked                   KrbErrCode = "KDC_ERR_CLIENT_REVOKED"
	KrbErrCodeKdcErrServiceRevoked                  KrbErrCode = "KDC_ERR_SERVICE_REVOKED"
	KrbErrCodeKdcErrTgtRevoked                      KrbErrCode = "KDC_ERR_TGT_REVOKED"
	KrbErrCodeKdcErrClientNotyet                    KrbErrCode = "KDC_ERR_CLIENT_NOTYET"
	KrbErrCodeKdcErrServiceNotyet                   KrbErrCode = "KDC_ERR_SERVICE_NOTYET"
	KrbErrCodeKdcErrKeyExp                          KrbErrCode = "KDC_ERR_KEY_EXP"
	KrbErrCodeKdcErrPreauthFailed                   KrbErrCode = "KDC_ERR_PREAUTH_FAILED"
	KrbErrCodeKdcErrPreauthRequired                 KrbErrCode = "KDC_ERR_PREAUTH_REQUIRED"
	KrbErrCodeKdcErrServerNomatch                   KrbErrCode = "KDC_ERR_SERVER_NOMATCH"
	KrbErrCodeKdcErrMustUseUser2user                KrbErrCode = "KDC_ERR_MUST_USE_USER2USER"
	KrbErrCodeKdcErrPathNotAccepted                 KrbErrCode = "KDC_ERR_PATH_NOT_ACCEPTED"
	KrbErrCodeKdcErrSvcUnavailable                  KrbErrCode = "KDC_ERR_SVC_UNAVAILABLE"
	KrbErrCodeKrbApErrBadIntegrity                  KrbErrCode = "KRB_AP_ERR_BAD_INTEGRITY"
	KrbErrCodeKrbApErrTktExpired                    KrbErrCode = "KRB_AP_ERR_TKT_EXPIRED"
	KrbErrCodeKrbApErrTktNyv                        KrbErrCode = "KRB_AP_ERR_TKT_NYV"
	KrbErrCodeKrbApErrRepeat                        KrbErrCode = "KRB_AP_ERR_REPEAT"
	KrbErrCodeKrbApErrNotUs                         KrbErrCode = "KRB_AP_ERR_NOT_US"
	KrbErrCodeKrbApErrBadmatch                      KrbErrCode = "KRB_AP_ERR_BADMATCH"
	KrbErrCodeKrbApErrSkew                          KrbErrCode = "KRB_AP_ERR_SKEW"
	KrbErrCodeKrbApErrBadaddr                       KrbErrCode = "KRB_AP_ERR_BADADDR"
	KrbErrCodeKrbApErrBadversion                    KrbErrCode = "KRB_AP_ERR_BADVERSION"
	KrbErrCodeKrbApErrMsgType                       KrbErrCode = "KRB_AP_ERR_MSG_TYPE"
	KrbErrCodeKrbApErrModified                      KrbErrCode = "KRB_AP_ERR_MODIFIED"
	KrbErrCodeKrbApErrBadorder                      KrbErrCode = "KRB_AP_ERR_BADORDER"
	KrbErrCodeKrbApErrBadkeyver                     KrbErrCode = "KRB_AP_ERR_BADKEYVER"
	KrbErrCodeKrbApErrNokey                         KrbErrCode = "KRB_AP_ERR_NOKEY"
	KrbErrCodeKrbApErrMutFail                       KrbErrCode = "KRB_AP_ERR_MUT_FAIL"
	KrbErrCodeKrbApErrBaddirection                  KrbErrCode = "KRB_AP_ERR_BADDIRECTION"
	KrbErrCodeKrbApErrMethod                        KrbErrCode = "KRB_AP_ERR_METHOD"
	KrbErrCodeKrbApErrBadseq                        KrbErrCode = "KRB_AP_ERR_BADSEQ"
	KrbErrCodeKrbApErrInappCksum                    KrbErrCode = "KRB_AP_ERR_INAPP_CKSUM"
	KrbErrCodeKrbApPathNotAccepted                  KrbErrCode = "KRB_AP_PATH_NOT_ACCEPTED"
	KrbErrCodeKrbErrResponseTooBig                  KrbErrCode = "KRB_ERR_RESPONSE_TOO_BIG"
	KrbErrCodeKrbErrGeneric                         KrbErrCode = "KRB_ERR_GENERIC"
	KrbErrCodeKrbErrFieldToolong                    KrbErrCode = "KRB_ERR_FIELD_TOOLONG"
	KrbErrCodeKdcErrClientNotTrusted                KrbErrCode = "KDC_ERR_CLIENT_NOT_TRUSTED"
	KrbErrCodeKdcErrKdcNotTrusted                   KrbErrCode = "KDC_ERR_KDC_NOT_TRUSTED"
	KrbErrCodeKdcErrInvalidSig                      KrbErrCode = "KDC_ERR_INVALID_SIG"
	KrbErrCodeKdcErrDhKeyParametersNotAccepted      KrbErrCode = "KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED"
	KrbErrCodeKdcErrCertificateMismatch             KrbErrCode = "KDC_ERR_CERTIFICATE_MISMATCH"
	KrbErrCodeKrbApErrNoTgt                         KrbErrCode = "KRB_AP_ERR_NO_TGT"
	KrbErrCodeKdcErrWrongRealm                      KrbErrCode = "KDC_ERR_WRONG_REALM"
	KrbErrCodeKrbApErrUserToUserRequired            KrbErrCode = "KRB_AP_ERR_USER_TO_USER_REQUIRED"
	KrbErrCodeKdcErrCantVerifyCertificate           KrbErrCode = "KDC_ERR_CANT_VERIFY_CERTIFICATE"
	KrbErrCodeKdcErrInvalidCertificate              KrbErrCode = "KDC_ERR_INVALID_CERTIFICATE"
	KrbErrCodeKdcErrRevokedCertificate              KrbErrCode = "KDC_ERR_REVOKED_CERTIFICATE"
	KrbErrCodeKdcErrRevocationStatusUnknown         KrbErrCode = "KDC_ERR_REVOCATION_STATUS_UNKNOWN"
	KrbErrCodeKdcErrRevocationStatusUnavailable     KrbErrCode = "KDC_ERR_REVOCATION_STATUS_UNAVAILABLE"
	KrbErrCodeKdcErrClientNameMismatch              KrbErrCode = "KDC_ERR_CLIENT_NAME_MISMATCH"
	KrbErrCodeKdcErrInconsistentKeyPurpose          KrbErrCode = "KDC_ERR_INCONSISTENT_KEY_PURPOSE"
	KrbErrCodeKdcErrDigestInCertNotAccepted         KrbErrCode = "KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED"
	KrbErrCodeKdcErrPaChecksumMustBeIncluded        KrbErrCode = "KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED"
	KrbErrCodeKdcErrDigestInSignedDataNotAccepted   KrbErrCode = "KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED"
	KrbErrCodeKdcErrPublicKeyEncryptionNotSupported KrbErrCode = "KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED"
	KrbErrCodeKrbApErrIakerbKdcNotFound             KrbErrCode = "KRB_AP_ERR_IAKERB_KDC_NOT_FOUND"
	KrbErrCodeKrbApErrIakerbKdcNoResponse           KrbErrCode = "KRB_AP_ERR_IAKERB_KDC_NO_RESPONSE"
	KrbErrCodeKrbErrMax                             KrbErrCode = "KRB_ERR_MAX"
)

var AllKrbErrCode = []KrbErrCode{
	KrbErrCodeKdcErrNone,
	KrbErrCodeKdcErrNameExp,
	KrbErrCodeKdcErrServiceExp,
	KrbErrCodeKdcErrBadPvno,
	KrbErrCodeKdcErrCOldMastKvno,
	KrbErrCodeKdcErrSOldMastKvno,
	KrbErrCodeKdcErrCPrincipalUnknown,
	KrbErrCodeKdcErrSPrincipalUnknown,
	KrbErrCodeKdcErrPrincipalNotUnique,
	KrbErrCodeKdcErrNullKey,
	KrbErrCodeKdcErrCannotPostdate,
	KrbErrCodeKdcErrNeverValid,
	KrbErrCodeKdcErrPolicy,
	KrbErrCodeKdcErrBadoption,
	KrbErrCodeKdcErrEnctypeNosupp,
	KrbErrCodeKdcErrSumtypeNosupp,
	KrbErrCodeKdcErrPadataTypeNosupp,
	KrbErrCodeKdcErrTrtypeNosupp,
	KrbErrCodeKdcErrClientRevoked,
	KrbErrCodeKdcErrServiceRevoked,
	KrbErrCodeKdcErrTgtRevoked,
	KrbErrCodeKdcErrClientNotyet,
	KrbErrCodeKdcErrServiceNotyet,
	KrbErrCodeKdcErrKeyExp,
	KrbErrCodeKdcErrPreauthFailed,
	KrbErrCodeKdcErrPreauthRequired,
	KrbErrCodeKdcErrServerNomatch,
	KrbErrCodeKdcErrMustUseUser2user,
	KrbErrCodeKdcErrPathNotAccepted,
	KrbErrCodeKdcErrSvcUnavailable,
	KrbErrCodeKrbApErrBadIntegrity,
	KrbErrCodeKrbApErrTktExpired,
	KrbErrCodeKrbApErrTktNyv,
	KrbErrCodeKrbApErrRepeat,
	KrbErrCodeKrbApErrNotUs,
	KrbErrCodeKrbApErrBadmatch,
	KrbErrCodeKrbApErrSkew,
	KrbErrCodeKrbApErrBadaddr,
	KrbErrCodeKrbApErrBadversion,
	KrbErrCodeKrbApErrMsgType,
	KrbErrCodeKrbApErrModified,
	KrbErrCodeKrbApErrBadorder,
	KrbErrCodeKrbApErrBadkeyver,
	KrbErrCodeKrbApErrNokey,
	KrbErrCodeKrbApErrMutFail,
	KrbErrCodeKrbApErrBaddirection,
	KrbErrCodeKrbApErrMethod,
	KrbErrCodeKrbApErrBadseq,
	KrbErrCodeKrbApErrInappCksum,
	KrbErrCodeKrbApPathNotAccepted,
	KrbErrCodeKrbErrResponseTooBig,
	KrbErrCodeKrbErrGeneric,
	KrbErrCodeKrbErrFieldToolong,
	KrbErrCodeKdcErrClientNotTrusted,
	KrbErrCodeKdcErrKdcNotTrusted,
	KrbErrCodeKdcErrInvalidSig,
	KrbErrCodeKdcErrDhKeyParametersNotAccepted,
	KrbErrCodeKdcErrCertificateMismatch,
	KrbErrCodeKrbApErrNoTgt,
	KrbErrCodeKdcErrWrongRealm,
	KrbErrCodeKrbApErrUserToUserRequired,
	KrbErrCodeKdcErrCantVerifyCertificate,
	KrbErrCodeKdcErrInvalidCertificate,
	KrbErrCodeKdcErrRevokedCertificate,
	KrbErrCodeKdcErrRevocationStatusUnknown,
	KrbErrCodeKdcErrRevocationStatusUnavailable,
	KrbErrCodeKdcErrClientNameMismatch,
	KrbErrCodeKdcErrInconsistentKeyPurpose,
	KrbErrCodeKdcErrDigestInCertNotAccepted,
	KrbErrCodeKdcErrPaChecksumMustBeIncluded,
	KrbErrCodeKdcErrDigestInSignedDataNotAccepted,
	KrbErrCodeKdcErrPublicKeyEncryptionNotSupported,
	KrbErrCodeKrbApErrIakerbKdcNotFound,
	KrbErrCodeKrbApErrIakerbKdcNoResponse,
	KrbErrCodeKrbErrMax,
}

func (e KrbErrCode) IsValid() bool {
	switch e {
	case KrbErrCodeKdcErrNone, KrbErrCodeKdcErrNameExp, KrbErrCodeKdcErrServiceExp, KrbErrCodeKdcErrBadPvno, KrbErrCodeKdcErrCOldMastKvno, KrbErrCodeKdcErrSOldMastKvno, KrbErrCodeKdcErrCPrincipalUnknown, KrbErrCodeKdcErrSPrincipalUnknown, KrbErrCodeKdcErrPrincipalNotUnique, KrbErrCodeKdcErrNullKey, KrbErrCodeKdcErrCannotPostdate, KrbErrCodeKdcErrNeverValid, KrbErrCodeKdcErrPolicy, KrbErrCodeKdcErrBadoption, KrbErrCodeKdcErrEnctypeNosupp, KrbErrCodeKdcErrSumtypeNosupp, KrbErrCodeKdcErrPadataTypeNosupp, KrbErrCodeKdcErrTrtypeNosupp, KrbErrCodeKdcErrClientRevoked, KrbErrCodeKdcErrServiceRevoked, KrbErrCodeKdcErrTgtRevoked, KrbErrCodeKdcErrClientNotyet, KrbErrCodeKdcErrServiceNotyet, KrbErrCodeKdcErrKeyExp, KrbErrCodeKdcErrPreauthFailed, KrbErrCodeKdcErrPreauthRequired, KrbErrCodeKdcErrServerNomatch, KrbErrCodeKdcErrMustUseUser2user, KrbErrCodeKdcErrPathNotAccepted, KrbErrCodeKdcErrSvcUnavailable, KrbErrCodeKrbApErrBadIntegrity, KrbErrCodeKrbApErrTktExpired, KrbErrCodeKrbApErrTktNyv, KrbErrCodeKrbApErrRepeat, KrbErrCodeKrbApErrNotUs, KrbErrCodeKrbApErrBadmatch, KrbErrCodeKrbApErrSkew, KrbErrCodeKrbApErrBadaddr, KrbErrCodeKrbApErrBadversion, KrbErrCodeKrbApErrMsgType, KrbErrCodeKrbApErrModified, KrbErrCodeKrbApErrBadorder, KrbErrCodeKrbApErrBadkeyver, KrbErrCodeKrbApErrNokey, KrbErrCodeKrbApErrMutFail, KrbErrCodeKrbApErrBaddirection, KrbErrCodeKrbApErrMethod, KrbErrCodeKrbApErrBadseq, KrbErrCodeKrbApErrInappCksum, KrbErrCodeKrbApPathNotAccepted, KrbErrCodeKrbErrResponseTooBig, KrbErrCodeKrbErrGeneric, KrbErrCodeKrbErrFieldToolong, KrbErrCodeKdcErrClientNotTrusted, KrbErrCodeKdcErrKdcNotTrusted, KrbErrCodeKdcErrInvalidSig, KrbErrCodeKdcErrDhKeyParametersNotAccepted, KrbErrCodeKdcErrCertificateMismatch, KrbErrCodeKrbApErrNoTgt, KrbErrCodeKdcErrWrongRealm, KrbErrCodeKrbApErrUserToUserRequired, KrbErrCodeKdcErrCantVerifyCertificate, KrbErrCodeKdcErrInvalidCertificate, KrbErrCodeKdcErrRevokedCertificate, KrbErrCodeKdcErrRevocationStatusUnknown, KrbErrCodeKdcErrRevocationStatusUnavailable, KrbErrCodeKdcErrClientNameMismatch, KrbErrCodeKdcErrInconsistentKeyPurpose, KrbErrCodeKdcErrDigestInCertNotAccepted, KrbErrCodeKdcErrPaChecksumMustBeIncluded, KrbErrCodeKdcErrDigestInSignedDataNotAccepted, KrbErrCodeKdcErrPublicKeyEncryptionNotSupported, KrbErrCodeKrbApErrIakerbKdcNotFound, KrbErrCodeKrbApErrIakerbKdcNoResponse, KrbErrCodeKrbErrMax:
		return true
	}
	return false
}

func (e KrbErrCode) String() string {
	return string(e)
}

func (e *KrbErrCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KrbErrCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KrbErrCode", str)
	}
	return nil
}

func (e KrbErrCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LdapBindResult string

const (
	LdapBindResultSuccess                       LdapBindResult = "SUCCESS"
	LdapBindResultOperationError                LdapBindResult = "OPERATION_ERROR"
	LdapBindResultProtocolError                 LdapBindResult = "PROTOCOL_ERROR"
	LdapBindResultTimeLimitExceeded             LdapBindResult = "TIME_LIMIT_EXCEEDED"
	LdapBindResultSizeLimitExceeded             LdapBindResult = "SIZE_LIMIT_EXCEEDED"
	LdapBindResultCompareFalse                  LdapBindResult = "COMPARE_FALSE"
	LdapBindResultCompareTrue                   LdapBindResult = "COMPARE_TRUE"
	LdapBindResultAuthMethodNotSupported        LdapBindResult = "AUTH_METHOD_NOT_SUPPORTED"
	LdapBindResultStrongerAuthRequired          LdapBindResult = "STRONGER_AUTH_REQUIRED"
	LdapBindResultReferral                      LdapBindResult = "REFERRAL"
	LdapBindResultAdminLimitExceeded            LdapBindResult = "ADMIN_LIMIT_EXCEEDED"
	LdapBindResultUnavailableCriticialExtension LdapBindResult = "UNAVAILABLE_CRITICIAL_EXTENSION"
	LdapBindResultConfidentialityRequired       LdapBindResult = "CONFIDENTIALITY_REQUIRED"
	LdapBindResultSaslBindInProgress            LdapBindResult = "SASL_BIND_IN_PROGRESS"
	LdapBindResultNoSuchAttribute               LdapBindResult = "NO_SUCH_ATTRIBUTE"
	LdapBindResultUndefinedType                 LdapBindResult = "UNDEFINED_TYPE"
	LdapBindResultInappropriateMatching         LdapBindResult = "INAPPROPRIATE_MATCHING"
	LdapBindResultConstantViolation             LdapBindResult = "CONSTANT_VIOLATION"
	LdapBindResultTypeOrValueExists             LdapBindResult = "TYPE_OR_VALUE_EXISTS"
	LdapBindResultInvalidSyntax                 LdapBindResult = "INVALID_SYNTAX"
	LdapBindResultNoSuchObject                  LdapBindResult = "NO_SUCH_OBJECT"
	LdapBindResultAliasProblem                  LdapBindResult = "ALIAS_PROBLEM"
	LdapBindResultInvalidDnSyntax               LdapBindResult = "INVALID_DN_SYNTAX"
	LdapBindResultIsLeaf                        LdapBindResult = "IS_LEAF"
	LdapBindResultAliasDerefProblem             LdapBindResult = "ALIAS_DEREF_PROBLEM"
	LdapBindResultInappropriateAuth             LdapBindResult = "INAPPROPRIATE_AUTH"
	LdapBindResultInvalidCredentials            LdapBindResult = "INVALID_CREDENTIALS"
	LdapBindResultInsufficientAccess            LdapBindResult = "INSUFFICIENT_ACCESS"
	LdapBindResultBusy                          LdapBindResult = "BUSY"
	LdapBindResultUnavailable                   LdapBindResult = "UNAVAILABLE"
	LdapBindResultUnwillingToPerform            LdapBindResult = "UNWILLING_TO_PERFORM"
	LdapBindResultLoopDetect                    LdapBindResult = "LOOP_DETECT"
	LdapBindResultNamingViolation               LdapBindResult = "NAMING_VIOLATION"
	LdapBindResultObjectClassViolation          LdapBindResult = "OBJECT_CLASS_VIOLATION"
	LdapBindResultNotAllowedOnNonleaf           LdapBindResult = "NOT_ALLOWED_ON_NONLEAF"
	LdapBindResultNotAllowedOnRdn               LdapBindResult = "NOT_ALLOWED_ON_RDN"
	LdapBindResultAlreadyExists                 LdapBindResult = "ALREADY_EXISTS"
	LdapBindResultNoObjectClassMods             LdapBindResult = "NO_OBJECT_CLASS_MODS"
	LdapBindResultResultsTooLarge               LdapBindResult = "RESULTS_TOO_LARGE"
	LdapBindResultAffectsToMultipleDsas         LdapBindResult = "AFFECTS_TO_MULTIPLE_DSAS"
	LdapBindResultBuiltinOtherCode              LdapBindResult = "BUILTIN_OTHER_CODE"
	LdapBindResultTLSNotSupported               LdapBindResult = "TLS_NOT_SUPPORTED"
	LdapBindResultOther                         LdapBindResult = "OTHER"
)

var AllLdapBindResult = []LdapBindResult{
	LdapBindResultSuccess,
	LdapBindResultOperationError,
	LdapBindResultProtocolError,
	LdapBindResultTimeLimitExceeded,
	LdapBindResultSizeLimitExceeded,
	LdapBindResultCompareFalse,
	LdapBindResultCompareTrue,
	LdapBindResultAuthMethodNotSupported,
	LdapBindResultStrongerAuthRequired,
	LdapBindResultReferral,
	LdapBindResultAdminLimitExceeded,
	LdapBindResultUnavailableCriticialExtension,
	LdapBindResultConfidentialityRequired,
	LdapBindResultSaslBindInProgress,
	LdapBindResultNoSuchAttribute,
	LdapBindResultUndefinedType,
	LdapBindResultInappropriateMatching,
	LdapBindResultConstantViolation,
	LdapBindResultTypeOrValueExists,
	LdapBindResultInvalidSyntax,
	LdapBindResultNoSuchObject,
	LdapBindResultAliasProblem,
	LdapBindResultInvalidDnSyntax,
	LdapBindResultIsLeaf,
	LdapBindResultAliasDerefProblem,
	LdapBindResultInappropriateAuth,
	LdapBindResultInvalidCredentials,
	LdapBindResultInsufficientAccess,
	LdapBindResultBusy,
	LdapBindResultUnavailable,
	LdapBindResultUnwillingToPerform,
	LdapBindResultLoopDetect,
	LdapBindResultNamingViolation,
	LdapBindResultObjectClassViolation,
	LdapBindResultNotAllowedOnNonleaf,
	LdapBindResultNotAllowedOnRdn,
	LdapBindResultAlreadyExists,
	LdapBindResultNoObjectClassMods,
	LdapBindResultResultsTooLarge,
	LdapBindResultAffectsToMultipleDsas,
	LdapBindResultBuiltinOtherCode,
	LdapBindResultTLSNotSupported,
	LdapBindResultOther,
}

func (e LdapBindResult) IsValid() bool {
	switch e {
	case LdapBindResultSuccess, LdapBindResultOperationError, LdapBindResultProtocolError, LdapBindResultTimeLimitExceeded, LdapBindResultSizeLimitExceeded, LdapBindResultCompareFalse, LdapBindResultCompareTrue, LdapBindResultAuthMethodNotSupported, LdapBindResultStrongerAuthRequired, LdapBindResultReferral, LdapBindResultAdminLimitExceeded, LdapBindResultUnavailableCriticialExtension, LdapBindResultConfidentialityRequired, LdapBindResultSaslBindInProgress, LdapBindResultNoSuchAttribute, LdapBindResultUndefinedType, LdapBindResultInappropriateMatching, LdapBindResultConstantViolation, LdapBindResultTypeOrValueExists, LdapBindResultInvalidSyntax, LdapBindResultNoSuchObject, LdapBindResultAliasProblem, LdapBindResultInvalidDnSyntax, LdapBindResultIsLeaf, LdapBindResultAliasDerefProblem, LdapBindResultInappropriateAuth, LdapBindResultInvalidCredentials, LdapBindResultInsufficientAccess, LdapBindResultBusy, LdapBindResultUnavailable, LdapBindResultUnwillingToPerform, LdapBindResultLoopDetect, LdapBindResultNamingViolation, LdapBindResultObjectClassViolation, LdapBindResultNotAllowedOnNonleaf, LdapBindResultNotAllowedOnRdn, LdapBindResultAlreadyExists, LdapBindResultNoObjectClassMods, LdapBindResultResultsTooLarge, LdapBindResultAffectsToMultipleDsas, LdapBindResultBuiltinOtherCode, LdapBindResultTLSNotSupported, LdapBindResultOther:
		return true
	}
	return false
}

func (e LdapBindResult) String() string {
	return string(e)
}

func (e *LdapBindResult) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LdapBindResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LdapBindResult", str)
	}
	return nil
}

func (e LdapBindResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LdapOperationResult string

const (
	LdapOperationResultLdapSuccess                      LdapOperationResult = "LDAP_SUCCESS"
	LdapOperationResultLdapOperationsError              LdapOperationResult = "LDAP_OPERATIONS_ERROR"
	LdapOperationResultLdapProtocolError                LdapOperationResult = "LDAP_PROTOCOL_ERROR"
	LdapOperationResultLdapTimelimitExceeded            LdapOperationResult = "LDAP_TIMELIMIT_EXCEEDED"
	LdapOperationResultLdapSizelimitExceeded            LdapOperationResult = "LDAP_SIZELIMIT_EXCEEDED"
	LdapOperationResultLdapCompareFalse                 LdapOperationResult = "LDAP_COMPARE_FALSE"
	LdapOperationResultLdapCompareTrue                  LdapOperationResult = "LDAP_COMPARE_TRUE"
	LdapOperationResultLdapAuthMethodNotSupported       LdapOperationResult = "LDAP_AUTH_METHOD_NOT_SUPPORTED"
	LdapOperationResultLdapStrongAuthRequired           LdapOperationResult = "LDAP_STRONG_AUTH_REQUIRED"
	LdapOperationResultLdapReferral                     LdapOperationResult = "LDAP_REFERRAL"
	LdapOperationResultLdapAdminlimitExceeded           LdapOperationResult = "LDAP_ADMINLIMIT_EXCEEDED"
	LdapOperationResultLdapUnavailableCriticalExtension LdapOperationResult = "LDAP_UNAVAILABLE_CRITICAL_EXTENSION"
	LdapOperationResultLdapConfidentialityRequired      LdapOperationResult = "LDAP_CONFIDENTIALITY_REQUIRED"
	LdapOperationResultLdapSaslBindInProgress           LdapOperationResult = "LDAP_SASL_BIND_IN_PROGRESS"
	LdapOperationResultLdapNoSuchAttribute              LdapOperationResult = "LDAP_NO_SUCH_ATTRIBUTE"
	LdapOperationResultLdapUndefinedType                LdapOperationResult = "LDAP_UNDEFINED_TYPE"
	LdapOperationResultLdapInappropriateMatching        LdapOperationResult = "LDAP_INAPPROPRIATE_MATCHING"
	LdapOperationResultLdapConstraintViolation          LdapOperationResult = "LDAP_CONSTRAINT_VIOLATION"
	LdapOperationResultLdapTypeOrValueExists            LdapOperationResult = "LDAP_TYPE_OR_VALUE_EXISTS"
	LdapOperationResultLdapInvalidSyntax                LdapOperationResult = "LDAP_INVALID_SYNTAX"
	LdapOperationResultLdapNoSuchObject                 LdapOperationResult = "LDAP_NO_SUCH_OBJECT"
	LdapOperationResultLdapAliasProblem                 LdapOperationResult = "LDAP_ALIAS_PROBLEM"
	LdapOperationResultLdapInvalidDnSyntax              LdapOperationResult = "LDAP_INVALID_DN_SYNTAX"
	LdapOperationResultLdapAliasDerefProblem            LdapOperationResult = "LDAP_ALIAS_DEREF_PROBLEM"
	LdapOperationResultLdapInappropriateAuth            LdapOperationResult = "LDAP_INAPPROPRIATE_AUTH"
	LdapOperationResultInvalidCredentials               LdapOperationResult = "INVALID_CREDENTIALS"
	LdapOperationResultWrongUsernameCasingOrPassword    LdapOperationResult = "WRONG_USERNAME_CASING_OR_PASSWORD"
	LdapOperationResultAccountDoesNotExist              LdapOperationResult = "ACCOUNT_DOES_NOT_EXIST"
	LdapOperationResultAccountIsLockedOrDisabled        LdapOperationResult = "ACCOUNT_IS_LOCKED_OR_DISABLED"
	LdapOperationResultClockSkew                        LdapOperationResult = "CLOCK_SKEW"
	LdapOperationResultAccountPasswordExpired           LdapOperationResult = "ACCOUNT_PASSWORD_EXPIRED"
	LdapOperationResultLdapInsufficientAccess           LdapOperationResult = "LDAP_INSUFFICIENT_ACCESS"
	LdapOperationResultLdapBusy                         LdapOperationResult = "LDAP_BUSY"
	LdapOperationResultLdapUnavailable                  LdapOperationResult = "LDAP_UNAVAILABLE"
	LdapOperationResultLdapUnwillingToPerform           LdapOperationResult = "LDAP_UNWILLING_TO_PERFORM"
	LdapOperationResultLdapLoopDetect                   LdapOperationResult = "LDAP_LOOP_DETECT"
	LdapOperationResultLdapNamingViolation              LdapOperationResult = "LDAP_NAMING_VIOLATION"
	LdapOperationResultLdapObjectClassViolation         LdapOperationResult = "LDAP_OBJECT_CLASS_VIOLATION"
	LdapOperationResultLdapNotAllowedOnNonleaf          LdapOperationResult = "LDAP_NOT_ALLOWED_ON_NONLEAF"
	LdapOperationResultLdapNotAllowedOnRdn              LdapOperationResult = "LDAP_NOT_ALLOWED_ON_RDN"
	LdapOperationResultLdapAlreadyExists                LdapOperationResult = "LDAP_ALREADY_EXISTS"
	LdapOperationResultLdapNoObjectClassMods            LdapOperationResult = "LDAP_NO_OBJECT_CLASS_MODS"
	LdapOperationResultLdapAffectsMultipleDsas          LdapOperationResult = "LDAP_AFFECTS_MULTIPLE_DSAS"
	LdapOperationResultLdapDomainNotFound               LdapOperationResult = "LDAP_DOMAIN_NOT_FOUND"
	LdapOperationResultLdapCertificateNotFound          LdapOperationResult = "LDAP_CERTIFICATE_NOT_FOUND"
	LdapOperationResultLdapConnectError                 LdapOperationResult = "LDAP_CONNECT_ERROR"
	LdapOperationResultLdapOther                        LdapOperationResult = "LDAP_OTHER"
)

var AllLdapOperationResult = []LdapOperationResult{
	LdapOperationResultLdapSuccess,
	LdapOperationResultLdapOperationsError,
	LdapOperationResultLdapProtocolError,
	LdapOperationResultLdapTimelimitExceeded,
	LdapOperationResultLdapSizelimitExceeded,
	LdapOperationResultLdapCompareFalse,
	LdapOperationResultLdapCompareTrue,
	LdapOperationResultLdapAuthMethodNotSupported,
	LdapOperationResultLdapStrongAuthRequired,
	LdapOperationResultLdapReferral,
	LdapOperationResultLdapAdminlimitExceeded,
	LdapOperationResultLdapUnavailableCriticalExtension,
	LdapOperationResultLdapConfidentialityRequired,
	LdapOperationResultLdapSaslBindInProgress,
	LdapOperationResultLdapNoSuchAttribute,
	LdapOperationResultLdapUndefinedType,
	LdapOperationResultLdapInappropriateMatching,
	LdapOperationResultLdapConstraintViolation,
	LdapOperationResultLdapTypeOrValueExists,
	LdapOperationResultLdapInvalidSyntax,
	LdapOperationResultLdapNoSuchObject,
	LdapOperationResultLdapAliasProblem,
	LdapOperationResultLdapInvalidDnSyntax,
	LdapOperationResultLdapAliasDerefProblem,
	LdapOperationResultLdapInappropriateAuth,
	LdapOperationResultInvalidCredentials,
	LdapOperationResultWrongUsernameCasingOrPassword,
	LdapOperationResultAccountDoesNotExist,
	LdapOperationResultAccountIsLockedOrDisabled,
	LdapOperationResultClockSkew,
	LdapOperationResultAccountPasswordExpired,
	LdapOperationResultLdapInsufficientAccess,
	LdapOperationResultLdapBusy,
	LdapOperationResultLdapUnavailable,
	LdapOperationResultLdapUnwillingToPerform,
	LdapOperationResultLdapLoopDetect,
	LdapOperationResultLdapNamingViolation,
	LdapOperationResultLdapObjectClassViolation,
	LdapOperationResultLdapNotAllowedOnNonleaf,
	LdapOperationResultLdapNotAllowedOnRdn,
	LdapOperationResultLdapAlreadyExists,
	LdapOperationResultLdapNoObjectClassMods,
	LdapOperationResultLdapAffectsMultipleDsas,
	LdapOperationResultLdapDomainNotFound,
	LdapOperationResultLdapCertificateNotFound,
	LdapOperationResultLdapConnectError,
	LdapOperationResultLdapOther,
}

func (e LdapOperationResult) IsValid() bool {
	switch e {
	case LdapOperationResultLdapSuccess, LdapOperationResultLdapOperationsError, LdapOperationResultLdapProtocolError, LdapOperationResultLdapTimelimitExceeded, LdapOperationResultLdapSizelimitExceeded, LdapOperationResultLdapCompareFalse, LdapOperationResultLdapCompareTrue, LdapOperationResultLdapAuthMethodNotSupported, LdapOperationResultLdapStrongAuthRequired, LdapOperationResultLdapReferral, LdapOperationResultLdapAdminlimitExceeded, LdapOperationResultLdapUnavailableCriticalExtension, LdapOperationResultLdapConfidentialityRequired, LdapOperationResultLdapSaslBindInProgress, LdapOperationResultLdapNoSuchAttribute, LdapOperationResultLdapUndefinedType, LdapOperationResultLdapInappropriateMatching, LdapOperationResultLdapConstraintViolation, LdapOperationResultLdapTypeOrValueExists, LdapOperationResultLdapInvalidSyntax, LdapOperationResultLdapNoSuchObject, LdapOperationResultLdapAliasProblem, LdapOperationResultLdapInvalidDnSyntax, LdapOperationResultLdapAliasDerefProblem, LdapOperationResultLdapInappropriateAuth, LdapOperationResultInvalidCredentials, LdapOperationResultWrongUsernameCasingOrPassword, LdapOperationResultAccountDoesNotExist, LdapOperationResultAccountIsLockedOrDisabled, LdapOperationResultClockSkew, LdapOperationResultAccountPasswordExpired, LdapOperationResultLdapInsufficientAccess, LdapOperationResultLdapBusy, LdapOperationResultLdapUnavailable, LdapOperationResultLdapUnwillingToPerform, LdapOperationResultLdapLoopDetect, LdapOperationResultLdapNamingViolation, LdapOperationResultLdapObjectClassViolation, LdapOperationResultLdapNotAllowedOnNonleaf, LdapOperationResultLdapNotAllowedOnRdn, LdapOperationResultLdapAlreadyExists, LdapOperationResultLdapNoObjectClassMods, LdapOperationResultLdapAffectsMultipleDsas, LdapOperationResultLdapDomainNotFound, LdapOperationResultLdapCertificateNotFound, LdapOperationResultLdapConnectError, LdapOperationResultLdapOther:
		return true
	}
	return false
}

func (e LdapOperationResult) String() string {
	return string(e)
}

func (e *LdapOperationResult) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LdapOperationResult(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LdapOperationResult", str)
	}
	return nil
}

func (e LdapOperationResult) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LdapQuerySignature string

const (
	LdapQuerySignatureGpoSearch                        LdapQuerySignature = "GPO_SEARCH"
	LdapQuerySignatureGroupMembershipEnumeration       LdapQuerySignature = "GROUP_MEMBERSHIP_ENUMERATION"
	LdapQuerySignatureACLEnumeration                   LdapQuerySignature = "ACL_ENUMERATION"
	LdapQuerySignatureSingleEntryQuery                 LdapQuerySignature = "SINGLE_ENTRY_QUERY"
	LdapQuerySignatureSpnEnumeration                   LdapQuerySignature = "SPN_ENUMERATION"
	LdapQuerySignatureTrustEnumeration                 LdapQuerySignature = "TRUST_ENUMERATION"
	LdapQuerySignatureGpoEnumeration                   LdapQuerySignature = "GPO_ENUMERATION"
	LdapQuerySignatureUserEnumeration                  LdapQuerySignature = "USER_ENUMERATION"
	LdapQuerySignatureEndpointEnumeration              LdapQuerySignature = "ENDPOINT_ENUMERATION"
	LdapQuerySignatureDcEnumeration                    LdapQuerySignature = "DC_ENUMERATION"
	LdapQuerySignatureGroupEnumeration                 LdapQuerySignature = "GROUP_ENUMERATION"
	LdapQuerySignatureOuEnumeration                    LdapQuerySignature = "OU_ENUMERATION"
	LdapQuerySignatureAllObjectsEnumeration            LdapQuerySignature = "ALL_OBJECTS_ENUMERATION"
	LdapQuerySignatureAdcsEnumeration                  LdapQuerySignature = "ADCS_ENUMERATION"
	LdapQuerySignatureAdcsMisconfigEnumeration         LdapQuerySignature = "ADCS_MISCONFIG_ENUMERATION"
	LdapQuerySignatureBloodhoundSharphound             LdapQuerySignature = "BLOODHOUND_SHARPHOUND"
	LdapQuerySignatureSpnEnumerationImpacket           LdapQuerySignature = "SPN_ENUMERATION_IMPACKET"
	LdapQuerySignatureBloodhoundPowershell             LdapQuerySignature = "BLOODHOUND_POWERSHELL"
	LdapQuerySignatureSpnEnumerationKerberoasting      LdapQuerySignature = "SPN_ENUMERATION_KERBEROASTING"
	LdapQuerySignatureSpnEnumerationEmpire             LdapQuerySignature = "SPN_ENUMERATION_EMPIRE"
	LdapQuerySignatureSpnEnumerationPowersploit        LdapQuerySignature = "SPN_ENUMERATION_POWERSPLOIT"
	LdapQuerySignatureSpnEnumerationRubeus             LdapQuerySignature = "SPN_ENUMERATION_RUBEUS"
	LdapQuerySignaturePreauthEnumeration               LdapQuerySignature = "PREAUTH_ENUMERATION"
	LdapQuerySignaturePreauthEnumerationRubeus         LdapQuerySignature = "PREAUTH_ENUMERATION_RUBEUS"
	LdapQuerySignatureDelegationReconnaissance         LdapQuerySignature = "DELEGATION_RECONNAISSANCE"
	LdapQuerySignatureDelegationReconnaissanceImpacket LdapQuerySignature = "DELEGATION_RECONNAISSANCE_IMPACKET"
	LdapQuerySignaturePreauthEnumerationCme            LdapQuerySignature = "PREAUTH_ENUMERATION_CME"
	LdapQuerySignatureDelegationReconnaissanceCme      LdapQuerySignature = "DELEGATION_RECONNAISSANCE_CME"
	LdapQuerySignatureAdminCountEnumeration            LdapQuerySignature = "ADMIN_COUNT_ENUMERATION"
	LdapQuerySignatureAdminCountEnumerationCme         LdapQuerySignature = "ADMIN_COUNT_ENUMERATION_CME"
	LdapQuerySignatureBloodhoundPython                 LdapQuerySignature = "BLOODHOUND_PYTHON"
	LdapQuerySignatureSpnEnumerationKerberoast         LdapQuerySignature = "SPN_ENUMERATION_KERBEROAST"
	LdapQuerySignatureAdfind                           LdapQuerySignature = "ADFIND"
	LdapQuerySignatureKrbRelay                         LdapQuerySignature = "KRB_RELAY"
	LdapQuerySignatureCertipy                          LdapQuerySignature = "CERTIPY"
	LdapQuerySignatureAdcsReconTools                   LdapQuerySignature = "ADCS_RECON_TOOLS"
	LdapQuerySignatureRubeusEnumerationDomainPolicy    LdapQuerySignature = "RUBEUS_ENUMERATION_DOMAIN_POLICY"
	LdapQuerySignatureAdreconReconnaissance            LdapQuerySignature = "ADRECON_RECONNAISSANCE"
	LdapQuerySignatureMlHighConfidence                 LdapQuerySignature = "ML_HIGH_CONFIDENCE"
)

var AllLdapQuerySignature = []LdapQuerySignature{
	LdapQuerySignatureGpoSearch,
	LdapQuerySignatureGroupMembershipEnumeration,
	LdapQuerySignatureACLEnumeration,
	LdapQuerySignatureSingleEntryQuery,
	LdapQuerySignatureSpnEnumeration,
	LdapQuerySignatureTrustEnumeration,
	LdapQuerySignatureGpoEnumeration,
	LdapQuerySignatureUserEnumeration,
	LdapQuerySignatureEndpointEnumeration,
	LdapQuerySignatureDcEnumeration,
	LdapQuerySignatureGroupEnumeration,
	LdapQuerySignatureOuEnumeration,
	LdapQuerySignatureAllObjectsEnumeration,
	LdapQuerySignatureAdcsEnumeration,
	LdapQuerySignatureAdcsMisconfigEnumeration,
	LdapQuerySignatureBloodhoundSharphound,
	LdapQuerySignatureSpnEnumerationImpacket,
	LdapQuerySignatureBloodhoundPowershell,
	LdapQuerySignatureSpnEnumerationKerberoasting,
	LdapQuerySignatureSpnEnumerationEmpire,
	LdapQuerySignatureSpnEnumerationPowersploit,
	LdapQuerySignatureSpnEnumerationRubeus,
	LdapQuerySignaturePreauthEnumeration,
	LdapQuerySignaturePreauthEnumerationRubeus,
	LdapQuerySignatureDelegationReconnaissance,
	LdapQuerySignatureDelegationReconnaissanceImpacket,
	LdapQuerySignaturePreauthEnumerationCme,
	LdapQuerySignatureDelegationReconnaissanceCme,
	LdapQuerySignatureAdminCountEnumeration,
	LdapQuerySignatureAdminCountEnumerationCme,
	LdapQuerySignatureBloodhoundPython,
	LdapQuerySignatureSpnEnumerationKerberoast,
	LdapQuerySignatureAdfind,
	LdapQuerySignatureKrbRelay,
	LdapQuerySignatureCertipy,
	LdapQuerySignatureAdcsReconTools,
	LdapQuerySignatureRubeusEnumerationDomainPolicy,
	LdapQuerySignatureAdreconReconnaissance,
	LdapQuerySignatureMlHighConfidence,
}

func (e LdapQuerySignature) IsValid() bool {
	switch e {
	case LdapQuerySignatureGpoSearch, LdapQuerySignatureGroupMembershipEnumeration, LdapQuerySignatureACLEnumeration, LdapQuerySignatureSingleEntryQuery, LdapQuerySignatureSpnEnumeration, LdapQuerySignatureTrustEnumeration, LdapQuerySignatureGpoEnumeration, LdapQuerySignatureUserEnumeration, LdapQuerySignatureEndpointEnumeration, LdapQuerySignatureDcEnumeration, LdapQuerySignatureGroupEnumeration, LdapQuerySignatureOuEnumeration, LdapQuerySignatureAllObjectsEnumeration, LdapQuerySignatureAdcsEnumeration, LdapQuerySignatureAdcsMisconfigEnumeration, LdapQuerySignatureBloodhoundSharphound, LdapQuerySignatureSpnEnumerationImpacket, LdapQuerySignatureBloodhoundPowershell, LdapQuerySignatureSpnEnumerationKerberoasting, LdapQuerySignatureSpnEnumerationEmpire, LdapQuerySignatureSpnEnumerationPowersploit, LdapQuerySignatureSpnEnumerationRubeus, LdapQuerySignaturePreauthEnumeration, LdapQuerySignaturePreauthEnumerationRubeus, LdapQuerySignatureDelegationReconnaissance, LdapQuerySignatureDelegationReconnaissanceImpacket, LdapQuerySignaturePreauthEnumerationCme, LdapQuerySignatureDelegationReconnaissanceCme, LdapQuerySignatureAdminCountEnumeration, LdapQuerySignatureAdminCountEnumerationCme, LdapQuerySignatureBloodhoundPython, LdapQuerySignatureSpnEnumerationKerberoast, LdapQuerySignatureAdfind, LdapQuerySignatureKrbRelay, LdapQuerySignatureCertipy, LdapQuerySignatureAdcsReconTools, LdapQuerySignatureRubeusEnumerationDomainPolicy, LdapQuerySignatureAdreconReconnaissance, LdapQuerySignatureMlHighConfidence:
		return true
	}
	return false
}

func (e LdapQuerySignature) String() string {
	return string(e)
}

func (e *LdapQuerySignature) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LdapQuerySignature(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LdapQuerySignature", str)
	}
	return nil
}

func (e LdapQuerySignature) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LdapSecurityType string

const (
	LdapSecurityTypeUnknown             LdapSecurityType = "UNKNOWN"
	LdapSecurityTypeNone                LdapSecurityType = "NONE"
	LdapSecurityTypeTLS                 LdapSecurityType = "TLS"
	LdapSecurityTypeSaslIntegrity       LdapSecurityType = "SASL_INTEGRITY"
	LdapSecurityTypeSaslConfidentiality LdapSecurityType = "SASL_CONFIDENTIALITY"
)

var AllLdapSecurityType = []LdapSecurityType{
	LdapSecurityTypeUnknown,
	LdapSecurityTypeNone,
	LdapSecurityTypeTLS,
	LdapSecurityTypeSaslIntegrity,
	LdapSecurityTypeSaslConfidentiality,
}

func (e LdapSecurityType) IsValid() bool {
	switch e {
	case LdapSecurityTypeUnknown, LdapSecurityTypeNone, LdapSecurityTypeTLS, LdapSecurityTypeSaslIntegrity, LdapSecurityTypeSaslConfidentiality:
		return true
	}
	return false
}

func (e LdapSecurityType) String() string {
	return string(e)
}

func (e *LdapSecurityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LdapSecurityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LdapSecurityType", str)
	}
	return nil
}

func (e LdapSecurityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of Multi-Factor Authentication connector types.
type MfaConnectorType string

const (
	MfaConnectorTypeDuoAuth         MfaConnectorType = "DUO_AUTH"
	MfaConnectorTypeSecureAuthAuth  MfaConnectorType = "SECURE_AUTH_AUTH"
	MfaConnectorTypeOktaAuth        MfaConnectorType = "OKTA_AUTH"
	MfaConnectorTypeSymantecVipAuth MfaConnectorType = "SYMANTEC_VIP_AUTH"
	MfaConnectorTypeRsaAuth         MfaConnectorType = "RSA_AUTH"
	MfaConnectorTypeRsaCas          MfaConnectorType = "RSA_CAS"
	MfaConnectorTypeGoogleAuth      MfaConnectorType = "GOOGLE_AUTH"
	MfaConnectorTypeAzureMfa        MfaConnectorType = "AZURE_MFA"
	MfaConnectorTypeAzureAuth       MfaConnectorType = "AZURE_AUTH"
	MfaConnectorTypeRadius          MfaConnectorType = "RADIUS"
	MfaConnectorTypePingIDEntityMfa MfaConnectorType = "PING_IDENTITY_MFA"
	MfaConnectorTypeCyberArk        MfaConnectorType = "CYBER_ARK"
	MfaConnectorTypeOneLogin        MfaConnectorType = "ONE_LOGIN"
	MfaConnectorTypeEntrust         MfaConnectorType = "ENTRUST"
	MfaConnectorTypeForgerock       MfaConnectorType = "FORGEROCK"
	MfaConnectorTypeOidc            MfaConnectorType = "OIDC"
	MfaConnectorTypeCsFalconAuth    MfaConnectorType = "CS_FALCON_AUTH"
)

var AllMfaConnectorType = []MfaConnectorType{
	MfaConnectorTypeDuoAuth,
	MfaConnectorTypeSecureAuthAuth,
	MfaConnectorTypeOktaAuth,
	MfaConnectorTypeSymantecVipAuth,
	MfaConnectorTypeRsaAuth,
	MfaConnectorTypeRsaCas,
	MfaConnectorTypeGoogleAuth,
	MfaConnectorTypeAzureMfa,
	MfaConnectorTypeAzureAuth,
	MfaConnectorTypeRadius,
	MfaConnectorTypePingIDEntityMfa,
	MfaConnectorTypeCyberArk,
	MfaConnectorTypeOneLogin,
	MfaConnectorTypeEntrust,
	MfaConnectorTypeForgerock,
	MfaConnectorTypeOidc,
	MfaConnectorTypeCsFalconAuth,
}

func (e MfaConnectorType) IsValid() bool {
	switch e {
	case MfaConnectorTypeDuoAuth, MfaConnectorTypeSecureAuthAuth, MfaConnectorTypeOktaAuth, MfaConnectorTypeSymantecVipAuth, MfaConnectorTypeRsaAuth, MfaConnectorTypeRsaCas, MfaConnectorTypeGoogleAuth, MfaConnectorTypeAzureMfa, MfaConnectorTypeAzureAuth, MfaConnectorTypeRadius, MfaConnectorTypePingIDEntityMfa, MfaConnectorTypeCyberArk, MfaConnectorTypeOneLogin, MfaConnectorTypeEntrust, MfaConnectorTypeForgerock, MfaConnectorTypeOidc, MfaConnectorTypeCsFalconAuth:
		return true
	}
	return false
}

func (e MfaConnectorType) String() string {
	return string(e)
}

func (e *MfaConnectorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MfaConnectorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MfaConnectorType", str)
	}
	return nil
}

func (e MfaConnectorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of Multi-Factor Authentication factor types.
type MfaFactorType string

const (
	MfaFactorTypePush                   MfaFactorType = "PUSH"
	MfaFactorTypePushWithNumberMatching MfaFactorType = "PUSH_WITH_NUMBER_MATCHING"
	MfaFactorTypePushWithOtpFallback    MfaFactorType = "PUSH_WITH_OTP_FALLBACK"
	MfaFactorTypeOtp                    MfaFactorType = "OTP"
	MfaFactorTypeCallOtp                MfaFactorType = "CALL_OTP"
	MfaFactorTypeCallVerify             MfaFactorType = "CALL_VERIFY"
	MfaFactorTypeCallVerifyWithPasscode MfaFactorType = "CALL_VERIFY_WITH_PASSCODE"
	MfaFactorTypeSms1way                MfaFactorType = "SMS_1WAY"
	MfaFactorTypeSms2way                MfaFactorType = "SMS_2WAY"
	MfaFactorTypeDynamic                MfaFactorType = "DYNAMIC"
	MfaFactorTypeBiometrics             MfaFactorType = "BIOMETRICS"
	MfaFactorTypeHardwareOtp            MfaFactorType = "HARDWARE_OTP"
	MfaFactorTypeEmergencyOtp           MfaFactorType = "EMERGENCY_OTP"
	MfaFactorTypeFido                   MfaFactorType = "FIDO"
	MfaFactorTypeGridCard               MfaFactorType = "GRID_CARD"
	MfaFactorTypeOidcAuth               MfaFactorType = "OIDC_AUTH"
)

var AllMfaFactorType = []MfaFactorType{
	MfaFactorTypePush,
	MfaFactorTypePushWithNumberMatching,
	MfaFactorTypePushWithOtpFallback,
	MfaFactorTypeOtp,
	MfaFactorTypeCallOtp,
	MfaFactorTypeCallVerify,
	MfaFactorTypeCallVerifyWithPasscode,
	MfaFactorTypeSms1way,
	MfaFactorTypeSms2way,
	MfaFactorTypeDynamic,
	MfaFactorTypeBiometrics,
	MfaFactorTypeHardwareOtp,
	MfaFactorTypeEmergencyOtp,
	MfaFactorTypeFido,
	MfaFactorTypeGridCard,
	MfaFactorTypeOidcAuth,
}

func (e MfaFactorType) IsValid() bool {
	switch e {
	case MfaFactorTypePush, MfaFactorTypePushWithNumberMatching, MfaFactorTypePushWithOtpFallback, MfaFactorTypeOtp, MfaFactorTypeCallOtp, MfaFactorTypeCallVerify, MfaFactorTypeCallVerifyWithPasscode, MfaFactorTypeSms1way, MfaFactorTypeSms2way, MfaFactorTypeDynamic, MfaFactorTypeBiometrics, MfaFactorTypeHardwareOtp, MfaFactorTypeEmergencyOtp, MfaFactorTypeFido, MfaFactorTypeGridCard, MfaFactorTypeOidcAuth:
		return true
	}
	return false
}

func (e MfaFactorType) String() string {
	return string(e)
}

func (e *MfaFactorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MfaFactorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MfaFactorType", str)
	}
	return nil
}

func (e MfaFactorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of network types (aka subnet types).
type NetworkType string

const (
	// The fallback value indicating the network type could not be recognized.
	NetworkTypeUnknown NetworkType = "UNKNOWN"
	// Configuration-based network-type specifying a VPN subnet.
	NetworkTypeVpn NetworkType = "VPN"
	// Indicates that the activity has originated from a public IP address.
	NetworkTypePublic NetworkType = "PUBLIC"
	// Configuration-based network-type specifying a wireless subnet.
	NetworkTypeWireless NetworkType = "WIRELESS"
	// Configuration-based network-type specifying an internal organization subnet.
	NetworkTypeInternal NetworkType = "INTERNAL"
	// Configuration-based network-type specifying a NAT subnet.
	NetworkTypeNat NetworkType = "NAT"
)

var AllNetworkType = []NetworkType{
	NetworkTypeUnknown,
	NetworkTypeVpn,
	NetworkTypePublic,
	NetworkTypeWireless,
	NetworkTypeInternal,
	NetworkTypeNat,
}

func (e NetworkType) IsValid() bool {
	switch e {
	case NetworkTypeUnknown, NetworkTypeVpn, NetworkTypePublic, NetworkTypeWireless, NetworkTypeInternal, NetworkTypeNat:
		return true
	}
	return false
}

func (e NetworkType) String() string {
	return string(e)
}

func (e *NetworkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkType", str)
	}
	return nil
}

func (e NetworkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of well-known error codes Microsoft uses in their NTLM protocol implementation.
type NtlmErrorCode string

const (
	NtlmErrorCodeNoNtlmError                 NtlmErrorCode = "NO_NTLM_ERROR"
	NtlmErrorCodeAccessDenied                NtlmErrorCode = "ACCESS_DENIED"
	NtlmErrorCodeAccountExpiration           NtlmErrorCode = "ACCOUNT_EXPIRATION"
	NtlmErrorCodeInvalidPassword             NtlmErrorCode = "INVALID_PASSWORD"
	NtlmErrorCodeLogonFailure                NtlmErrorCode = "LOGON_FAILURE"
	NtlmErrorCodeNoSuchUser                  NtlmErrorCode = "NO_SUCH_USER"
	NtlmErrorCodeAccountRestriction          NtlmErrorCode = "ACCOUNT_RESTRICTION"
	NtlmErrorCodeInvalidLogonHours           NtlmErrorCode = "INVALID_LOGON_HOURS"
	NtlmErrorCodeInvalidWorkstation          NtlmErrorCode = "INVALID_WORKSTATION"
	NtlmErrorCodePasswordExpired             NtlmErrorCode = "PASSWORD_EXPIRED"
	NtlmErrorCodeAccountDisabled             NtlmErrorCode = "ACCOUNT_DISABLED"
	NtlmErrorCodeLogonNotGranted             NtlmErrorCode = "LOGON_NOT_GRANTED"
	NtlmErrorCodeLogonTypeNotGranted         NtlmErrorCode = "LOGON_TYPE_NOT_GRANTED"
	NtlmErrorCodeAccountLockedOut            NtlmErrorCode = "ACCOUNT_LOCKED_OUT"
	NtlmErrorCodeUserChangePasswordNextLogon NtlmErrorCode = "USER_CHANGE_PASSWORD_NEXT_LOGON"
	NtlmErrorCodeOther                       NtlmErrorCode = "OTHER"
)

var AllNtlmErrorCode = []NtlmErrorCode{
	NtlmErrorCodeNoNtlmError,
	NtlmErrorCodeAccessDenied,
	NtlmErrorCodeAccountExpiration,
	NtlmErrorCodeInvalidPassword,
	NtlmErrorCodeLogonFailure,
	NtlmErrorCodeNoSuchUser,
	NtlmErrorCodeAccountRestriction,
	NtlmErrorCodeInvalidLogonHours,
	NtlmErrorCodeInvalidWorkstation,
	NtlmErrorCodePasswordExpired,
	NtlmErrorCodeAccountDisabled,
	NtlmErrorCodeLogonNotGranted,
	NtlmErrorCodeLogonTypeNotGranted,
	NtlmErrorCodeAccountLockedOut,
	NtlmErrorCodeUserChangePasswordNextLogon,
	NtlmErrorCodeOther,
}

func (e NtlmErrorCode) IsValid() bool {
	switch e {
	case NtlmErrorCodeNoNtlmError, NtlmErrorCodeAccessDenied, NtlmErrorCodeAccountExpiration, NtlmErrorCodeInvalidPassword, NtlmErrorCodeLogonFailure, NtlmErrorCodeNoSuchUser, NtlmErrorCodeAccountRestriction, NtlmErrorCodeInvalidLogonHours, NtlmErrorCodeInvalidWorkstation, NtlmErrorCodePasswordExpired, NtlmErrorCodeAccountDisabled, NtlmErrorCodeLogonNotGranted, NtlmErrorCodeLogonTypeNotGranted, NtlmErrorCodeAccountLockedOut, NtlmErrorCodeUserChangePasswordNextLogon, NtlmErrorCodeOther:
		return true
	}
	return false
}

func (e NtlmErrorCode) String() string {
	return string(e)
}

func (e *NtlmErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NtlmErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NtlmErrorCode", str)
	}
	return nil
}

func (e NtlmErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObjectSidTakeoverMethod string

const (
	ObjectSidTakeoverMethodObjectSidHistory ObjectSidTakeoverMethod = "OBJECT_SID_HISTORY"
	ObjectSidTakeoverMethodUnknown          ObjectSidTakeoverMethod = "UNKNOWN"
)

var AllObjectSidTakeoverMethod = []ObjectSidTakeoverMethod{
	ObjectSidTakeoverMethodObjectSidHistory,
	ObjectSidTakeoverMethodUnknown,
}

func (e ObjectSidTakeoverMethod) IsValid() bool {
	switch e {
	case ObjectSidTakeoverMethodObjectSidHistory, ObjectSidTakeoverMethodUnknown:
		return true
	}
	return false
}

func (e ObjectSidTakeoverMethod) String() string {
	return string(e)
}

func (e *ObjectSidTakeoverMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObjectSidTakeoverMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObjectSidTakeoverMethod", str)
	}
	return nil
}

func (e ObjectSidTakeoverMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatingSystemFamily string

const (
	OperatingSystemFamilyWindows OperatingSystemFamily = "WINDOWS"
	OperatingSystemFamilyOsx     OperatingSystemFamily = "OSX"
	OperatingSystemFamilyUnix    OperatingSystemFamily = "UNIX"
	OperatingSystemFamilyLinux   OperatingSystemFamily = "LINUX"
	OperatingSystemFamilyIos     OperatingSystemFamily = "IOS"
	OperatingSystemFamilyAndroid OperatingSystemFamily = "ANDROID"
	OperatingSystemFamilyOther   OperatingSystemFamily = "OTHER"
)

var AllOperatingSystemFamily = []OperatingSystemFamily{
	OperatingSystemFamilyWindows,
	OperatingSystemFamilyOsx,
	OperatingSystemFamilyUnix,
	OperatingSystemFamilyLinux,
	OperatingSystemFamilyIos,
	OperatingSystemFamilyAndroid,
	OperatingSystemFamilyOther,
}

func (e OperatingSystemFamily) IsValid() bool {
	switch e {
	case OperatingSystemFamilyWindows, OperatingSystemFamilyOsx, OperatingSystemFamilyUnix, OperatingSystemFamilyLinux, OperatingSystemFamilyIos, OperatingSystemFamilyAndroid, OperatingSystemFamilyOther:
		return true
	}
	return false
}

func (e OperatingSystemFamily) String() string {
	return string(e)
}

func (e *OperatingSystemFamily) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystemFamily(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystemFamily", str)
	}
	return nil
}

func (e OperatingSystemFamily) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatingSystemTarget string

const (
	OperatingSystemTargetWorkstation                 OperatingSystemTarget = "WORKSTATION"
	OperatingSystemTargetServer                      OperatingSystemTarget = "SERVER"
	OperatingSystemTargetIntegratedSolutionAppliance OperatingSystemTarget = "INTEGRATED_SOLUTION_APPLIANCE"
	OperatingSystemTargetMobile                      OperatingSystemTarget = "MOBILE"
	OperatingSystemTargetTablet                      OperatingSystemTarget = "TABLET"
	OperatingSystemTargetGameConsole                 OperatingSystemTarget = "GAME_CONSOLE"
	OperatingSystemTargetWearable                    OperatingSystemTarget = "WEARABLE"
	OperatingSystemTargetSmartTv                     OperatingSystemTarget = "SMART_TV"
	OperatingSystemTargetPda                         OperatingSystemTarget = "PDA"
	OperatingSystemTargetUndetermined                OperatingSystemTarget = "UNDETERMINED"
)

var AllOperatingSystemTarget = []OperatingSystemTarget{
	OperatingSystemTargetWorkstation,
	OperatingSystemTargetServer,
	OperatingSystemTargetIntegratedSolutionAppliance,
	OperatingSystemTargetMobile,
	OperatingSystemTargetTablet,
	OperatingSystemTargetGameConsole,
	OperatingSystemTargetWearable,
	OperatingSystemTargetSmartTv,
	OperatingSystemTargetPda,
	OperatingSystemTargetUndetermined,
}

func (e OperatingSystemTarget) IsValid() bool {
	switch e {
	case OperatingSystemTargetWorkstation, OperatingSystemTargetServer, OperatingSystemTargetIntegratedSolutionAppliance, OperatingSystemTargetMobile, OperatingSystemTargetTablet, OperatingSystemTargetGameConsole, OperatingSystemTargetWearable, OperatingSystemTargetSmartTv, OperatingSystemTargetPda, OperatingSystemTargetUndetermined:
		return true
	}
	return false
}

func (e OperatingSystemTarget) String() string {
	return string(e)
}

func (e *OperatingSystemTarget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystemTarget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystemTarget", str)
	}
	return nil
}

func (e OperatingSystemTarget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatingSystemVulnerability string

const (
	OperatingSystemVulnerabilityNone    OperatingSystemVulnerability = "NONE"
	OperatingSystemVulnerabilityUnknown OperatingSystemVulnerability = "UNKNOWN"
	OperatingSystemVulnerabilityLow     OperatingSystemVulnerability = "LOW"
	OperatingSystemVulnerabilityMedium  OperatingSystemVulnerability = "MEDIUM"
	OperatingSystemVulnerabilityHigh    OperatingSystemVulnerability = "HIGH"
)

var AllOperatingSystemVulnerability = []OperatingSystemVulnerability{
	OperatingSystemVulnerabilityNone,
	OperatingSystemVulnerabilityUnknown,
	OperatingSystemVulnerabilityLow,
	OperatingSystemVulnerabilityMedium,
	OperatingSystemVulnerabilityHigh,
}

func (e OperatingSystemVulnerability) IsValid() bool {
	switch e {
	case OperatingSystemVulnerabilityNone, OperatingSystemVulnerabilityUnknown, OperatingSystemVulnerabilityLow, OperatingSystemVulnerabilityMedium, OperatingSystemVulnerabilityHigh:
		return true
	}
	return false
}

func (e OperatingSystemVulnerability) String() string {
	return string(e)
}

func (e *OperatingSystemVulnerability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatingSystemVulnerability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatingSystemVulnerability", str)
	}
	return nil
}

func (e OperatingSystemVulnerability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of password strength values.
type PasswordStrength string

const (
	PasswordStrengthUnknown PasswordStrength = "UNKNOWN"
	PasswordStrengthWeak    PasswordStrength = "WEAK"
	PasswordStrengthStrong  PasswordStrength = "STRONG"
)

var AllPasswordStrength = []PasswordStrength{
	PasswordStrengthUnknown,
	PasswordStrengthWeak,
	PasswordStrengthStrong,
}

func (e PasswordStrength) IsValid() bool {
	switch e {
	case PasswordStrengthUnknown, PasswordStrengthWeak, PasswordStrengthStrong:
		return true
	}
	return false
}

func (e PasswordStrength) String() string {
	return string(e)
}

func (e *PasswordStrength) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PasswordStrength(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PasswordStrength", str)
	}
	return nil
}

func (e PasswordStrength) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProtocolType string

const (
	ProtocolTypeKerberos ProtocolType = "KERBEROS"
	ProtocolTypeLdap     ProtocolType = "LDAP"
	ProtocolTypeNtlm     ProtocolType = "NTLM"
	ProtocolTypeDceRPC   ProtocolType = "DCE_RPC"
	ProtocolTypeSsl      ProtocolType = "SSL"
	ProtocolTypeUnknown  ProtocolType = "UNKNOWN"
)

var AllProtocolType = []ProtocolType{
	ProtocolTypeKerberos,
	ProtocolTypeLdap,
	ProtocolTypeNtlm,
	ProtocolTypeDceRPC,
	ProtocolTypeSsl,
	ProtocolTypeUnknown,
}

func (e ProtocolType) IsValid() bool {
	switch e {
	case ProtocolTypeKerberos, ProtocolTypeLdap, ProtocolTypeNtlm, ProtocolTypeDceRPC, ProtocolTypeSsl, ProtocolTypeUnknown:
		return true
	}
	return false
}

func (e ProtocolType) String() string {
	return string(e)
}

func (e *ProtocolType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtocolType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtocolType", str)
	}
	return nil
}

func (e ProtocolType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RegisteredTenantType string

const (
	RegisteredTenantTypeExternal        RegisteredTenantType = "EXTERNAL"
	RegisteredTenantTypeRegisteredApp   RegisteredTenantType = "REGISTERED_APP"
	RegisteredTenantTypeManagedIDEntity RegisteredTenantType = "MANAGED_IDENTITY"
)

var AllRegisteredTenantType = []RegisteredTenantType{
	RegisteredTenantTypeExternal,
	RegisteredTenantTypeRegisteredApp,
	RegisteredTenantTypeManagedIDEntity,
}

func (e RegisteredTenantType) IsValid() bool {
	switch e {
	case RegisteredTenantTypeExternal, RegisteredTenantTypeRegisteredApp, RegisteredTenantTypeManagedIDEntity:
		return true
	}
	return false
}

func (e RegisteredTenantType) String() string {
	return string(e)
}

func (e *RegisteredTenantType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegisteredTenantType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegisteredTenantType", str)
	}
	return nil
}

func (e RegisteredTenantType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RemoteCodeExecutionMethod string

const (
	RemoteCodeExecutionMethodPsExec RemoteCodeExecutionMethod = "PS_EXEC"
)

var AllRemoteCodeExecutionMethod = []RemoteCodeExecutionMethod{
	RemoteCodeExecutionMethodPsExec,
}

func (e RemoteCodeExecutionMethod) IsValid() bool {
	switch e {
	case RemoteCodeExecutionMethodPsExec:
		return true
	}
	return false
}

func (e RemoteCodeExecutionMethod) String() string {
	return string(e)
}

func (e *RemoteCodeExecutionMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemoteCodeExecutionMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemoteCodeExecutionMethod", str)
	}
	return nil
}

func (e RemoteCodeExecutionMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of sort options for the `riskByMembershipSummary` query API.
type RiskByMembershipSortKey string

const (
	// Sort by the group name.
	RiskByMembershipSortKeyGroup RiskByMembershipSortKey = "GROUP"
	// Sort by the group risk score.
	RiskByMembershipSortKeyScore RiskByMembershipSortKey = "SCORE"
	// Sort by the group impact score.
	RiskByMembershipSortKeyImpact RiskByMembershipSortKey = "IMPACT"
)

var AllRiskByMembershipSortKey = []RiskByMembershipSortKey{
	RiskByMembershipSortKeyGroup,
	RiskByMembershipSortKeyScore,
	RiskByMembershipSortKeyImpact,
}

func (e RiskByMembershipSortKey) IsValid() bool {
	switch e {
	case RiskByMembershipSortKeyGroup, RiskByMembershipSortKeyScore, RiskByMembershipSortKeyImpact:
		return true
	}
	return false
}

func (e RiskByMembershipSortKey) String() string {
	return string(e)
}

func (e *RiskByMembershipSortKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskByMembershipSortKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskByMembershipSortKey", str)
	}
	return nil
}

func (e RiskByMembershipSortKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of risk factor types.
type RiskFactorType string

const (
	RiskFactorTypeAbnormalServiceAccess                                                        RiskFactorType = "ABNORMAL_SERVICE_ACCESS"
	RiskFactorTypeCredentialTheft                                                              RiskFactorType = "CREDENTIAL_THEFT"
	RiskFactorTypeDailyVolumeAnomaly                                                           RiskFactorType = "DAILY_VOLUME_ANOMALY"
	RiskFactorTypePolicyRuleMatch                                                              RiskFactorType = "POLICY_RULE_MATCH"
	RiskFactorTypeForbiddenCountry                                                             RiskFactorType = "FORBIDDEN_COUNTRY"
	RiskFactorTypeForgedPac                                                                    RiskFactorType = "FORGED_PAC"
	RiskFactorTypeGoldenTicket                                                                 RiskFactorType = "GOLDEN_TICKET"
	RiskFactorTypeIdentityVerificationDeny                                                     RiskFactorType = "IDENTITY_VERIFICATION_DENY"
	RiskFactorTypeIdentityVerificationTimeout                                                  RiskFactorType = "IDENTITY_VERIFICATION_TIMEOUT"
	RiskFactorTypeLateralMovement                                                              RiskFactorType = "LATERAL_MOVEMENT"
	RiskFactorTypeNewServerAccess                                                              RiskFactorType = "NEW_SERVER_ACCESS"
	RiskFactorTypePassTheHash                                                                  RiskFactorType = "PASS_THE_HASH"
	RiskFactorTypePassTheTicket                                                                RiskFactorType = "PASS_THE_TICKET"
	RiskFactorTypePasswordBruteForce                                                           RiskFactorType = "PASSWORD_BRUTE_FORCE"
	RiskFactorTypeSkeletonKey                                                                  RiskFactorType = "SKELETON_KEY"
	RiskFactorTypeStaleAccountUsage                                                            RiskFactorType = "STALE_ACCOUNT_USAGE"
	RiskFactorTypeStaleHostUsage                                                               RiskFactorType = "STALE_HOST_USAGE"
	RiskFactorTypeStaleServiceUsage                                                            RiskFactorType = "STALE_SERVICE_USAGE"
	RiskFactorTypeCredentialScanning                                                           RiskFactorType = "CREDENTIAL_SCANNING"
	RiskFactorTypeGeoAnomaly                                                                   RiskFactorType = "GEO_ANOMALY"
	RiskFactorTypeNewEntityVolume                                                              RiskFactorType = "NEW_ENTITY_VOLUME"
	RiskFactorTypeDcSync                                                                       RiskFactorType = "DC_SYNC"
	RiskFactorTypeHiddenObject                                                                 RiskFactorType = "HIDDEN_OBJECT"
	RiskFactorTypeBadIPReputationUsage                                                         RiskFactorType = "BAD_IP_REPUTATION_USAGE"
	RiskFactorTypeAnomalousRPC                                                                 RiskFactorType = "ANOMALOUS_RPC"
	RiskFactorTypeRemoteCodeExecution                                                          RiskFactorType = "REMOTE_CODE_EXECUTION"
	RiskFactorTypeNtlmRelay                                                                    RiskFactorType = "NTLM_RELAY"
	RiskFactorTypeCredsspAttack                                                                RiskFactorType = "CREDSSP_ATTACK"
	RiskFactorTypeLdapReconnaissance                                                           RiskFactorType = "LDAP_RECONNAISSANCE"
	RiskFactorTypeBronzeBit                                                                    RiskFactorType = "BRONZE_BIT"
	RiskFactorTypeSuspiciousCloudActivityMl                                                    RiskFactorType = "SUSPICIOUS_CLOUD_ACTIVITY_ML"
	RiskFactorTypeAgedPassword                                                                 RiskFactorType = "AGED_PASSWORD"
	RiskFactorTypeKrbtgtAgedPassword                                                           RiskFactorType = "KRBTGT_AGED_PASSWORD"
	RiskFactorTypeAssociationWithRiskyEndpoint                                                 RiskFactorType = "ASSOCIATION_WITH_RISKY_ENDPOINT"
	RiskFactorTypeNeverExpiresPassword                                                         RiskFactorType = "NEVER_EXPIRES_PASSWORD"
	RiskFactorTypeInsufficientPasswordRotation                                                 RiskFactorType = "INSUFFICIENT_PASSWORD_ROTATION"
	RiskFactorTypeExposedPassword                                                              RiskFactorType = "EXPOSED_PASSWORD"
	RiskFactorTypeInactiveAccount                                                              RiskFactorType = "INACTIVE_ACCOUNT"
	RiskFactorTypeSharedEndpoint                                                               RiskFactorType = "SHARED_ENDPOINT"
	RiskFactorTypeSharedUser                                                                   RiskFactorType = "SHARED_USER"
	RiskFactorTypeStaleAccount                                                                 RiskFactorType = "STALE_ACCOUNT"
	RiskFactorTypeUnmanagedHost                                                                RiskFactorType = "UNMANAGED_HOST"
	RiskFactorTypeVpnUsage                                                                     RiskFactorType = "VPN_USAGE"
	RiskFactorTypeVulnerableOs                                                                 RiskFactorType = "VULNERABLE_OS"
	RiskFactorTypeWeakPassword                                                                 RiskFactorType = "WEAK_PASSWORD"
	RiskFactorTypeWeakPasswordPolicy                                                           RiskFactorType = "WEAK_PASSWORD_POLICY"
	RiskFactorTypeDuplicatePassword                                                            RiskFactorType = "DUPLICATE_PASSWORD"
	RiskFactorTypeWatched                                                                      RiskFactorType = "WATCHED"
	RiskFactorTypeHasSpns                                                                      RiskFactorType = "HAS_SPNS"
	RiskFactorTypeNtlmMovements                                                                RiskFactorType = "NTLM_MOVEMENTS"
	RiskFactorTypeStealthyPrivileges                                                           RiskFactorType = "STEALTHY_PRIVILEGES"
	RiskFactorTypeObjectSidHistoryPrivilegesTakeover                                           RiskFactorType = "OBJECT_SID_HISTORY_PRIVILEGES_TAKEOVER"
	RiskFactorTypePrivilegedMachine                                                            RiskFactorType = "PRIVILEGED_MACHINE"
	RiskFactorTypeGuestAccountEnabled                                                          RiskFactorType = "GUEST_ACCOUNT_ENABLED"
	RiskFactorTypeVulnerableNtlmCompatibilityLevel                                             RiskFactorType = "VULNERABLE_NTLM_COMPATIBILITY_LEVEL"
	RiskFactorTypeSmbSigningDisabled                                                           RiskFactorType = "SMB_SIGNING_DISABLED"
	RiskFactorTypeDuplicatedLocalAdministrator                                                 RiskFactorType = "DUPLICATED_LOCAL_ADMINISTRATOR"
	RiskFactorTypePrivilegedUserUsingUnmanagedEndpoint                                         RiskFactorType = "PRIVILEGED_USER_USING_UNMANAGED_ENDPOINT"
	RiskFactorTypeUnmanagedEndpointUsedByPrivilegedUser                                        RiskFactorType = "UNMANAGED_ENDPOINT_USED_BY_PRIVILEGED_USER"
	RiskFactorTypeSharedEndpointUsedByPrivilegedUser                                           RiskFactorType = "SHARED_ENDPOINT_USED_BY_PRIVILEGED_USER"
	RiskFactorTypeKerberosPreauthNotRequired                                                   RiskFactorType = "KERBEROS_PREAUTH_NOT_REQUIRED"
	RiskFactorTypeDesKeyOnlyKerberosEncryption                                                 RiskFactorType = "DES_KEY_ONLY_KERBEROS_ENCRYPTION"
	RiskFactorTypeLdapSigningDisabled                                                          RiskFactorType = "LDAP_SIGNING_DISABLED"
	RiskFactorTypeLdapsChannelBinding                                                          RiskFactorType = "LDAPS_CHANNEL_BINDING"
	RiskFactorTypeSpoolerServiceRunning                                                        RiskFactorType = "SPOOLER_SERVICE_RUNNING"
	RiskFactorTypeNlaDisabled                                                                  RiskFactorType = "NLA_DISABLED"
	RiskFactorTypeExposedLocalAdmin                                                            RiskFactorType = "EXPOSED_LOCAL_ADMIN"
	RiskFactorTypeHasAttackPath                                                                RiskFactorType = "HAS_ATTACK_PATH"
	RiskFactorTypeUsesLocallyAdministratedMachines                                             RiskFactorType = "USES_LOCALLY_ADMINISTRATED_MACHINES"
	RiskFactorTypeCloudActivityOnVulnerableOs                                                  RiskFactorType = "CLOUD_ACTIVITY_ON_VULNERABLE_OS"
	RiskFactorTypeAzureLegacyProtocolUsage                                                     RiskFactorType = "AZURE_LEGACY_PROTOCOL_USAGE"
	RiskFactorTypeSuspiciousSpn                                                                RiskFactorType = "SUSPICIOUS_SPN"
	RiskFactorTypeSuspiciousUpn                                                                RiskFactorType = "SUSPICIOUS_UPN"
	RiskFactorTypeRiskyLinkedAccount                                                           RiskFactorType = "RISKY_LINKED_ACCOUNT"
	RiskFactorTypeCertificateTemplateAllowsAuthenticationAsAnyDomainUser                       RiskFactorType = "CERTIFICATE_TEMPLATE_ALLOWS_AUTHENTICATION_AS_ANY_DOMAIN_USER"
	RiskFactorTypeAuthenticateAsAnyDomainUserWithCertificateRequestAgentWithoutAnyRestrictions RiskFactorType = "AUTHENTICATE_AS_ANY_DOMAIN_USER_WITH_CERTIFICATE_REQUEST_AGENT_WITHOUT_ANY_RESTRICTIONS"
)

var AllRiskFactorType = []RiskFactorType{
	RiskFactorTypeAbnormalServiceAccess,
	RiskFactorTypeCredentialTheft,
	RiskFactorTypeDailyVolumeAnomaly,
	RiskFactorTypePolicyRuleMatch,
	RiskFactorTypeForbiddenCountry,
	RiskFactorTypeForgedPac,
	RiskFactorTypeGoldenTicket,
	RiskFactorTypeIdentityVerificationDeny,
	RiskFactorTypeIdentityVerificationTimeout,
	RiskFactorTypeLateralMovement,
	RiskFactorTypeNewServerAccess,
	RiskFactorTypePassTheHash,
	RiskFactorTypePassTheTicket,
	RiskFactorTypePasswordBruteForce,
	RiskFactorTypeSkeletonKey,
	RiskFactorTypeStaleAccountUsage,
	RiskFactorTypeStaleHostUsage,
	RiskFactorTypeStaleServiceUsage,
	RiskFactorTypeCredentialScanning,
	RiskFactorTypeGeoAnomaly,
	RiskFactorTypeNewEntityVolume,
	RiskFactorTypeDcSync,
	RiskFactorTypeHiddenObject,
	RiskFactorTypeBadIPReputationUsage,
	RiskFactorTypeAnomalousRPC,
	RiskFactorTypeRemoteCodeExecution,
	RiskFactorTypeNtlmRelay,
	RiskFactorTypeCredsspAttack,
	RiskFactorTypeLdapReconnaissance,
	RiskFactorTypeBronzeBit,
	RiskFactorTypeSuspiciousCloudActivityMl,
	RiskFactorTypeAgedPassword,
	RiskFactorTypeKrbtgtAgedPassword,
	RiskFactorTypeAssociationWithRiskyEndpoint,
	RiskFactorTypeNeverExpiresPassword,
	RiskFactorTypeInsufficientPasswordRotation,
	RiskFactorTypeExposedPassword,
	RiskFactorTypeInactiveAccount,
	RiskFactorTypeSharedEndpoint,
	RiskFactorTypeSharedUser,
	RiskFactorTypeStaleAccount,
	RiskFactorTypeUnmanagedHost,
	RiskFactorTypeVpnUsage,
	RiskFactorTypeVulnerableOs,
	RiskFactorTypeWeakPassword,
	RiskFactorTypeWeakPasswordPolicy,
	RiskFactorTypeDuplicatePassword,
	RiskFactorTypeWatched,
	RiskFactorTypeHasSpns,
	RiskFactorTypeNtlmMovements,
	RiskFactorTypeStealthyPrivileges,
	RiskFactorTypeObjectSidHistoryPrivilegesTakeover,
	RiskFactorTypePrivilegedMachine,
	RiskFactorTypeGuestAccountEnabled,
	RiskFactorTypeVulnerableNtlmCompatibilityLevel,
	RiskFactorTypeSmbSigningDisabled,
	RiskFactorTypeDuplicatedLocalAdministrator,
	RiskFactorTypePrivilegedUserUsingUnmanagedEndpoint,
	RiskFactorTypeUnmanagedEndpointUsedByPrivilegedUser,
	RiskFactorTypeSharedEndpointUsedByPrivilegedUser,
	RiskFactorTypeKerberosPreauthNotRequired,
	RiskFactorTypeDesKeyOnlyKerberosEncryption,
	RiskFactorTypeLdapSigningDisabled,
	RiskFactorTypeLdapsChannelBinding,
	RiskFactorTypeSpoolerServiceRunning,
	RiskFactorTypeNlaDisabled,
	RiskFactorTypeExposedLocalAdmin,
	RiskFactorTypeHasAttackPath,
	RiskFactorTypeUsesLocallyAdministratedMachines,
	RiskFactorTypeCloudActivityOnVulnerableOs,
	RiskFactorTypeAzureLegacyProtocolUsage,
	RiskFactorTypeSuspiciousSpn,
	RiskFactorTypeSuspiciousUpn,
	RiskFactorTypeRiskyLinkedAccount,
	RiskFactorTypeCertificateTemplateAllowsAuthenticationAsAnyDomainUser,
	RiskFactorTypeAuthenticateAsAnyDomainUserWithCertificateRequestAgentWithoutAnyRestrictions,
}

func (e RiskFactorType) IsValid() bool {
	switch e {
	case RiskFactorTypeAbnormalServiceAccess, RiskFactorTypeCredentialTheft, RiskFactorTypeDailyVolumeAnomaly, RiskFactorTypePolicyRuleMatch, RiskFactorTypeForbiddenCountry, RiskFactorTypeForgedPac, RiskFactorTypeGoldenTicket, RiskFactorTypeIdentityVerificationDeny, RiskFactorTypeIdentityVerificationTimeout, RiskFactorTypeLateralMovement, RiskFactorTypeNewServerAccess, RiskFactorTypePassTheHash, RiskFactorTypePassTheTicket, RiskFactorTypePasswordBruteForce, RiskFactorTypeSkeletonKey, RiskFactorTypeStaleAccountUsage, RiskFactorTypeStaleHostUsage, RiskFactorTypeStaleServiceUsage, RiskFactorTypeCredentialScanning, RiskFactorTypeGeoAnomaly, RiskFactorTypeNewEntityVolume, RiskFactorTypeDcSync, RiskFactorTypeHiddenObject, RiskFactorTypeBadIPReputationUsage, RiskFactorTypeAnomalousRPC, RiskFactorTypeRemoteCodeExecution, RiskFactorTypeNtlmRelay, RiskFactorTypeCredsspAttack, RiskFactorTypeLdapReconnaissance, RiskFactorTypeBronzeBit, RiskFactorTypeSuspiciousCloudActivityMl, RiskFactorTypeAgedPassword, RiskFactorTypeKrbtgtAgedPassword, RiskFactorTypeAssociationWithRiskyEndpoint, RiskFactorTypeNeverExpiresPassword, RiskFactorTypeInsufficientPasswordRotation, RiskFactorTypeExposedPassword, RiskFactorTypeInactiveAccount, RiskFactorTypeSharedEndpoint, RiskFactorTypeSharedUser, RiskFactorTypeStaleAccount, RiskFactorTypeUnmanagedHost, RiskFactorTypeVpnUsage, RiskFactorTypeVulnerableOs, RiskFactorTypeWeakPassword, RiskFactorTypeWeakPasswordPolicy, RiskFactorTypeDuplicatePassword, RiskFactorTypeWatched, RiskFactorTypeHasSpns, RiskFactorTypeNtlmMovements, RiskFactorTypeStealthyPrivileges, RiskFactorTypeObjectSidHistoryPrivilegesTakeover, RiskFactorTypePrivilegedMachine, RiskFactorTypeGuestAccountEnabled, RiskFactorTypeVulnerableNtlmCompatibilityLevel, RiskFactorTypeSmbSigningDisabled, RiskFactorTypeDuplicatedLocalAdministrator, RiskFactorTypePrivilegedUserUsingUnmanagedEndpoint, RiskFactorTypeUnmanagedEndpointUsedByPrivilegedUser, RiskFactorTypeSharedEndpointUsedByPrivilegedUser, RiskFactorTypeKerberosPreauthNotRequired, RiskFactorTypeDesKeyOnlyKerberosEncryption, RiskFactorTypeLdapSigningDisabled, RiskFactorTypeLdapsChannelBinding, RiskFactorTypeSpoolerServiceRunning, RiskFactorTypeNlaDisabled, RiskFactorTypeExposedLocalAdmin, RiskFactorTypeHasAttackPath, RiskFactorTypeUsesLocallyAdministratedMachines, RiskFactorTypeCloudActivityOnVulnerableOs, RiskFactorTypeAzureLegacyProtocolUsage, RiskFactorTypeSuspiciousSpn, RiskFactorTypeSuspiciousUpn, RiskFactorTypeRiskyLinkedAccount, RiskFactorTypeCertificateTemplateAllowsAuthenticationAsAnyDomainUser, RiskFactorTypeAuthenticateAsAnyDomainUserWithCertificateRequestAgentWithoutAnyRestrictions:
		return true
	}
	return false
}

func (e RiskFactorType) String() string {
	return string(e)
}

func (e *RiskFactorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskFactorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskFactorType", str)
	}
	return nil
}

func (e RiskFactorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RuleAction string

const (
	RuleActionAllow               RuleAction = "ALLOW"
	RuleActionBlock               RuleAction = "BLOCK"
	RuleActionMfa                 RuleAction = "MFA"
	RuleActionForcePasswordChange RuleAction = "FORCE_PASSWORD_CHANGE"
	RuleActionEmailVerification   RuleAction = "EMAIL_VERIFICATION"
	RuleActionAddToWatchList      RuleAction = "ADD_TO_WATCH_LIST"
	RuleActionSmsAlert            RuleAction = "SMS_ALERT"
	RuleActionApplySsoPolicy      RuleAction = "APPLY_SSO_POLICY"
)

var AllRuleAction = []RuleAction{
	RuleActionAllow,
	RuleActionBlock,
	RuleActionMfa,
	RuleActionForcePasswordChange,
	RuleActionEmailVerification,
	RuleActionAddToWatchList,
	RuleActionSmsAlert,
	RuleActionApplySsoPolicy,
}

func (e RuleAction) IsValid() bool {
	switch e {
	case RuleActionAllow, RuleActionBlock, RuleActionMfa, RuleActionForcePasswordChange, RuleActionEmailVerification, RuleActionAddToWatchList, RuleActionSmsAlert, RuleActionApplySsoPolicy:
		return true
	}
	return false
}

func (e RuleAction) String() string {
	return string(e)
}

func (e *RuleAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuleAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuleAction", str)
	}
	return nil
}

func (e RuleAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RuleTrigger string

const (
	RuleTriggerAccess          RuleTrigger = "access"
	RuleTriggerAccountEvent    RuleTrigger = "accountEvent"
	RuleTriggerFederatedAccess RuleTrigger = "federatedAccess"
	RuleTriggerAlert           RuleTrigger = "alert"
)

var AllRuleTrigger = []RuleTrigger{
	RuleTriggerAccess,
	RuleTriggerAccountEvent,
	RuleTriggerFederatedAccess,
	RuleTriggerAlert,
}

func (e RuleTrigger) IsValid() bool {
	switch e {
	case RuleTriggerAccess, RuleTriggerAccountEvent, RuleTriggerFederatedAccess, RuleTriggerAlert:
		return true
	}
	return false
}

func (e RuleTrigger) String() string {
	return string(e)
}

func (e *RuleTrigger) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuleTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuleTrigger", str)
	}
	return nil
}

func (e RuleTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScoreLevel string

const (
	ScoreLevelLow    ScoreLevel = "LOW"
	ScoreLevelMedium ScoreLevel = "MEDIUM"
	ScoreLevelHigh   ScoreLevel = "HIGH"
)

var AllScoreLevel = []ScoreLevel{
	ScoreLevelLow,
	ScoreLevelMedium,
	ScoreLevelHigh,
}

func (e ScoreLevel) IsValid() bool {
	switch e {
	case ScoreLevelLow, ScoreLevelMedium, ScoreLevelHigh:
		return true
	}
	return false
}

func (e ScoreLevel) String() string {
	return string(e)
}

func (e *ScoreLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScoreLevel", str)
	}
	return nil
}

func (e ScoreLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScoreSeverity string

const (
	ScoreSeverityNormal ScoreSeverity = "NORMAL"
	ScoreSeverityMedium ScoreSeverity = "MEDIUM"
	ScoreSeverityHigh   ScoreSeverity = "HIGH"
)

var AllScoreSeverity = []ScoreSeverity{
	ScoreSeverityNormal,
	ScoreSeverityMedium,
	ScoreSeverityHigh,
}

func (e ScoreSeverity) IsValid() bool {
	switch e {
	case ScoreSeverityNormal, ScoreSeverityMedium, ScoreSeverityHigh:
		return true
	}
	return false
}

func (e ScoreSeverity) String() string {
	return string(e)
}

func (e *ScoreSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScoreSeverity", str)
	}
	return nil
}

func (e ScoreSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SecurityAssessmentTimeResolution string

const (
	SecurityAssessmentTimeResolutionHour SecurityAssessmentTimeResolution = "HOUR"
	SecurityAssessmentTimeResolutionDay  SecurityAssessmentTimeResolution = "DAY"
	SecurityAssessmentTimeResolutionWeek SecurityAssessmentTimeResolution = "WEEK"
)

var AllSecurityAssessmentTimeResolution = []SecurityAssessmentTimeResolution{
	SecurityAssessmentTimeResolutionHour,
	SecurityAssessmentTimeResolutionDay,
	SecurityAssessmentTimeResolutionWeek,
}

func (e SecurityAssessmentTimeResolution) IsValid() bool {
	switch e {
	case SecurityAssessmentTimeResolutionHour, SecurityAssessmentTimeResolutionDay, SecurityAssessmentTimeResolutionWeek:
		return true
	}
	return false
}

func (e SecurityAssessmentTimeResolution) String() string {
	return string(e)
}

func (e *SecurityAssessmentTimeResolution) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityAssessmentTimeResolution(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityAssessmentTimeResolution", str)
	}
	return nil
}

func (e SecurityAssessmentTimeResolution) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceType string

const (
	ServiceTypeLdap           ServiceType = "LDAP"
	ServiceTypeWeb            ServiceType = "WEB"
	ServiceTypeFileShare      ServiceType = "FILE_SHARE"
	ServiceTypeDb             ServiceType = "DB"
	ServiceTypeRPCSs          ServiceType = "RPCSS"
	ServiceTypeRemoteDesktop  ServiceType = "REMOTE_DESKTOP"
	ServiceTypeSccm           ServiceType = "SCCM"
	ServiceTypeSip            ServiceType = "SIP"
	ServiceTypeDNS            ServiceType = "DNS"
	ServiceTypeMail           ServiceType = "MAIL"
	ServiceTypeNtlm           ServiceType = "NTLM"
	ServiceTypeComputerAccess ServiceType = "COMPUTER_ACCESS"
	ServiceTypeGenericCloud   ServiceType = "GENERIC_CLOUD"
	ServiceTypeServiceAccount ServiceType = "SERVICE_ACCOUNT"
	ServiceTypeUnknown        ServiceType = "UNKNOWN"
)

var AllServiceType = []ServiceType{
	ServiceTypeLdap,
	ServiceTypeWeb,
	ServiceTypeFileShare,
	ServiceTypeDb,
	ServiceTypeRPCSs,
	ServiceTypeRemoteDesktop,
	ServiceTypeSccm,
	ServiceTypeSip,
	ServiceTypeDNS,
	ServiceTypeMail,
	ServiceTypeNtlm,
	ServiceTypeComputerAccess,
	ServiceTypeGenericCloud,
	ServiceTypeServiceAccount,
	ServiceTypeUnknown,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeLdap, ServiceTypeWeb, ServiceTypeFileShare, ServiceTypeDb, ServiceTypeRPCSs, ServiceTypeRemoteDesktop, ServiceTypeSccm, ServiceTypeSip, ServiceTypeDNS, ServiceTypeMail, ServiceTypeNtlm, ServiceTypeComputerAccess, ServiceTypeGenericCloud, ServiceTypeServiceAccount, ServiceTypeUnknown:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SignInAudience string

const (
	SignInAudienceAzureADMyOrg                       SignInAudience = "AzureADMyOrg"
	SignInAudienceAzureADMultipleOrgs                SignInAudience = "AzureADMultipleOrgs"
	SignInAudienceAzureADandPersonalMicrosoftAccount SignInAudience = "AzureADandPersonalMicrosoftAccount"
	SignInAudiencePersonalMicrosoftAccount           SignInAudience = "PersonalMicrosoftAccount"
)

var AllSignInAudience = []SignInAudience{
	SignInAudienceAzureADMyOrg,
	SignInAudienceAzureADMultipleOrgs,
	SignInAudienceAzureADandPersonalMicrosoftAccount,
	SignInAudiencePersonalMicrosoftAccount,
}

func (e SignInAudience) IsValid() bool {
	switch e {
	case SignInAudienceAzureADMyOrg, SignInAudienceAzureADMultipleOrgs, SignInAudienceAzureADandPersonalMicrosoftAccount, SignInAudiencePersonalMicrosoftAccount:
		return true
	}
	return false
}

func (e SignInAudience) String() string {
	return string(e)
}

func (e *SignInAudience) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SignInAudience(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SignInAudience", str)
	}
	return nil
}

func (e SignInAudience) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SmbDialect string

const (
	SmbDialectSmb1     SmbDialect = "SMB_1"
	SmbDialectSmb2_0_2 SmbDialect = "SMB_2_0_2"
	SmbDialectSmb2_1   SmbDialect = "SMB_2_1"
	SmbDialectSmb3_0   SmbDialect = "SMB_3_0"
	SmbDialectSmb3_0_2 SmbDialect = "SMB_3_0_2"
	SmbDialectSmb3_1_1 SmbDialect = "SMB_3_1_1"
)

var AllSmbDialect = []SmbDialect{
	SmbDialectSmb1,
	SmbDialectSmb2_0_2,
	SmbDialectSmb2_1,
	SmbDialectSmb3_0,
	SmbDialectSmb3_0_2,
	SmbDialectSmb3_1_1,
}

func (e SmbDialect) IsValid() bool {
	switch e {
	case SmbDialectSmb1, SmbDialectSmb2_0_2, SmbDialectSmb2_1, SmbDialectSmb3_0, SmbDialectSmb3_0_2, SmbDialectSmb3_1_1:
		return true
	}
	return false
}

func (e SmbDialect) String() string {
	return string(e)
}

func (e *SmbDialect) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmbDialect(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmbDialect", str)
	}
	return nil
}

func (e SmbDialect) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	SortOrderAscending  SortOrder = "ASCENDING"
	SortOrderDescending SortOrder = "DESCENDING"
)

var AllSortOrder = []SortOrder{
	SortOrderAscending,
	SortOrderDescending,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAscending, SortOrderDescending:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SsoError string

const (
	SsoErrorInvalidCredentials SsoError = "INVALID_CREDENTIALS"
	SsoErrorLockedOut          SsoError = "LOCKED_OUT"
	SsoErrorBadPassword        SsoError = "BAD_PASSWORD"
	SsoErrorBadUsername        SsoError = "BAD_USERNAME"
	SsoErrorVerificationError  SsoError = "VERIFICATION_ERROR"
	SsoErrorPasswordExpired    SsoError = "PASSWORD_EXPIRED"
	SsoErrorSessionExpired     SsoError = "SESSION_EXPIRED"
	SsoErrorAccountDisabled    SsoError = "ACCOUNT_DISABLED"
	SsoErrorAuthorizationError SsoError = "AUTHORIZATION_ERROR"
	SsoErrorMaliciousIP        SsoError = "MALICIOUS_IP"
	SsoErrorUnknown            SsoError = "UNKNOWN"
)

var AllSsoError = []SsoError{
	SsoErrorInvalidCredentials,
	SsoErrorLockedOut,
	SsoErrorBadPassword,
	SsoErrorBadUsername,
	SsoErrorVerificationError,
	SsoErrorPasswordExpired,
	SsoErrorSessionExpired,
	SsoErrorAccountDisabled,
	SsoErrorAuthorizationError,
	SsoErrorMaliciousIP,
	SsoErrorUnknown,
}

func (e SsoError) IsValid() bool {
	switch e {
	case SsoErrorInvalidCredentials, SsoErrorLockedOut, SsoErrorBadPassword, SsoErrorBadUsername, SsoErrorVerificationError, SsoErrorPasswordExpired, SsoErrorSessionExpired, SsoErrorAccountDisabled, SsoErrorAuthorizationError, SsoErrorMaliciousIP, SsoErrorUnknown:
		return true
	}
	return false
}

func (e SsoError) String() string {
	return string(e)
}

func (e *SsoError) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SsoError(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SsoError", str)
	}
	return nil
}

func (e SsoError) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SystemComponent string

const (
	SystemComponentManagement  SystemComponent = "MANAGEMENT"
	SystemComponentEnforcement SystemComponent = "ENFORCEMENT"
	SystemComponentDetection   SystemComponent = "DETECTION"
)

var AllSystemComponent = []SystemComponent{
	SystemComponentManagement,
	SystemComponentEnforcement,
	SystemComponentDetection,
}

func (e SystemComponent) IsValid() bool {
	switch e {
	case SystemComponentManagement, SystemComponentEnforcement, SystemComponentDetection:
		return true
	}
	return false
}

func (e SystemComponent) String() string {
	return string(e)
}

func (e *SystemComponent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemComponent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemComponent", str)
	}
	return nil
}

func (e SystemComponent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SystemLoginFailureReason string

const (
	SystemLoginFailureReasonUnknown            SystemLoginFailureReason = "UNKNOWN"
	SystemLoginFailureReasonInvalidUsername    SystemLoginFailureReason = "INVALID_USERNAME"
	SystemLoginFailureReasonWrongPassword      SystemLoginFailureReason = "WRONG_PASSWORD"
	SystemLoginFailureReasonInvalidCredentials SystemLoginFailureReason = "INVALID_CREDENTIALS"
	SystemLoginFailureReasonUnauthorized       SystemLoginFailureReason = "UNAUTHORIZED"
	SystemLoginFailureReasonMfaDeny            SystemLoginFailureReason = "MFA_DENY"
	SystemLoginFailureReasonMfaTimeout         SystemLoginFailureReason = "MFA_TIMEOUT"
	SystemLoginFailureReasonTimeout            SystemLoginFailureReason = "TIMEOUT"
)

var AllSystemLoginFailureReason = []SystemLoginFailureReason{
	SystemLoginFailureReasonUnknown,
	SystemLoginFailureReasonInvalidUsername,
	SystemLoginFailureReasonWrongPassword,
	SystemLoginFailureReasonInvalidCredentials,
	SystemLoginFailureReasonUnauthorized,
	SystemLoginFailureReasonMfaDeny,
	SystemLoginFailureReasonMfaTimeout,
	SystemLoginFailureReasonTimeout,
}

func (e SystemLoginFailureReason) IsValid() bool {
	switch e {
	case SystemLoginFailureReasonUnknown, SystemLoginFailureReasonInvalidUsername, SystemLoginFailureReasonWrongPassword, SystemLoginFailureReasonInvalidCredentials, SystemLoginFailureReasonUnauthorized, SystemLoginFailureReasonMfaDeny, SystemLoginFailureReasonMfaTimeout, SystemLoginFailureReasonTimeout:
		return true
	}
	return false
}

func (e SystemLoginFailureReason) String() string {
	return string(e)
}

func (e *SystemLoginFailureReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemLoginFailureReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemLoginFailureReason", str)
	}
	return nil
}

func (e SystemLoginFailureReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of `SystemUser` types.
type SystemUserType string

const (
	SystemUserTypeCs         SystemUserType = "CS"
	SystemUserTypeCsToken    SystemUserType = "CS_TOKEN"
	SystemUserTypeLegacyUser SystemUserType = "LEGACY_USER"
)

var AllSystemUserType = []SystemUserType{
	SystemUserTypeCs,
	SystemUserTypeCsToken,
	SystemUserTypeLegacyUser,
}

func (e SystemUserType) IsValid() bool {
	switch e {
	case SystemUserTypeCs, SystemUserTypeCsToken, SystemUserTypeLegacyUser:
		return true
	}
	return false
}

func (e SystemUserType) String() string {
	return string(e)
}

func (e *SystemUserType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemUserType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemUserType", str)
	}
	return nil
}

func (e SystemUserType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// An enumeration of `timeline` event categories, each representing multiple
// `TimelineEventType` values. They can be used to restrict event types instead of
// or together with the exact event types in `timeline` query criteria.
//
// These categories form logical groups for timeline events, and any event type can
// belong to multiple categories. Moreover, the mapping between categories to event
// types may change between versions.
//
// See the `categories` timeline query argument for additional information on the usage of this enumeration.
type TimelineEventCategory string

const (
	// The category for event types indicating network activities, such as authentication and service accesses.
	TimelineEventCategoryActivity TimelineEventCategory = "ACTIVITY"
	// The category for audit log event types. This category is used by the system audit log page.
	TimelineEventCategoryAudit TimelineEventCategory = "AUDIT"
	// The category for all event types focused on a single `Entity`. This category
	// is used by the Entity page "Timeline" in the user interface.
	TimelineEventCategoryEntity TimelineEventCategory = "ENTITY"
	// The category for all event types representing system notifications. This
	// category is used by the Notifications page in the user interface.
	TimelineEventCategoryNotification TimelineEventCategory = "NOTIFICATION"
	// The category for all policy-related event types, used by the policy audit log.
	TimelineEventCategoryPolicy TimelineEventCategory = "POLICY"
	// The category for all system-related event types.
	TimelineEventCategorySystem TimelineEventCategory = "SYSTEM"
	// The category for threat-related event types, such as alerts and score escalations.
	TimelineEventCategoryThreat TimelineEventCategory = "THREAT"
	// The category for system-notification event types related to coverage issues.
	TimelineEventCategorySystemCoverageNotification TimelineEventCategory = "SYSTEM_COVERAGE_NOTIFICATION"
	// The category for system-notification event types related to software updates.
	TimelineEventCategorySoftwareUpdate TimelineEventCategory = "SOFTWARE_UPDATE"
	// The category for system-notification event types related to configured connectors.
	TimelineEventCategoryConnectorNotification TimelineEventCategory = "CONNECTOR_NOTIFICATION"
	// The category for all event types which may be Threat Hunter queries.
	TimelineEventCategoryThreatHunter TimelineEventCategory = "THREAT_HUNTER"
)

var AllTimelineEventCategory = []TimelineEventCategory{
	TimelineEventCategoryActivity,
	TimelineEventCategoryAudit,
	TimelineEventCategoryEntity,
	TimelineEventCategoryNotification,
	TimelineEventCategoryPolicy,
	TimelineEventCategorySystem,
	TimelineEventCategoryThreat,
	TimelineEventCategorySystemCoverageNotification,
	TimelineEventCategorySoftwareUpdate,
	TimelineEventCategoryConnectorNotification,
	TimelineEventCategoryThreatHunter,
}

func (e TimelineEventCategory) IsValid() bool {
	switch e {
	case TimelineEventCategoryActivity, TimelineEventCategoryAudit, TimelineEventCategoryEntity, TimelineEventCategoryNotification, TimelineEventCategoryPolicy, TimelineEventCategorySystem, TimelineEventCategoryThreat, TimelineEventCategorySystemCoverageNotification, TimelineEventCategorySoftwareUpdate, TimelineEventCategoryConnectorNotification, TimelineEventCategoryThreatHunter:
		return true
	}
	return false
}

func (e TimelineEventCategory) String() string {
	return string(e)
}

func (e *TimelineEventCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineEventCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineEventCategory", str)
	}
	return nil
}

func (e TimelineEventCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineEventSeverity string

const (
	TimelineEventSeverityNeutral   TimelineEventSeverity = "NEUTRAL"
	TimelineEventSeverityModerate  TimelineEventSeverity = "MODERATE"
	TimelineEventSeverityImportant TimelineEventSeverity = "IMPORTANT"
)

var AllTimelineEventSeverity = []TimelineEventSeverity{
	TimelineEventSeverityNeutral,
	TimelineEventSeverityModerate,
	TimelineEventSeverityImportant,
}

func (e TimelineEventSeverity) IsValid() bool {
	switch e {
	case TimelineEventSeverityNeutral, TimelineEventSeverityModerate, TimelineEventSeverityImportant:
		return true
	}
	return false
}

func (e TimelineEventSeverity) String() string {
	return string(e)
}

func (e *TimelineEventSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineEventSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineEventSeverity", str)
	}
	return nil
}

func (e TimelineEventSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineEventType string

const (
	TimelineEventTypeSuccessfulAuthentication                     TimelineEventType = "SUCCESSFUL_AUTHENTICATION"
	TimelineEventTypeFailedAuthentication                         TimelineEventType = "FAILED_AUTHENTICATION"
	TimelineEventTypeServiceAccess                                TimelineEventType = "SERVICE_ACCESS"
	TimelineEventTypeDcerpcOperation                              TimelineEventType = "DCERPC_OPERATION"
	TimelineEventTypeRemoteCodeExecution                          TimelineEventType = "REMOTE_CODE_EXECUTION"
	TimelineEventTypeFileOperation                                TimelineEventType = "FILE_OPERATION"
	TimelineEventTypeLdapSearch                                   TimelineEventType = "LDAP_SEARCH"
	TimelineEventTypeAccountCreated                               TimelineEventType = "ACCOUNT_CREATED"
	TimelineEventTypePasswordChange                               TimelineEventType = "PASSWORD_CHANGE"
	TimelineEventTypeAccountNameChange                            TimelineEventType = "ACCOUNT_NAME_CHANGE"
	TimelineEventTypeDepartmentChange                             TimelineEventType = "DEPARTMENT_CHANGE"
	TimelineEventTypeOuChange                                     TimelineEventType = "OU_CHANGE"
	TimelineEventTypeEmailAddressChange                           TimelineEventType = "EMAIL_ADDRESS_CHANGE"
	TimelineEventTypeAccountEnabled                               TimelineEventType = "ACCOUNT_ENABLED"
	TimelineEventTypeAccountDisabled                              TimelineEventType = "ACCOUNT_DISABLED"
	TimelineEventTypeAccountLocked                                TimelineEventType = "ACCOUNT_LOCKED"
	TimelineEventTypeAccountUnlocked                              TimelineEventType = "ACCOUNT_UNLOCKED"
	TimelineEventTypeEntityResurgence                             TimelineEventType = "ENTITY_RESURGENCE"
	TimelineEventTypeEntityInactive                               TimelineEventType = "ENTITY_INACTIVE"
	TimelineEventTypeEntityStale                                  TimelineEventType = "ENTITY_STALE"
	TimelineEventTypeEntityShared                                 TimelineEventType = "ENTITY_SHARED"
	TimelineEventTypeEntityNotShared                              TimelineEventType = "ENTITY_NOT_SHARED"
	TimelineEventTypeEntityLearned                                TimelineEventType = "ENTITY_LEARNED"
	TimelineEventTypeEntityMarked                                 TimelineEventType = "ENTITY_MARKED"
	TimelineEventTypeEntityUnmarked                               TimelineEventType = "ENTITY_UNMARKED"
	TimelineEventTypeEntityWatched                                TimelineEventType = "ENTITY_WATCHED"
	TimelineEventTypeEntityUnwatched                              TimelineEventType = "ENTITY_UNWATCHED"
	TimelineEventTypeEntityArchived                               TimelineEventType = "ENTITY_ARCHIVED"
	TimelineEventTypeEntityUnarchived                             TimelineEventType = "ENTITY_UNARCHIVED"
	TimelineEventTypeExposedPassword                              TimelineEventType = "EXPOSED_PASSWORD"
	TimelineEventTypeWeakPassword                                 TimelineEventType = "WEAK_PASSWORD"
	TimelineEventTypePrivilegeEscalation                          TimelineEventType = "PRIVILEGE_ESCALATION"
	TimelineEventTypePrivilegeDeEscalation                        TimelineEventType = "PRIVILEGE_DE_ESCALATION"
	TimelineEventTypeScoreEscalation                              TimelineEventType = "SCORE_ESCALATION"
	TimelineEventTypeScoreDeEscalation                            TimelineEventType = "SCORE_DE_ESCALATION"
	TimelineEventTypeAuthorizerChange                             TimelineEventType = "AUTHORIZER_CHANGE"
	TimelineEventTypeLinkedAccountChange                          TimelineEventType = "LINKED_ACCOUNT_CHANGE"
	TimelineEventTypeAlert                                        TimelineEventType = "ALERT"
	TimelineEventTypeNewIncident                                  TimelineEventType = "NEW_INCIDENT"
	TimelineEventTypeIncidentTypeChange                           TimelineEventType = "INCIDENT_TYPE_CHANGE"
	TimelineEventTypeIncidentSeverityChange                       TimelineEventType = "INCIDENT_SEVERITY_CHANGE"
	TimelineEventTypeIncidentLifeCycleStageChange                 TimelineEventType = "INCIDENT_LIFE_CYCLE_STAGE_CHANGE"
	TimelineEventTypePolicyRuleMatch                              TimelineEventType = "POLICY_RULE_MATCH"
	TimelineEventTypeMfaServiceEnrollment                         TimelineEventType = "MFA_SERVICE_ENROLLMENT"
	TimelineEventTypeConnectorConfigurationModified               TimelineEventType = "CONNECTOR_CONFIGURATION_MODIFIED"
	TimelineEventTypeConnectorConfigurationAdded                  TimelineEventType = "CONNECTOR_CONFIGURATION_ADDED"
	TimelineEventTypeConnectorConfigurationDeleted                TimelineEventType = "CONNECTOR_CONFIGURATION_DELETED"
	TimelineEventTypePolicyRuleModified                           TimelineEventType = "POLICY_RULE_MODIFIED"
	TimelineEventTypePolicyRuleAdded                              TimelineEventType = "POLICY_RULE_ADDED"
	TimelineEventTypePolicyRuleDeleted                            TimelineEventType = "POLICY_RULE_DELETED"
	TimelineEventTypePolicyRulesReordered                         TimelineEventType = "POLICY_RULES_REORDERED"
	TimelineEventTypePolicyApplied                                TimelineEventType = "POLICY_APPLIED"
	TimelineEventTypeAlertExceptionModified                       TimelineEventType = "ALERT_EXCEPTION_MODIFIED"
	TimelineEventTypeReportModified                               TimelineEventType = "REPORT_MODIFIED"
	TimelineEventTypeReportAdded                                  TimelineEventType = "REPORT_ADDED"
	TimelineEventTypeReportDeleted                                TimelineEventType = "REPORT_DELETED"
	TimelineEventTypeEmailNotificationConfigurationModified       TimelineEventType = "EMAIL_NOTIFICATION_CONFIGURATION_MODIFIED"
	TimelineEventTypeDetectionAggressionConfigurationModified     TimelineEventType = "DETECTION_AGGRESSION_CONFIGURATION_MODIFIED"
	TimelineEventTypeRiskFactorsConfigurationModified             TimelineEventType = "RISK_FACTORS_CONFIGURATION_MODIFIED"
	TimelineEventTypeDomainRemoval                                TimelineEventType = "DOMAIN_REMOVAL"
	TimelineEventTypeNetExtractorStoppedPublish                   TimelineEventType = "NET_EXTRACTOR_STOPPED_PUBLISH"
	TimelineEventTypeMfaUIFallbackPeriodChanged                   TimelineEventType = "MFA_UI_FALLBACK_PERIOD_CHANGED"
	TimelineEventTypeUncoveredDomainController                    TimelineEventType = "UNCOVERED_DOMAIN_CONTROLLER"
	TimelineEventTypeConnectorFailure                             TimelineEventType = "CONNECTOR_FAILURE"
	TimelineEventTypeToolFailure                                  TimelineEventType = "TOOL_FAILURE"
	TimelineEventTypeToolDeleted                                  TimelineEventType = "TOOL_DELETED"
	TimelineEventTypeIDPContainerWatchdogEvent                    TimelineEventType = "IDP_CONTAINER_WATCHDOG_EVENT"
	TimelineEventTypeIDPContainerGenericWatchdogEvent             TimelineEventType = "IDP_CONTAINER_GENERIC_WATCHDOG_EVENT"
	TimelineEventTypeNetExtractorStoppedPolicy                    TimelineEventType = "NET_EXTRACTOR_STOPPED_POLICY"
	TimelineEventTypeNetExtractorStoppedTraffic                   TimelineEventType = "NET_EXTRACTOR_STOPPED_TRAFFIC"
	TimelineEventTypeNetExtractorWatchdogAnalyzerServiceRestart   TimelineEventType = "NET_EXTRACTOR_WATCHDOG_ANALYZER_SERVICE_RESTART"
	TimelineEventTypeNetExtractorWatchdogManagementServiceRestart TimelineEventType = "NET_EXTRACTOR_WATCHDOG_MANAGEMENT_SERVICE_RESTART"
	TimelineEventTypeNetExtractorWatchdogMonitoringServiceRestart TimelineEventType = "NET_EXTRACTOR_WATCHDOG_MONITORING_SERVICE_RESTART"
)

var AllTimelineEventType = []TimelineEventType{
	TimelineEventTypeSuccessfulAuthentication,
	TimelineEventTypeFailedAuthentication,
	TimelineEventTypeServiceAccess,
	TimelineEventTypeDcerpcOperation,
	TimelineEventTypeRemoteCodeExecution,
	TimelineEventTypeFileOperation,
	TimelineEventTypeLdapSearch,
	TimelineEventTypeAccountCreated,
	TimelineEventTypePasswordChange,
	TimelineEventTypeAccountNameChange,
	TimelineEventTypeDepartmentChange,
	TimelineEventTypeOuChange,
	TimelineEventTypeEmailAddressChange,
	TimelineEventTypeAccountEnabled,
	TimelineEventTypeAccountDisabled,
	TimelineEventTypeAccountLocked,
	TimelineEventTypeAccountUnlocked,
	TimelineEventTypeEntityResurgence,
	TimelineEventTypeEntityInactive,
	TimelineEventTypeEntityStale,
	TimelineEventTypeEntityShared,
	TimelineEventTypeEntityNotShared,
	TimelineEventTypeEntityLearned,
	TimelineEventTypeEntityMarked,
	TimelineEventTypeEntityUnmarked,
	TimelineEventTypeEntityWatched,
	TimelineEventTypeEntityUnwatched,
	TimelineEventTypeEntityArchived,
	TimelineEventTypeEntityUnarchived,
	TimelineEventTypeExposedPassword,
	TimelineEventTypeWeakPassword,
	TimelineEventTypePrivilegeEscalation,
	TimelineEventTypePrivilegeDeEscalation,
	TimelineEventTypeScoreEscalation,
	TimelineEventTypeScoreDeEscalation,
	TimelineEventTypeAuthorizerChange,
	TimelineEventTypeLinkedAccountChange,
	TimelineEventTypeAlert,
	TimelineEventTypeNewIncident,
	TimelineEventTypeIncidentTypeChange,
	TimelineEventTypeIncidentSeverityChange,
	TimelineEventTypeIncidentLifeCycleStageChange,
	TimelineEventTypePolicyRuleMatch,
	TimelineEventTypeMfaServiceEnrollment,
	TimelineEventTypeConnectorConfigurationModified,
	TimelineEventTypeConnectorConfigurationAdded,
	TimelineEventTypeConnectorConfigurationDeleted,
	TimelineEventTypePolicyRuleModified,
	TimelineEventTypePolicyRuleAdded,
	TimelineEventTypePolicyRuleDeleted,
	TimelineEventTypePolicyRulesReordered,
	TimelineEventTypePolicyApplied,
	TimelineEventTypeAlertExceptionModified,
	TimelineEventTypeReportModified,
	TimelineEventTypeReportAdded,
	TimelineEventTypeReportDeleted,
	TimelineEventTypeEmailNotificationConfigurationModified,
	TimelineEventTypeDetectionAggressionConfigurationModified,
	TimelineEventTypeRiskFactorsConfigurationModified,
	TimelineEventTypeDomainRemoval,
	TimelineEventTypeNetExtractorStoppedPublish,
	TimelineEventTypeMfaUIFallbackPeriodChanged,
	TimelineEventTypeUncoveredDomainController,
	TimelineEventTypeConnectorFailure,
	TimelineEventTypeToolFailure,
	TimelineEventTypeToolDeleted,
	TimelineEventTypeIDPContainerWatchdogEvent,
	TimelineEventTypeIDPContainerGenericWatchdogEvent,
	TimelineEventTypeNetExtractorStoppedPolicy,
	TimelineEventTypeNetExtractorStoppedTraffic,
	TimelineEventTypeNetExtractorWatchdogAnalyzerServiceRestart,
	TimelineEventTypeNetExtractorWatchdogManagementServiceRestart,
	TimelineEventTypeNetExtractorWatchdogMonitoringServiceRestart,
}

func (e TimelineEventType) IsValid() bool {
	switch e {
	case TimelineEventTypeSuccessfulAuthentication, TimelineEventTypeFailedAuthentication, TimelineEventTypeServiceAccess, TimelineEventTypeDcerpcOperation, TimelineEventTypeRemoteCodeExecution, TimelineEventTypeFileOperation, TimelineEventTypeLdapSearch, TimelineEventTypeAccountCreated, TimelineEventTypePasswordChange, TimelineEventTypeAccountNameChange, TimelineEventTypeDepartmentChange, TimelineEventTypeOuChange, TimelineEventTypeEmailAddressChange, TimelineEventTypeAccountEnabled, TimelineEventTypeAccountDisabled, TimelineEventTypeAccountLocked, TimelineEventTypeAccountUnlocked, TimelineEventTypeEntityResurgence, TimelineEventTypeEntityInactive, TimelineEventTypeEntityStale, TimelineEventTypeEntityShared, TimelineEventTypeEntityNotShared, TimelineEventTypeEntityLearned, TimelineEventTypeEntityMarked, TimelineEventTypeEntityUnmarked, TimelineEventTypeEntityWatched, TimelineEventTypeEntityUnwatched, TimelineEventTypeEntityArchived, TimelineEventTypeEntityUnarchived, TimelineEventTypeExposedPassword, TimelineEventTypeWeakPassword, TimelineEventTypePrivilegeEscalation, TimelineEventTypePrivilegeDeEscalation, TimelineEventTypeScoreEscalation, TimelineEventTypeScoreDeEscalation, TimelineEventTypeAuthorizerChange, TimelineEventTypeLinkedAccountChange, TimelineEventTypeAlert, TimelineEventTypeNewIncident, TimelineEventTypeIncidentTypeChange, TimelineEventTypeIncidentSeverityChange, TimelineEventTypeIncidentLifeCycleStageChange, TimelineEventTypePolicyRuleMatch, TimelineEventTypeMfaServiceEnrollment, TimelineEventTypeConnectorConfigurationModified, TimelineEventTypeConnectorConfigurationAdded, TimelineEventTypeConnectorConfigurationDeleted, TimelineEventTypePolicyRuleModified, TimelineEventTypePolicyRuleAdded, TimelineEventTypePolicyRuleDeleted, TimelineEventTypePolicyRulesReordered, TimelineEventTypePolicyApplied, TimelineEventTypeAlertExceptionModified, TimelineEventTypeReportModified, TimelineEventTypeReportAdded, TimelineEventTypeReportDeleted, TimelineEventTypeEmailNotificationConfigurationModified, TimelineEventTypeDetectionAggressionConfigurationModified, TimelineEventTypeRiskFactorsConfigurationModified, TimelineEventTypeDomainRemoval, TimelineEventTypeNetExtractorStoppedPublish, TimelineEventTypeMfaUIFallbackPeriodChanged, TimelineEventTypeUncoveredDomainController, TimelineEventTypeConnectorFailure, TimelineEventTypeToolFailure, TimelineEventTypeToolDeleted, TimelineEventTypeIDPContainerWatchdogEvent, TimelineEventTypeIDPContainerGenericWatchdogEvent, TimelineEventTypeNetExtractorStoppedPolicy, TimelineEventTypeNetExtractorStoppedTraffic, TimelineEventTypeNetExtractorWatchdogAnalyzerServiceRestart, TimelineEventTypeNetExtractorWatchdogManagementServiceRestart, TimelineEventTypeNetExtractorWatchdogMonitoringServiceRestart:
		return true
	}
	return false
}

func (e TimelineEventType) String() string {
	return string(e)
}

func (e *TimelineEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineEventType", str)
	}
	return nil
}

func (e TimelineEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TLSVersion string

const (
	TLSVersionTLSNoVersion TLSVersion = "TLS_NO_VERSION"
	TLSVersionTLSV1_0      TLSVersion = "TLS_V1_0"
	TLSVersionTLSV1_1      TLSVersion = "TLS_V1_1"
	TLSVersionTLSV1_2      TLSVersion = "TLS_V1_2"
	TLSVersionTLSV1_3      TLSVersion = "TLS_V1_3"
)

var AllTLSVersion = []TLSVersion{
	TLSVersionTLSNoVersion,
	TLSVersionTLSV1_0,
	TLSVersionTLSV1_1,
	TLSVersionTLSV1_2,
	TLSVersionTLSV1_3,
}

func (e TLSVersion) IsValid() bool {
	switch e {
	case TLSVersionTLSNoVersion, TLSVersionTLSV1_0, TLSVersionTLSV1_1, TLSVersionTLSV1_2, TLSVersionTLSV1_3:
		return true
	}
	return false
}

func (e TLSVersion) String() string {
	return string(e)
}

func (e *TLSVersion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLSVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TlsVersion", str)
	}
	return nil
}

func (e TLSVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TrafficInspectionExclusionListProtocol string

const (
	TrafficInspectionExclusionListProtocolTCP TrafficInspectionExclusionListProtocol = "TCP"
	TrafficInspectionExclusionListProtocolUDP TrafficInspectionExclusionListProtocol = "UDP"
)

var AllTrafficInspectionExclusionListProtocol = []TrafficInspectionExclusionListProtocol{
	TrafficInspectionExclusionListProtocolTCP,
	TrafficInspectionExclusionListProtocolUDP,
}

func (e TrafficInspectionExclusionListProtocol) IsValid() bool {
	switch e {
	case TrafficInspectionExclusionListProtocolTCP, TrafficInspectionExclusionListProtocolUDP:
		return true
	}
	return false
}

func (e TrafficInspectionExclusionListProtocol) String() string {
	return string(e)
}

func (e *TrafficInspectionExclusionListProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrafficInspectionExclusionListProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrafficInspectionExclusionListProtocol", str)
	}
	return nil
}

func (e TrafficInspectionExclusionListProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TrafficInspectionExclusionListStatus string

const (
	TrafficInspectionExclusionListStatusActive        TrafficInspectionExclusionListStatus = "ACTIVE"
	TrafficInspectionExclusionListStatusPendingAdd    TrafficInspectionExclusionListStatus = "PENDING_ADD"
	TrafficInspectionExclusionListStatusPendingRemove TrafficInspectionExclusionListStatus = "PENDING_REMOVE"
	TrafficInspectionExclusionListStatusFailedAdd     TrafficInspectionExclusionListStatus = "FAILED_ADD"
)

var AllTrafficInspectionExclusionListStatus = []TrafficInspectionExclusionListStatus{
	TrafficInspectionExclusionListStatusActive,
	TrafficInspectionExclusionListStatusPendingAdd,
	TrafficInspectionExclusionListStatusPendingRemove,
	TrafficInspectionExclusionListStatusFailedAdd,
}

func (e TrafficInspectionExclusionListStatus) IsValid() bool {
	switch e {
	case TrafficInspectionExclusionListStatusActive, TrafficInspectionExclusionListStatusPendingAdd, TrafficInspectionExclusionListStatusPendingRemove, TrafficInspectionExclusionListStatusFailedAdd:
		return true
	}
	return false
}

func (e TrafficInspectionExclusionListStatus) String() string {
	return string(e)
}

func (e *TrafficInspectionExclusionListStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrafficInspectionExclusionListStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrafficInspectionExclusionListStatus", str)
	}
	return nil
}

func (e TrafficInspectionExclusionListStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserAccountControlFlags string

const (
	UserAccountControlFlagsScript                     UserAccountControlFlags = "SCRIPT"
	UserAccountControlFlagsAccountdisable             UserAccountControlFlags = "ACCOUNTDISABLE"
	UserAccountControlFlagsHomedirRequired            UserAccountControlFlags = "HOMEDIR_REQUIRED"
	UserAccountControlFlagsLockout                    UserAccountControlFlags = "LOCKOUT"
	UserAccountControlFlagsPasswdNotreqd              UserAccountControlFlags = "PASSWD_NOTREQD"
	UserAccountControlFlagsPasswdCantChange           UserAccountControlFlags = "PASSWD_CANT_CHANGE"
	UserAccountControlFlagsEncryptedTextPwdAllowed    UserAccountControlFlags = "ENCRYPTED_TEXT_PWD_ALLOWED"
	UserAccountControlFlagsTempDuplicateAccount       UserAccountControlFlags = "TEMP_DUPLICATE_ACCOUNT"
	UserAccountControlFlagsNormalAccount              UserAccountControlFlags = "NORMAL_ACCOUNT"
	UserAccountControlFlagsInterdomainTrustAccount    UserAccountControlFlags = "INTERDOMAIN_TRUST_ACCOUNT"
	UserAccountControlFlagsWorkstationTrustAccount    UserAccountControlFlags = "WORKSTATION_TRUST_ACCOUNT"
	UserAccountControlFlagsServerTrustAccount         UserAccountControlFlags = "SERVER_TRUST_ACCOUNT"
	UserAccountControlFlagsDontExpirePassword         UserAccountControlFlags = "DONT_EXPIRE_PASSWORD"
	UserAccountControlFlagsMnsLogonAccount            UserAccountControlFlags = "MNS_LOGON_ACCOUNT"
	UserAccountControlFlagsSmartcardRequired          UserAccountControlFlags = "SMARTCARD_REQUIRED"
	UserAccountControlFlagsTrustedForDelegation       UserAccountControlFlags = "TRUSTED_FOR_DELEGATION"
	UserAccountControlFlagsNotDelegated               UserAccountControlFlags = "NOT_DELEGATED"
	UserAccountControlFlagsUseDesKeyOnly              UserAccountControlFlags = "USE_DES_KEY_ONLY"
	UserAccountControlFlagsDontReqPreauth             UserAccountControlFlags = "DONT_REQ_PREAUTH"
	UserAccountControlFlagsPasswordExpired            UserAccountControlFlags = "PASSWORD_EXPIRED"
	UserAccountControlFlagsTrustedToAuthForDelegation UserAccountControlFlags = "TRUSTED_TO_AUTH_FOR_DELEGATION"
	UserAccountControlFlagsPartialSecretsAccount      UserAccountControlFlags = "PARTIAL_SECRETS_ACCOUNT"
)

var AllUserAccountControlFlags = []UserAccountControlFlags{
	UserAccountControlFlagsScript,
	UserAccountControlFlagsAccountdisable,
	UserAccountControlFlagsHomedirRequired,
	UserAccountControlFlagsLockout,
	UserAccountControlFlagsPasswdNotreqd,
	UserAccountControlFlagsPasswdCantChange,
	UserAccountControlFlagsEncryptedTextPwdAllowed,
	UserAccountControlFlagsTempDuplicateAccount,
	UserAccountControlFlagsNormalAccount,
	UserAccountControlFlagsInterdomainTrustAccount,
	UserAccountControlFlagsWorkstationTrustAccount,
	UserAccountControlFlagsServerTrustAccount,
	UserAccountControlFlagsDontExpirePassword,
	UserAccountControlFlagsMnsLogonAccount,
	UserAccountControlFlagsSmartcardRequired,
	UserAccountControlFlagsTrustedForDelegation,
	UserAccountControlFlagsNotDelegated,
	UserAccountControlFlagsUseDesKeyOnly,
	UserAccountControlFlagsDontReqPreauth,
	UserAccountControlFlagsPasswordExpired,
	UserAccountControlFlagsTrustedToAuthForDelegation,
	UserAccountControlFlagsPartialSecretsAccount,
}

func (e UserAccountControlFlags) IsValid() bool {
	switch e {
	case UserAccountControlFlagsScript, UserAccountControlFlagsAccountdisable, UserAccountControlFlagsHomedirRequired, UserAccountControlFlagsLockout, UserAccountControlFlagsPasswdNotreqd, UserAccountControlFlagsPasswdCantChange, UserAccountControlFlagsEncryptedTextPwdAllowed, UserAccountControlFlagsTempDuplicateAccount, UserAccountControlFlagsNormalAccount, UserAccountControlFlagsInterdomainTrustAccount, UserAccountControlFlagsWorkstationTrustAccount, UserAccountControlFlagsServerTrustAccount, UserAccountControlFlagsDontExpirePassword, UserAccountControlFlagsMnsLogonAccount, UserAccountControlFlagsSmartcardRequired, UserAccountControlFlagsTrustedForDelegation, UserAccountControlFlagsNotDelegated, UserAccountControlFlagsUseDesKeyOnly, UserAccountControlFlagsDontReqPreauth, UserAccountControlFlagsPasswordExpired, UserAccountControlFlagsTrustedToAuthForDelegation, UserAccountControlFlagsPartialSecretsAccount:
		return true
	}
	return false
}

func (e UserAccountControlFlags) String() string {
	return string(e)
}

func (e *UserAccountControlFlags) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserAccountControlFlags(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserAccountControlFlags", str)
	}
	return nil
}

func (e UserAccountControlFlags) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserEntityClassification string

const (
	UserEntityClassificationHuman        UserEntityClassification = "HUMAN"
	UserEntityClassificationProgrammatic UserEntityClassification = "PROGRAMMATIC"
	UserEntityClassificationExecutive    UserEntityClassification = "EXECUTIVE"
	UserEntityClassificationHoneytoken   UserEntityClassification = "HONEYTOKEN"
)

var AllUserEntityClassification = []UserEntityClassification{
	UserEntityClassificationHuman,
	UserEntityClassificationProgrammatic,
	UserEntityClassificationExecutive,
	UserEntityClassificationHoneytoken,
}

func (e UserEntityClassification) IsValid() bool {
	switch e {
	case UserEntityClassificationHuman, UserEntityClassificationProgrammatic, UserEntityClassificationExecutive, UserEntityClassificationHoneytoken:
		return true
	}
	return false
}

func (e UserEntityClassification) String() string {
	return string(e)
}

func (e *UserEntityClassification) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserEntityClassification(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserEntityClassification", str)
	}
	return nil
}

func (e UserEntityClassification) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
